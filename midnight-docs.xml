This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/develop/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  develop/
    archived-relnotes/
      2023-11_devnet_0_0_2_release_notes.mdx
      2024-02_devnet_0_1_0_release_notes.mdx
      2024-09_testnet_release_notes.mdx
    guides/
      compact-javascript-runtime.mdx
      wallet-dev-guide.mdx
    how-midnight-works/
      _circuit_constraints.mdx
      _circuit_example.mdx
      _ledger_assignments.mdx
      _ledger_example.mdx
      _private_assignments.mdx
      _private_example.mdx
      building-blocks.mdx
      impact.mdx
      index.mdx
      keeping-data-private.mdx
      semantics.mdx
      smart-contracts.mdx
      zswap.mdx
    how-to/
      acquire-tokens.mdx
      fix-version-mismatch-errors.mdx
      lace-wallet.mdx
      nextjs-wallet-connect.mdx
      react-wallet-connect.mdx
      run-proof-server.mdx
    reference/
      compact/
        compact-std-library/
          exports.md
          README.md
        compact-grammar.mdx
        explicit_disclosure.mdx
        index.mdx
        lang-ref.mdx
        ledger-adt.mdx
        opaque_data.mdx
        writing.mdx
      midnight-api/
        compact-runtime/
          classes/
            CompactError.md
            CompactTypeBoolean.md
            CompactTypeBytes.md
            CompactTypeCurvePoint.md
            CompactTypeEnum.md
            CompactTypeField.md
            CompactTypeMerkleTreeDigest.md
            CompactTypeMerkleTreePath.md
            CompactTypeMerkleTreePathEntry.md
            CompactTypeOpaqueString.md
            CompactTypeOpaqueUint8Array.md
            CompactTypeUnsignedInteger.md
            CompactTypeVector.md
            ContractMaintenanceAuthority.md
            ContractOperation.md
            ContractState.md
            CostModel.md
            QueryContext.md
            QueryResults.md
            StateBoundedMerkleTree.md
            StateMap.md
            StateValue.md
            VmResults.md
            VmStack.md
          enumerations/
            NetworkId.md
          functions/
            addField.md
            alignedConcat.md
            assert.md
            bigIntToValue.md
            checkProofData.md
            coinCommitment.md
            constructorContext.md
            contractDependencies.md
            convert_bigint_to_Uint8Array.md
            convert_Uint8Array_to_bigint.md
            convertBytesToField.md
            convertBytesToUint.md
            convertFieldToBytes.md
            createZswapInput.md
            createZswapOutput.md
            decodeCoinInfo.md
            decodeCoinPublicKey.md
            decodeContractAddress.md
            decodeQualifiedCoinInfo.md
            decodeRecipient.md
            decodeTokenType.md
            decodeZswapLocalState.md
            degradeToTransient.md
            dummyContractAddress.md
            ecAdd.md
            ecMul.md
            ecMulGenerator.md
            emptyZswapLocalState.md
            encodeCoinInfo.md
            encodeCoinPublicKey.md
            encodeContractAddress.md
            encodeQualifiedCoinInfo.md
            encodeRecipient.md
            encodeTokenType.md
            encodeZswapLocalState.md
            hasCoinCommitment.md
            hashToCurve.md
            leafHash.md
            maxAlignedSize.md
            mulField.md
            ownPublicKey.md
            persistentCommit.md
            persistentHash.md
            runProgram.md
            sampleContractAddress.md
            sampleSigningKey.md
            sampleTokenType.md
            signatureVerifyingKey.md
            signData.md
            subField.md
            tokenType.md
            transientCommit.md
            transientHash.md
            type_error.md
            upgradeFromTransient.md
            valueToBigInt.md
            verifySignature.md
            witnessContext.md
          interfaces/
            CircuitContext.md
            CircuitResults.md
            CompactType.md
            ConstructorContext.md
            ConstructorResult.md
            CurvePoint.md
            EncodedCoinInfo.md
            EncodedCoinPublicKey.md
            EncodedContractAddress.md
            EncodedQualifiedCoinInfo.md
            EncodedRecipient.md
            EncodedZswapLocalState.md
            MerkleTreeDigest.md
            MerkleTreePath.md
            MerkleTreePathEntry.md
            ProofData.md
            Recipient.md
            WitnessContext.md
            ZswapLocalState.md
          type-aliases/
            AlignedValue.md
            Alignment.md
            AlignmentAtom.md
            AlignmentSegment.md
            BlockContext.md
            CoinCommitment.md
            CoinInfo.md
            CoinPublicKey.md
            ContractAddress.md
            ContractReferenceLocations.md
            DomainSeperator.md
            Effects.md
            Fr.md
            GatherResult.md
            Key.md
            Nonce.md
            Nullifier.md
            Op.md
            QualifiedCoinInfo.md
            Signature.md
            SignatureVerifyingKey.md
            SigningKey.md
            SparseCompactADT.md
            SparseCompactArrayLikeADT.md
            SparseCompactCellADT.md
            SparseCompactContractAddress.md
            SparseCompactListADT.md
            SparseCompactMapADT.md
            SparseCompactSetADT.md
            SparseCompactStruct.md
            SparseCompactType.md
            SparseCompactValue.md
            SparseCompactVector.md
            TokenType.md
            Transcript.md
            Value.md
          variables/
            BooleanDescriptor.md
            Bytes32Descriptor.md
            CoinInfoDescriptor.md
            CoinRecipientDescriptor.md
            ContractAddressDescriptor.md
            DUMMY_ADDRESS.md
            MAX_FIELD.md
            MaxUint8Descriptor.md
            versionString.md
            ZswapCoinPublicKeyDescriptor.md
          globals.md
          README.md
        dapp-connector/
          classes/
            APIError.md
          interfaces/
            DAppConnectorAPI.md
            DAppConnectorWalletAPI.md
            DAppConnectorWalletState.md
            ServiceUriConfig.md
          type-aliases/
            ErrorCode.md
          variables/
            ErrorCodes.md
          globals.md
          README.md
        ledger/
          classes/
            AuthorizedMint.md
            ContractCall.md
            ContractCallPrototype.md
            ContractCallsPrototype.md
            ContractDeploy.md
            ContractMaintenanceAuthority.md
            ContractOperation.md
            ContractOperationVersion.md
            ContractOperationVersionedVerifierKey.md
            ContractState.md
            CostModel.md
            EncryptionSecretKey.md
            Input.md
            LedgerParameters.md
            LedgerState.md
            LocalState.md
            MaintenanceUpdate.md
            MerkleTreeCollapsedUpdate.md
            Offer.md
            Output.md
            PreTranscript.md
            ProofErasedAuthorizedMint.md
            ProofErasedInput.md
            ProofErasedOffer.md
            ProofErasedOutput.md
            ProofErasedTransaction.md
            ProofErasedTransient.md
            QueryContext.md
            QueryResults.md
            ReplaceAuthority.md
            StateBoundedMerkleTree.md
            StateMap.md
            StateValue.md
            SystemTransaction.md
            Transaction.md
            TransactionContext.md
            TransactionCostModel.md
            TransactionResult.md
            Transient.md
            UnprovenAuthorizedMint.md
            UnprovenInput.md
            UnprovenOffer.md
            UnprovenOutput.md
            UnprovenTransaction.md
            UnprovenTransient.md
            VerifierKeyInsert.md
            VerifierKeyRemove.md
            VmResults.md
            VmStack.md
            WellFormedStrictness.md
            ZswapChainState.md
          enumerations/
            NetworkId.md
          functions/
            bigIntModFr.md
            bigIntToValue.md
            checkProofData.md
            coinCommitment.md
            communicationCommitment.md
            communicationCommitmentRandomness.md
            createCoinInfo.md
            decodeCoinInfo.md
            decodeCoinPublicKey.md
            decodeContractAddress.md
            decodeQualifiedCoinInfo.md
            decodeTokenType.md
            degradeToTransient.md
            dummyContractAddress.md
            ecAdd.md
            ecMul.md
            ecMulGenerator.md
            encodeCoinInfo.md
            encodeCoinPublicKey.md
            encodeContractAddress.md
            encodeQualifiedCoinInfo.md
            encodeTokenType.md
            hashToCurve.md
            leafHash.md
            maxAlignedSize.md
            maxField.md
            nativeToken.md
            partitionTranscripts.md
            persistentCommit.md
            persistentHash.md
            runProgram.md
            sampleCoinPublicKey.md
            sampleContractAddress.md
            sampleSigningKey.md
            sampleTokenType.md
            signatureVerifyingKey.md
            signData.md
            tokenType.md
            transientCommit.md
            transientHash.md
            upgradeFromTransient.md
            valueToBigInt.md
            verifySignature.md
          type-aliases/
            AlignedValue.md
            Alignment.md
            AlignmentAtom.md
            AlignmentSegment.md
            BlockContext.md
            CoinCommitment.md
            CoinInfo.md
            CoinPublicKey.md
            CommunicationCommitment.md
            CommunicationCommitmentRand.md
            ContractAction.md
            ContractAddress.md
            DomainSeperator.md
            Effects.md
            EncodedStateValue.md
            EncPublicKey.md
            Fr.md
            GatherResult.md
            Key.md
            Nonce.md
            Nullifier.md
            Op.md
            QualifiedCoinInfo.md
            Signature.md
            SignatureVerifyingKey.md
            SigningKey.md
            SingleUpdate.md
            TokenType.md
            TransactionHash.md
            TransactionId.md
            Transcript.md
            Value.md
          globals.md
          README.md
        midnight-indexer/
          README.md
        midnight-js/
          @midnight-ntwrk/
            midnight-js-contracts/
              classes/
                CallTxFailedError.md
                ContractTypeError.md
                DeployTxFailedError.md
                IncompleteCallTxPrivateStateConfig.md
                IncompleteFindContractPrivateStateConfig.md
                InsertVerifierKeyTxFailedError.md
                RemoveVerifierKeyTxFailedError.md
                ReplaceMaintenanceAuthorityTxFailedError.md
                TxFailedError.md
              functions/
                call.md
                callContractConstructor.md
                createCallTxOptions.md
                createCircuitCallTxInterface.md
                createCircuitMaintenanceTxInterface.md
                createCircuitMaintenanceTxInterfaces.md
                createContractMaintenanceTxInterface.md
                createUnprovenCallTx.md
                createUnprovenCallTxFromInitialStates.md
                createUnprovenDeployTx.md
                createUnprovenDeployTxFromVerifierKeys.md
                deployContract.md
                findDeployedContract.md
                getPublicStates.md
                getStates.md
                submitCallTx.md
                submitDeployTx.md
                submitInsertVerifierKeyTx.md
                submitRemoveVerifierKeyTx.md
                submitReplaceAuthorityTx.md
                submitTx.md
                verifierKeysEqual.md
                verifyContractState.md
              type-aliases/
                CallOptions.md
                CallOptionsBase.md
                CallOptionsProviderDataDependencies.md
                CallOptionsWithArguments.md
                CallOptionsWithPrivateState.md
                CallOptionsWithProviderDataDependencies.md
                CallResult.md
                CallResultPrivate.md
                CallResultPublic.md
                CallTxOptions.md
                CallTxOptionsBase.md
                CallTxOptionsWithPrivateStateId.md
                CircuitCallTxInterface.md
                CircuitMaintenanceTxInterface.md
                CircuitMaintenanceTxInterfaces.md
                ContractConstructorOptions.md
                ContractConstructorOptionsBase.md
                ContractConstructorOptionsProviderDataDependencies.md
                ContractConstructorOptionsWithArguments.md
                ContractConstructorOptionsWithPrivateState.md
                ContractConstructorOptionsWithProviderDataDependencies.md
                ContractConstructorResult.md
                ContractMaintenanceTxInterface.md
                ContractProviders.md
                ContractStates.md
                DeployContractOptions.md
                DeployContractOptionsBase.md
                DeployContractOptionsWithPrivateState.md
                DeployedContract.md
                DeployTxOptions.md
                DeployTxOptionsBase.md
                DeployTxOptionsWithPrivateState.md
                DeployTxOptionsWithPrivateStateId.md
                FinalizedCallTxData.md
                FinalizedDeployTxData.md
                FinalizedDeployTxDataBase.md
                FindDeployedContractOptions.md
                FindDeployedContractOptionsBase.md
                FindDeployedContractOptionsExistingPrivateState.md
                FindDeployedContractOptionsStorePrivateState.md
                FoundContract.md
                PartitionedTranscript.md
                PublicContractStates.md
                SubmitTxOptions.md
                SubmitTxProviders.md
                UnprovenCallTxProvidersBase.md
                UnprovenCallTxProvidersWithPrivateState.md
                UnprovenDeployTxOptions.md
                UnprovenDeployTxProviders.md
                UnsubmittedCallTxData.md
                UnsubmittedDeployTxData.md
                UnsubmittedDeployTxDataBase.md
                UnsubmittedDeployTxPrivateData.md
                UnsubmittedDeployTxPublicData.md
                UnsubmittedTxData.md
              README.md
            midnight-js-fetch-zk-config-provider/
              classes/
                FetchZkConfigProvider.md
              README.md
            midnight-js-http-client-proof-provider/
              functions/
                httpClientProofProvider.md
                serializePayload.md
                serializeZKConfig.md
              variables/
                DEFAULT_CONFIG.md
              README.md
            midnight-js-indexer-public-data-provider/
              classes/
                IndexerFormattedError.md
              functions/
                indexerPublicDataProvider.md
              README.md
            midnight-js-level-private-state-provider/
              functions/
                levelPrivateStateProvider.md
              interfaces/
                LevelPrivateStateProviderConfig.md
              variables/
                DEFAULT_CONFIG.md
              README.md
            midnight-js-logger-provider/
              classes/
                LoggerProvider.md
              README.md
            midnight-js-network-id/
              classes/
                NetworkIdTypeError.md
              enumerations/
                NetworkId.md
              functions/
                getLedgerNetworkId.md
                getNetworkId.md
                getRuntimeNetworkId.md
                getZswapNetworkId.md
                networkIdToHex.md
                setNetworkId.md
                stringToNetworkId.md
              README.md
            midnight-js-node-zk-config-provider/
              classes/
                NodeZkConfigProvider.md
              README.md
            midnight-js-testing/
              classes/
                DevnetTestEnvironment.md
                DynamicProofServerContainer.md
                EnvVarRemoteTestEnvironment.md
                FaucetClient.md
                GzipFile.md
                IndexerClient.md
                LocalTestConfiguration.md
                LocalTestEnvironment.md
                MidnightWalletProvider.md
                NodeClient.md
                ProofServerClient.md
                QanetTestEnvironment.md
                RemoteTestEnvironment.md
                StaticProofServerContainer.md
                TestEnvironment.md
                Testnet2TestEnvironment.md
                TestnetTestEnvironment.md
                WalletFactory.md
                WalletSaveStateProvider.md
              functions/
                createDefaultTestLogger.md
                createLogger.md
                createOutputs.md
                delay.md
                expectFoundAndDeployedStatesEqual.md
                expectFoundAndDeployedTxDataEqual.md
                expectFoundAndDeployedTxPrivateDataEqual.md
                expectFoundAndDeployedTxPublicDataEqual.md
                expectStatesEqual.md
                expectSuccessfulCallTx.md
                expectSuccessfulDeployTx.md
                expectSuccessfulTxData.md
                extractHostnameAndPort.md
                getContainersConfiguration.md
                getInitialState.md
                getTestEnvironment.md
                getWalletStateFilename.md
                initializeMidnightProviders.md
                inMemoryPrivateStateProvider.md
                normalizeWalletState.md
                sendTransactionToAddress.md
                sendTransactionToWallet.md
                setContainersConfiguration.md
                stateValueEqual.md
                syncWallet.md
                txsEqual.md
                waitForFinalizedBalance.md
                waitForFullSync.md
                waitForFunds.md
                waitForPending.md
                waitForSyncProgressDefined.md
                waitForTxInHistory.md
                walletStateWithoutHistoryAndCoins.md
              interfaces/
                ContainerEndpoints.md
                ContainersConfiguration.md
                ContractConfiguration.md
                EnvironmentConfiguration.md
                LogConfiguration.md
                ProofServerContainer.md
                ProofServerContainerConfiguration.md
                StandaloneContainerNames.md
                StandaloneContainersConfiguration.md
              type-aliases/
                ComponentPortsConfiguration.md
                MidnightWallet.md
                SerializedWalletState.md
                TxOutput.md
              variables/
                DEFAULT_WALLET_LOG_LEVEL.md
                DEFAULT_WALLET_STATE_DIRECTORY.md
                defaultContainersConfiguration.md
                latestContainersConfiguration.md
                logger.md
                MINUTE.md
              README.md
            midnight-js-types/
              classes/
                InvalidProtocolSchemeError.md
                ZKConfigProvider.md
              enumerations/
                LogLevel.md
              functions/
                createBalancedTx.md
                createProverKey.md
                createUnbalancedTx.md
                createVerifierKey.md
                createZKIR.md
                getImpureCircuitIds.md
              interfaces/
                Contract.md
                FinalizedTxData.md
                LoggerProvider.md
                MidnightProvider.md
                MidnightProviders.md
                PrivateStateProvider.md
                ProofProvider.md
                ProveTxConfig.md
                PublicDataProvider.md
                WalletProvider.md
                ZKConfig.md
              type-aliases/
                All.md
                BalancedTransaction.md
                BlockHashConfig.md
                BlockHeightConfig.md
                CircuitParameters.md
                CircuitReturnType.md
                ContractStateObservableConfig.md
                ImpureCircuit.md
                ImpureCircuitId.md
                ImpureCircuits.md
                InitialStateParameters.md
                Latest.md
                PrivateState.md
                PrivateStateId.md
                ProverKey.md
                TxIdConfig.md
                TxStatus.md
                UnbalancedTransaction.md
                VerifierKey.md
                Witness.md
                Witnesses.md
                ZKIR.md
              variables/
                FailEntirely.md
                FailFallible.md
                SucceedEntirely.md
              README.md
            midnight-js-utils/
              functions/
                assertDefined.md
                assertIsContractAddress.md
                assertIsHex.md
                assertUndefined.md
                fromHex.md
                isHex.md
                parseCoinPublicKeyToHex.md
                parseEncPublicKeyToHex.md
                parseHex.md
                toHex.md
              type-aliases/
                ParsedHexString.md
              README.md
          packages.md
          README.md
        onchain-runtime/
          classes/
            ContractMaintenanceAuthority.md
            ContractOperation.md
            ContractState.md
            CostModel.md
            QueryContext.md
            QueryResults.md
            StateBoundedMerkleTree.md
            StateMap.md
            StateValue.md
            VmResults.md
            VmStack.md
          enumerations/
            NetworkId.md
          functions/
            bigIntModFr.md
            bigIntToValue.md
            checkProofData.md
            coinCommitment.md
            decodeCoinInfo.md
            decodeCoinPublicKey.md
            decodeContractAddress.md
            decodeQualifiedCoinInfo.md
            decodeTokenType.md
            degradeToTransient.md
            dummyContractAddress.md
            ecAdd.md
            ecMul.md
            ecMulGenerator.md
            encodeCoinInfo.md
            encodeCoinPublicKey.md
            encodeContractAddress.md
            encodeQualifiedCoinInfo.md
            encodeTokenType.md
            hashToCurve.md
            leafHash.md
            maxAlignedSize.md
            maxField.md
            persistentCommit.md
            persistentHash.md
            runProgram.md
            sampleContractAddress.md
            sampleSigningKey.md
            sampleTokenType.md
            signatureVerifyingKey.md
            signData.md
            tokenType.md
            transientCommit.md
            transientHash.md
            upgradeFromTransient.md
            valueToBigInt.md
            verifySignature.md
          type-aliases/
            AlignedValue.md
            Alignment.md
            AlignmentAtom.md
            AlignmentSegment.md
            BlockContext.md
            CoinCommitment.md
            CoinInfo.md
            CoinPublicKey.md
            ContractAddress.md
            DomainSeperator.md
            Effects.md
            EncodedStateValue.md
            Fr.md
            GatherResult.md
            Key.md
            Nonce.md
            Nullifier.md
            Op.md
            QualifiedCoinInfo.md
            Signature.md
            SignatureVerifyingKey.md
            SigningKey.md
            TokenType.md
            Transcript.md
            Value.md
          globals.md
          README.md
        wallet-api/
          interfaces/
            Wallet.md
          type-aliases/
            Address.md
            AddressLegacy.md
            ApplyStage.md
            BalanceTransactionToProve.md
            CoinPublicKey.md
            CoinPublicKeyLegacy.md
            EncPublicKeyLegacy.md
            NothingToProve.md
            ProvingRecipe.md
            SyncLag.md
            SyncProgress.md
            TokenTransfer.md
            TokenType.md
            TransactionHash.md
            TransactionHistoryEntry.md
            TransactionIdentifier.md
            TransactionToProve.md
            WalletState.md
          variables/
            BALANCE_TRANSACTION_TO_PROVE.md
            NOTHING_TO_PROVE.md
            TRANSACTION_TO_PROVE.md
          globals.md
          README.md
        zswap/
          classes/
            AuthorizedMint.md
            EncryptionSecretKey.md
            Input.md
            LedgerParameters.md
            LocalState.md
            MerkleTreeCollapsedUpdate.md
            Offer.md
            Output.md
            ProofErasedAuthorizedMint.md
            ProofErasedInput.md
            ProofErasedOffer.md
            ProofErasedOutput.md
            ProofErasedTransaction.md
            ProofErasedTransient.md
            SystemTransaction.md
            Transaction.md
            TransactionCostModel.md
            Transient.md
            UnprovenAuthorizedMint.md
            UnprovenInput.md
            UnprovenOffer.md
            UnprovenOutput.md
            UnprovenTransaction.md
            UnprovenTransient.md
            ZswapChainState.md
          enumerations/
            NetworkId.md
          functions/
            createCoinInfo.md
            nativeToken.md
            sampleCoinPublicKey.md
            sampleContractAddress.md
            sampleTokenType.md
          type-aliases/
            CoinCommitment.md
            CoinInfo.md
            CoinPublicKey.md
            ContractAddress.md
            EncPublicKey.md
            Nonce.md
            Nullifier.md
            QualifiedCoinInfo.md
            TokenType.md
            TransactionHash.md
            TransactionId.md
          globals.md
          README.md
        index.mdx
      tools/
        vsc-plugin/
          index.mdx
        compiler-usage.mdx
        index.mdx
      index.mdx
    tutorial/
      1-using/
        chrome-ext.mdx
        faucet.mdx
        index.mdx
        proof-server.mdx
        welcome.mdx
      2-building/
        contract-details.mdx
        counter-build.mdx
        counter-run.mdx
        dapp-details.mdx
        examples-repo.mdx
        index.mdx
      3-creating/
        bboard-contract.mdx
        bboard-dapp.mdx
        index.mdx
        local-testing.mdx
        scenario.mdx
        updatability.mdx
      index.mdx
    faq.mdx
    getting-help.mdx
    relnotes.mdx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/develop/archived-relnotes/2023-11_devnet_0_0_2_release_notes.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
pagination_prev: null
---

# 2023-11 Devnet v0.0.2 release notes

**13 November 2023**

Midnight is a regulatory-friendly data protection-based blockchain that safeguards sensitive commercial and personal data, protecting fundamental freedoms of association, commerce, and expression for developers, companies, and individuals. Midnight utilizes a novel data protection-first programming model and zero-knowledge (ZK) proofs while operating as a Cardano partner chain.

## Overview

This devnet release is Midnight’s first alpha version, which is being made available to a select audience of the developer community. We aim to solicit their feedback on the progress of Midnight technology and development. It is the first of many iterations of the functionality on the roadmap to Midnight Mainnet.

These release notes present the core features of Midnight that are being made available to this inaugural group of participants and list some of the known issues our team has mapped and is working to resolve. During the devnet campaign, we will use our Discord channel to update you on resolutions and any new issues we find.

## Impacted Users

These release notes apply to all Midnight `devnet` users.

## Impacted Components

| Component            |                Version                | Change/impact                                                                                                             |
| ------ | :-----: | ------ |
| Blockchain | nodebd45, 4f5f8ad38, 70417868e, 903edade, 061e555cfe | Initial release |
| Pub-sub indexer | 0.2.10 | Initial release |
| Wallet (Lace) | 1.0.4 | Initial release |
| DApp Connector | 1.0.0 | Initial release |
| Proof generator | 2.0.4 | Initial release |
| Compact Compiler | 0.8.11 | Initial release |
| Visual Studio plugin | 0.2.10 | Initial release |

## Additional Resources

### Dev Support

* Developer support is available via Discord → [bit.ly/Midnight_Discord](https://bit.ly/Midnight_Discord)
* Documentation is accessible here → [devnetdocs.midnight.network/docs/](https://devnetdocs.midnight.network/docs/)

Access is granted only to `devnet` participants. If you cannot access these resources, please contact us via the details provided in the `devnet` invitation email.

We will also offer in-person consultation assistance and publish the support hours windows and availability for `devnet` participants to secure a consultation. Details will be provided via the Discord channel.

### Social Channels

* Midnight on Twitter: [twitter.com/MidnightNtwrk](https://twitter.com/MidnightNtwrk)
* Midnight on LinkedIn: [linkedin.com/showcase/midnight-ntwrk/](https://www.linkedin.com/showcase/midnight-ntwrk/)

## What is new in this release? 

### New Features

* Build data-protection smart contracts using the Compact domain-specific language (DSL) and Compact compiler. Generate Javascript, cryptographic materials, and circuit descriptions needed by the proof to create the ZK proofs that enforce the terms of a smart contract while shielding the private data.
* Store, manage, and interact with Midnight assets and decentralized applications (DApps) directly within the Google Chrome web browser using a Midnight version of the popular Lace wallet.
* Pay for transactional costs and move value peer-to-peer using shielded tDUST tokens.
* Create ZK proofs and perform ZK computations using the local proof generator software to facilitate submitting transactions and proof data from clients.
* Index the Midnight blockchain data to support wallet and DApp functionality using the Pub-sub indexer to query data directly from the ledger.
* Write Midnight DApps in Typescript and Compact DSL code supported by the Visual Studio Code plugin.

### Bug Fixes

N/A

### Enhancements

* No enhancements are considered for this release since it is the first release.

### Known issues

<dl>
  <dt><strong>PM-7595</strong></dt>
  <dd>Wallet history shows only transaction fees to preserve the confidentiality of the transaction. Other visualization methods will be made available in the future.</dd>

  <dt><strong>PM-7815</strong></dt>
  <dd>The following error messages or behaviors of the wallet require the user to resync the wallet by using the resync button next to the syncing status in the menu.</dd>

  <dt><strong>PM-7830, PM-7826, PM-7790</strong></dt>
  <dd><ul><li>Wallet locks funds when an error happens after a transaction is balanced/built but before it is submitted.</li><li>When a `Not sufficient funds` error appears, and no errors are present in the node logs, it might be the wallet locking funds due to an error before submitting a transaction.</li><li>When a `Wallet was not synced. Connection was lost` error appears, it might be because the wallet is locking funds due to an error before submitting a transaction.</li><li>Wallet locks funds when a valid transaction is submitted but fails execution in the node</li></ul></dd>

  <dt><strong>PM-7832</strong></dt>
  <dd>Wallet displays a popup indicating that it cannot “fetch ADA price”. When this occurs, the user can close this message and proceed further. Ada is not a token available for use on Midnight devnet.</dd>

  <dt><strong>PM-7820</strong></dt>
  <dd><p>The following error messages or behaviors of the wallet require the user to create a new wallet:</p><p><ul><li>RuntimeError: unreachable at was: Not sufficient funds to balance token</li></ul></p></dd>

  <dt><strong>PM-7594</strong></dt>
  <dd>When the headless wallet is stopped, it might show an error saying `node:events:495 throw er; // Unhandled 'error'`. It's an internal abrupt close of connection, but nothing is wrong. Users can ignore this message.</dd>

  <dt><strong>PM-7593</strong></dt>
  <dd>When headless wallet connects to the pub-sub indexer, it might fail with error message `<java.security.SecureRandom is not supported on this platform because it provides neither crypto.getRandomValues nor Node.js "crypto" module.` Users should apply the workaround:</dd>

```
Unset
 import { webcrypto } from "node:cryptou"; // \@ts-ignore
 global.crypto = webcrypto;
```

</dl>
</file>

<file path="docs/develop/archived-relnotes/2024-02_devnet_0_1_0_release_notes.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
pagination_prev: null
---

# 2024-02 Devnet v0.1.0 release notes

**19 February 2024**

Midnight is a regulatory-friendly data protection-based blockchain that safeguards sensitive commercial and personal data, protecting fundamental freedoms of association, commerce, and expression for developers, companies, and individuals. Midnight utilizes a novel data protection-first programming model and zero-knowledge (ZK) proofs while operating as a Cardano partner chain.

## Overview

This devnet release is Midnight's first public alpha version, which is being made broadly available for the developer community. We aim to solicit the community's feedback about Midnight's technology and development progress. It is one of many iterations of the functionality on the roadmap to Midnight mainnet.

These release notes present the core features of Midnight that are being made available at this time and list some of the known issues our team has mapped and is working to resolve. We will use Midnight's to update the community on resolutions and any new issues we find.

NOTE: the previous version of Devnet, 0.0.2, will be deactivated after this new devnet release, and Midnight's documentation [docs.midnight.network](https:lldocs.midnight.network) has been updated to reflect the new version. Communication of Devnet 0.0.2 sunset will be issued via Midnight's Discord.

## Impacted Users

These release notes apply to all Midnight `devnet` users.

## Impacted Components

| **Component** | **Version** | **Change/impact** |
| ------ | :-----: | ------ |
| Blockchain | 0.2.0 | Stabilization upgrade, bug fixes |
| Pub-sub indexer | 1.0.5 | Stabilization upgrade |
| Wallet (Lace) | 1.1.0 (App), 3.5.5 (Engine), 3.3.1 (API) | Midnight Native Shielded Tokens |
| DApp connector | 1.1.0 | Common prover and balance methods |
| Proof server | 2.0.7 | Bug fixes |
| Compact compiler | 0.9.2 | Support to Midnight Native Shielded Tokens |
| Visual Studio plugin | 0.2.12 | Accompanying Compact language updates |
| Faucet | 0.6.1 | Initial release |

## Additional Resources

### Developer support

The Developer Relations team can be reached through [Midnight's Discord channel](https://bit.ly/Midnight_Discord), where further communication about community engagement will be made.

### Documentation

Midnight documentation is accessible at [devnetdocs.midnight.network/docs/](https://devnetdocs.midnight.network/docs/) and is regularly updated. In case of suggestions, questions, or requests, please contact the Developer Relations team on Discord.

### Social Channels

* Midnight on Twitter: [twitter.com/MidnightNtwrk](https://twitter.com/MidnightNtwrk)
* Midnight on LinkedIn: [linkedin.com/showcase/midnight-ntwrk/](https://www.linkedin.com/showcase/midnight-ntwrk/)

## What is new in this release? 

### New Features

* This is an alpha version of Midnight, which is open to all developers.

* Build data-protection smart contracts using the Compact language and Compact compiler. Generate JavaScript, cryptographic materials, and circuit descriptions needed by the proof to create the ZK proofs that enforce the terms of a smart contract while shielding the users' private data.

* Store, manage, and interact with Midnight assets and decentralized applications (DApps) directly within the Google Chrome web browser using a Midnight alpha version of the popular Lace wallet exclusive for Devnet.

* View and manage listed Midnight Native Tokens in their Midnight Lace Wallet.

* Pay for transactional costs and move value peer-to-peer using shielded tDUST tokens (tDUST is a test token used for Midnight devnet testing purposes only.

* Create ZK proofs and perform ZK computations using the local proof generator software to facilitate the submission of transactions and proof data from clients.

* Index the Midnight blockchain data to support wallet and DApp functionality using the pub-sub indexer to query data directly from the ledger.

* Write Midnight DApps in TypeScript and Compact DSL code supported by the Visual Studio Code plugin.

### Bug Fixes

* **PM-7595** - The wallet history shows only transaction fees to preserve the confidentiality of the transaction. Other visualization methods will be made available in the future.

* **PM-7815 PM-7830 PM-7826 PM-7790** - The following error messages or behaviors of the wallet require the user to resync the wallet by using the resync button next to the syncing status in the menu:
                       
	* The wallet locks funds when an error happens after a transaction is balanced/built but before it is submitted.

	* When a 'Not sufficient funds' error appears, and no errors are present in the node logs, it might be the wallet locking funds due to an error before submitting a transaction.

	* When a 'Wallet was not synced. Connection was lost' error appears, it might be because the wallet is locking funds due to an error before submitting a transaction.

	* The wallet locks funds when a valid transaction is submitted but fails to execute in the node.     

* **PM-7832** - The wallet displays a popup indicating that it cannot 'fetch ADA price'. When this occurs, the user can close this message and proceed further. Ada is not a token available for use on the Midnight devnet.

* **PM-7820 PM-7817** - The following error messages or behaviors of the wallet require the user to create a new wallet:

	* RuntimeError: unreachable at wasm

	* Not sufficient funds to balance token

* **PM-7594** - When the headless wallet is stopped, it might show an error saying `node:events:495 throw er; // Unhandled 'error'`. It's an internal abrupt close of connection, but nothing is wrong. Users can ignore this message.              
          
* **PM-7593** - When the headless wallet connects to the pub-sub indexer, it might fail with error message `java.security.SecureRandom is not supported on this platform because it provides neither 'crypto.getRandomValues' nor Node.js 'crypto' module.'` The users should apply the following workaround:

```
Unset
 import { webcrypto } from "node:cryptou"; // \@ts-ignore
 global.crypto = webcrypto;
```

### Enhancements

* Increased stability for all components.

* New blocks are produced every 6 seconds.

* Users are now able to implement, visualize and transact with different shielded token types.

### Known issues

| **Item** | **Issue** |
| :---- | :---- |
| PM-8694 | **Wallet** Native tokens missing after resyncing or restoring wallet. When that happens, users are required to mint new tokens. |
| PM-8523 | **Pubsub** Missing block height number validation before querying. This should not impact users. |
| PM-8476 | **Wallet** Deploying contract error after increasing wallet balance. In case of insufficient balance, users should increase wallet balance, resync their wallet, then redeploy the contract. |       
| PM-8199 | **Compactc** Compiler might not add a trailing slash to `COMPACT_PATH`. Users should add the trailing '/' at the end of the variable, if not using the provided wrapper script. |
| PM-8135 | **Faucet** Error messages are ambiguous in case of insufficient balance or invalid address. Users should ensure a valid wallet address is entered (e.g. by copy and paste from Lace Wallet), and try again after a few minutes. |
| PM-7843 | **Welcome DApp** DApp halts if invalid contract address is set. Users should end the current CLI DApp instance and start a new one ensuring to use a valid Contract Address. |  
| PM-7798 | **Faucet** Previous error message remains visible while processing request. Users can ignore the message and proceed. |
</file>

<file path="docs/develop/archived-relnotes/2024-09_testnet_release_notes.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
pagination_prev: null
---

# 2024-09 Testnet release notes

**October 1, 2024**

Midnight is a regulatory-friendly data protection-based blockchain that safeguards sensitive commercial and personal data, protecting fundamental freedoms of association, commerce, and expression for developers, companies, and individuals. Midnight utilizes a novel data protection-first programming model and zero-knowledge (ZK) proofs while operating as a Cardano partner chain.

## Overview

Midnight `testnet` is the evolution from our developer-centric `devnet` version to the upcoming public `mainnet` release; it is being made broadly available to the independent and partner developer communities. We solicit feedback about our technology and development progress.

These release notes present the core features of `testnet` along with some of the known issues our team has mapped and is working to resolve. We will use Midnight’s Discord channel (​​[discord.gg/midnightnetwork](https://discord.gg/midnightnetwork)) to update the community on these and any new issues we find.

NOTE: The Midnight documentation ([docs.midnight.network](https://docs.midnight.network/)) has been updated to reflect `testnet`. The `devnet` will be sunset on a schedule to be shared via Discord.

## Impacted users

These release notes apply to all Midnight users.

## Impacted components

| Component            |                Version                | Change/impact                                                                                                             |
| -------------------- | :-----------------------------------: | ------------------------------------------------------------------------------------------------------------------------- |
| Blockchain           |                 0.6.3                 | Stabilization upgrade, bug fixes                                                                                          |
| Indexer              |                 2.2.1                 | Stabilization updates and hard fork improvements                                                                          |
| Wallet (Lace)        | 1.2.2&nbsp;(App), 3.6.3&nbsp;(Engine), 3.4.21&nbsp;(API) | Support for `testnet` (not backwards-compatible with `devnet`) |
| DApp connector       |                 1.2.1                 | Common prover and balance methods                                                                                         |
| Ledger               |                 3.0.3                 | Ledger now uses halo2 proving system, supporting SNARK upgradeability                                                     |
| Compact compiler     |                 0.18.2                | Accompanying Compact language updates                                                                                     |
| Compact              |                 0.10.1                | Syntax changes, namespace changes, and bug fixes to make the language more analogous to TypeScript and more user-friendly |
| Visual Studio plugin |                 0.2.12                | Accompanying Compact language updates                                                                                     |
| Mn.JS                |                 0.2.4                 | API changes to support snark upgrade                                                                                      |
| Faucet               |                 0.8.0                 | `testnet` support (not backward compatible with `devnet`). Improved performance and UX.                                   |

## Additional resources

### Developer support

The Developer Relations team can be reached through Midnight’s Discord channel (​​[discord.gg/midnightnetwork](https://discord.gg/midnightnetwork)), where further communication about community engagement will be made. 

### Documentation

Midnight documentation ([docs.midnight.network](https://docs.midnight.network/)) is regularly updated. Please address  suggestions, questions, and requests to the Developer Relations team on Discord.

### Social channels

- Midnight on Twitter/X: [twitter.com/MidnightNtwrk](https://twitter.com/MidnightNtwrk)
- Midnight on LinkedIn: [linkedin.com/showcase/midnight-ntwrk/](https://www.linkedin.com/showcase/midnight-ntwrk/)

# What is in this release?

- SNARK Upgradeability: Midnight’s tech stack is now capable of updating the proving without resetting the chain. Contracts can be easily updated to accommodate proving system changes, bug fixes, and performance enhancements. As of now, there is no need to move contract funds if maintenance authority is set. 

- Midnight Block Producer Guide and System Requirements: SPOs may become block producers for the public Midnight Testnet to confirm they meet the hardware requirements to maintain consistent node performance and contribute effectively to Midnight's security and stability. These requirements help maintain a level playing field for all participants and promote a healthy ecosystem.

- Stake Pool Operator (SPO) Registration and Block Production, A new consensus mechanism was designed to enhance network decentralization while maintaining a degree of centralized control. It has been fully integrated into the block stack and is now available for external evaluation, allowing developers and the community to test and provide feedback. 

- Chain Hard Fork Capability: Midnight internal developers are now able to publish backward incompatible changes without resetting the chain. DApp and Wallet developers can accommodate these changes with minimal inconvenience to their users. Finally, it provides a mechanism for SPOs and Block Producers to upgrade to the new consensus rules.

- Halo2 as a proving system instead of Plonk: Halo2, a popular library for zero-knowledge proofs, offers advantages like custom gates, lookup arguments, and universal SNARKs. Midnight uses a modified version of Halo2, supporting efficient recursion and pairing-friendly curves.

- SPO nodes automatically vote for runtime upgrades: Validators should be able to signal to one another that they have upgraded to a client version compatible with the latest ledger version and the upcoming runtime upgrade. This signaling is achieved by broadcasting a specific message to the network, indicating the client version and a unique identifier for the runtime upgrade. Only validators with compatible clients can participate in the upgrade process, ensuring a smooth transition to the new runtime.

## Bug fixes

|   Item  | Issue/bug                                                                                                                                                                                                                                                                                                                                                                                |
| :-----: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| PM-8523 | \[Indexer] Missing block height number validation before querying. This should not impact users.                                                                                                                                                                                                                                                                                         |
| PM-8135 | \[Faucet] Error messages are ambiguous in case of insufficient balance or invalid address. Users should ensure a valid wallet address is entered (e.g. by copy and paste from Lace Wallet) and try again after a few minutes.                                                                                                                                                            |
| PM-7843 | \[Welcome DApp] DApp halts if invalid contract address is set. Users should end the current CLI DApp instance and start a new one ensuring to use a valid Contract Address.                                                                                                                                                                                                              |
| PM-7593 | When the Wallet SDK connects to the indexer, it can fail with error message ‘java.security.SecureRandom is not supported on this platform because it provides neither \`crypto.getRandomValues\` nor Node.js' ‘crypto’ module.’ The users should apply the following workaround:`import` `{` `webcrypto` `}` `from` `"node:crypto";``//` `@ts-ignore``global.crypto` `=` `webcrypto;` |

## Enhancements

### Ledger

- Ledger now supports the Halo2 proving system.

- Ledger supports upgradeable contracts to support SNARK upgradeability. 

- Ledger parameters has been added. 

- Added a mechanism for block rewards. 

- Moved the network ID variable from a state variable to a parameter of serialization functions.

- Switched to SHA-256 for our persistent hash function.

- Bug fixes and improvements. 

### Compact 

- Ledger declaration syntax and namespace changes:

  - Ledger fields are now declared individually with the keyword `ledger`.

  - There is no need to prefix a ledger field with `ledger.` since ledger field declarations are now top-level.

  - Kernel operations now require `kernel.` prefix instead of `ledger.` prefix.

  - Ledger field update shortcuts are now statements.

- Unsigned integer sizes can now be generic and can take either numeric literal or a generic parameter name.

- The static typing of subtraction now provides a more precise bound on the result type.

- Compact now matches the precedence of relational operators in TypeScript and JavaScript.

- Due to the lack of direct analog in TypeScript, Generics can no longer be parameterized over generics.

- The identifier `contract` is now a reserved word due to adding support for a new in-progress feature that allows contracts to call other contracts.

       More details on these changes, why we made them, and how you can fix your code can be found in the [Compact 0.10.1 notes](https://docs.google.com/document/d/1pZCpOdBdilHNQo4hgDmW2Ij-VKsUYR9TPBlxC5kG3lI/edit?usp=sharing).

### CompactC

- The command line compiler has been renamed from `run-compactc.sh` to `compactc`.

### MN.JS

- Added convenience functions for performing SNARK upgrades of contracts.

- Added convenience functions for creating unproven transactions.

- Added convenience functions  for submitting transactions directly.

- Replaced function parameters with configuration objects at the main SDK entry points.

- Improved type inference for contracts and API clients.

- Added support for storing and retrieving contract maintenance authority signing keys.

- Introduced an explicit distinction between public and private data in the transaction model.

### Blockchain

- Session length increased from 6 minutes to 2 hours to improve stability.

- Simplified configuration for Midnight node with pre-configured settings for each network, reducing setup time and the risk of configuration errors.

- Users are now able to implement, visualize, and transact with different shielded token types, providing enhanced privacy and flexibility for various use cases.

- Users can now view initial faucet funding transactions directly within the genesis block using polkadot.js, improving transparency.

- Docker Compose scripts now available for SPOs that would prefer not to use Kubernetes.

- Several RPC methods now return `json` rather than `string`.

- The Midnight node image is now Debian-based for better compatibility and easier management.

- Node Version of block author now included in block header.

- Full set of substrate node CLI commands available.

- Node now monitors the available disk space and will gracefully shut down if that value drops below the threshold.

- Increased stability for all components.

### Indexer

- Enhanced stability and performance through updated dependencies, optimized database schema, and improved logging.

- Implemented support for the upcoming network upgrade, enabling seamless upgrades, providing flexibility for developers, and better UX for end-users.

- Enhanced compatibility with the latest Halo2 proving system, allowing for smoother transactions and reduced error rates.

### Wallet

- Midnight-Lace

  - Enhanced stability and performance improvements.

  - Updated to the latest version of Wallet SDK for improved security, compatibility, and feature support.

- Wallet SDK

  - The Halo2 proving system has been integrated, enabling more efficient proving transaction performance.

  - Implemented support for network upgrades, enabling seamless upgrades, providing flexibility for developers, and better UX for end-users.

  - Network ID is now a required build parameter to ensure proper network configuration and prevent transactions from ending up in the wrong network.

  - Introduced option to omit transaction history via build parameter. This can be used to reduce storage requirements and improve performance in certain use cases.

## Known issues

|   Item   | Issue                                                                                                                           | Impact                                                                                                                                                                                                                                      | Workaround                                                                                                            |
| :------: | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| PM-8694 | \[Wallet] Native tokens missing after resyncing or restoring wallet. When that happens, users are required to mint new tokens.  | Native Tokens can go missing in Midnight Lace Wallet when restoring a wallet using the same seed phrase on multiple devices. The problem occurs when transferring the wallet setup (using the seed phrase) to a different browser/computer. | Workaround: Keep Midnight-Lace and its associated seed phrase on the same browser/computer to preserve native tokens. |
| PM-12387 | Partner-chain-cli missing deregister command                                                                                    | Deregister must be performed by invoking the sidechain-main-cli that’s packaged with partner-chain-cli.                                                                                                                                     | Invoke “./sidechain-main-cli deregister” to perform deregistration.                                                   |
| PM-12428 | Unexpected  "Not sufficient funds to balance token" message                                                                     | SNARK upgrades initiated using Midnight.js will fail intermittently.                                                                                                                                                                        | Increase the delay between each SNARK upgrade attempt.                                                                |
| PM-12365 | \[wallet] Timed out trying to connect if an invalid network ID provided.                                                        | Wallet will not connect.                                                                                                                                                                                                                    | Verify if the network ID, indexer, and node URLs are correct.                                                         |
|  PM-3974 | Retain the ability to develop smart contracts when a hard fork happens.                                                         | MN.JS won’t support HF at this time.                                                                                                                                                                                                        | Launch HF capability on all components. MN.jS updates will happen on the next release.                                |
</file>

<file path="docs/develop/guides/compact-javascript-runtime.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# The Compact JavaScript Implementation: run your contracts off-chain

If you’ve written smart contracts before, you’re probably used to languages like Solidity or Rust that compile to on-chain bytecode.

The **Midnight blockchain** takes a different approach. It uses a domain-specific language called **Compact**, designed from the ground up for [zero-knowledge smart contracts](https://docs.midnight.network/develop/reference/compact): programs that can prove that private data exists (and is known) and that satisfies the constraints required by the contract.

When you compile a Compact contract, the compiler doesn’t just generate the zero-knowledge circuits. It also produces a **JavaScript implementation**, typically found in a file called `index.cjs` in a subfolder next to your `.compact` file.

This implementation lets you execute and test your Compact contract logic directly in JavaScript, using Node.js or any standard testing framework. As we have not (yet) provided a Compact contract unit testing framework, but since contracts are compiled to JavaScript, you can write JavaScript unit tests against their JavaScript implementations. It’s your bridge between the high-level Compact code and the low-level ZK circuit that runs on-chain.

In this tutorial, we’ll explore the [implementation generated for the bboard contract](https://github.com/midnightntwrk/example-bboard) in depth. You’ll learn:

* How the `index.cjs` file is generated during compilation

* How it’s structured and what each section does

* How the implementation connects JavaScript to Compact’s zero-knowledge circuits

* And how you can use it to write unit tests **or** run the contract locally

By the end, you’ll understand how Compact’s JavaScript implementation fits into the development workflow — and how it makes testing private smart contracts both accessible and familiar.

## **How the JavaScript implementation Gets Generated**

When you compile a Compact contract, the compiler produces more than just zero-knowledge circuits — it also emits a matching JavaScript implementation (typically named `index.cjs`). This implementation is essential for simulating, testing, and interacting with your contract logic in a plain JavaScript environment (e.g., Node.js, browser tests). In this section, we’ll walk through *how* and *why* that implementation is generated.

### **The Compilation Pipeline: Compact → Circuits \+ JS implementation**

Here’s a high-level view of what happens under the hood:

1. **Circuit Generation**  
    The compiler checks your `.compact` files and emits zero-knowledge circuits for each contract function or “entry point”.

2. **Implementation File Generation**  
   Concurrently, the compiler generates a **JavaScript implementation file** that mirrors the contract’s structure:

   * It knows which functions exist (their signatures, inputs, outputs).

   * It embeds type descriptors for all Compact types used (integers, booleans, enums, bytes, composite types).

   * It wraps each contract entry point so that you can invoke it in JS, passing native JS values, and get back state transitions.

3. **Linking to the Compact Implementation Library**  
   The generated `index.cjs` does *not* reimplement arithmetic, field operations, or other foundational ZK logic; instead, it imports a shared implementation library from `@midnight-ntwrk/compact-runtime`. That library implements:

   * Finite field arithmetic

   * Serialization and deserialization

   * Error types, type checks, alignment rules

   * Circuit-related helper functions  
      The generated file and the implementation library together form a complete environment.

4. **Source Maps & Type Declarations**

   * A **source map** (`index.cjs.map`) is emitted so that debugging or tracing can map back to your original Compact source (line numbers, symbol names).

   * A **TypeScript declaration file** (`index.d.cts`) is generated so that, when you import this implementation in a TypeScript project, you get proper types, autocomplete, and compile-time safety.

Because of these steps, `index.cjs` is not a hand-written artifact but a systematically generated adapter between Compact’s ZK circuits and the JavaScript world.

*Tip:* If you ever change your Compact contract (add or remove functions, change types), a fresh compilation will regenerate `index.cjs` accordingly. Always treat it as generated rather than handwritten, and refrain from changing the code manually.

In the next section, we’ll break down how **`index.cjs`** is structured internally, from boilerplate and imports, through type descriptors and composite types, all the way to the wrapper functions you actually call in your tests.

## **Inside the JavaScript Implementation: Understanding the Structure**

Once you’ve compiled your Compact contract, you’ll find the generated implementation in a file named `index.cjs`.

This file is a self-contained CommonJS module that mirrors your contract’s structure,  from type definitions to callable functions.

Let’s look at how it’s built, piece by piece.

### **1\. Implementation Initialization and Safety Checks**

At the very top, the implementation ensures that the version of `@midnight-ntwrk/compact-runtime` installed in your project matches the version expected by the compiler. It also verifies that the arithmetic field used by the circuits is consistent.

```javascript
'use strict';

const __compactRuntime = require('@midnight-ntwrk/compact-runtime');
const expectedRuntimeVersionString = '0.8.1';
const expectedRuntimeVersion = expectedRuntimeVersionString.split('-')[0].split('.').map(Number);
const actualRuntimeVersion = __compactRuntime.versionString.split('-')[0].split('.').map(Number);
if (expectedRuntimeVersion[0] != actualRuntimeVersion[0] || [...])
  throw new __compactRuntime.CompactError(`Version mismatch...`);

{ 
  const MAX_FIELD = 52435875175126190479447740508185965837690552500527637822603658699938581184512n;
  if (__compactRuntime.MAX_FIELD !== MAX_FIELD)
    throw new __compactRuntime.CompactError(`compiler thinks maximum field value is ${MAX_FIELD}...`);
}
```

This boilerplate ensures that your locally installed implementation matches what the Compact compiler expected when it generated the circuits.

### **2\. Type Definitions and Descriptors**

Next, the file defines **enumerations** and **type descriptors**.

These tell the implementation how to encode and decode the data types used in your contract — like integers, strings, or custom structs.

```javascript 
var State;
(function (State) {
  State[State['VACANT'] = 0] = 'VACANT';
  State[State['OCCUPIED'] = 1] = 'OCCUPIED';
})(State = exports.State || (exports.State = {}));

const _descriptor_1 = new __compactRuntime.CompactTypeUnsignedInteger(18446744073709551615n, 8);
const _descriptor_2 = new __compactRuntime.CompactTypeBytes(32);
const _descriptor_3 = new __compactRuntime.CompactTypeBoolean();
const _descriptor_4 = new __compactRuntime.CompactTypeOpaqueString();
```

Each `_descriptor_*` object defines how JavaScript and the on-chain values are represented.

### **3\. Composite Types and Data Structures**

Complex Compact types, like `Option`, `Maybe`, or structured records, are represented as small JavaScript classes that combine primitive descriptors.

```javascript
class _Maybe_0 {
  alignment() {
    return _descriptor_3.alignment().concat(_descriptor_4.alignment());
  }
  fromValue(value_0) {
    return {
      is_some: _descriptor_3.fromValue(value_0),
      value: _descriptor_4.fromValue(value_0)
    };
  }
  toValue(value_0) {
    return _descriptor_3.toValue(value_0.is_some)
      .concat(_descriptor_4.toValue(value_0.value));
  }
}
```

Each of these classes provides methods like `fromValue()` and `toValue()` to convert between **JavaScript objects** and **ledger-compatible encodings**.

### **4\. The Contract Class and Circuit Wrappers**

This is where things get interesting; the generated implementation defines a `Contract` class that mirrors your Compact contract’s **entry points** (such as `post`, `takeDown`, etc.).

These methods don’t execute business logic directly; instead, they prepare inputs, execute the entrypoints of the contract implementation, and handle proof data.

```javascript
class Contract {
  constructor(witnesses) {
    this.witnesses = witnesses;
    this.circuits = {
      post: (...args) => {
        const context = args[0];
        const newMessage = args[1];
        const partialProofData = {
          input: { value: _descriptor_4.toValue(newMessage), alignment: _descriptor_4.alignment() },
          output: undefined,
          publicTranscript: [],
          privateTranscriptOutputs: []
        };
        const result = this._post_0(context, partialProofData, newMessage);
        return { result, context, proofData: partialProofData };
      },
      takeDown: (...args) => {
        [...]
      }
    };
  }
}
```

When you call `contract.circuits.post(context, newMessage)` in JavaScript, the implementation automatically:

* Validates input types

* Encodes data for the ZK circuit

* Executes the Compact logic

* Returns structured proof data for verification

### **5\. Exports and Type Bindings**

Finally, the implementation exports everything you’ll need to interact with the contract in your JavaScript code or tests.

`exports.Contract = Contract;`

`exports.State = State;`

The corresponding `index.d.cts` file provides type hints so that when you import this module in a TypeScript project, your IDE understands what functions and structures are available.

Each of these sections works together to make the Compact contract executable outside the blockchain, in a safe and fully verifiable way.

In the next section, we’ll see how you can use this implementation in practice: setting it up in a JavaScript test environment and running contract calls just like you would on-chain.

## **Using the JavaScript Implementation**

Now that you understand how the `index.cjs` file is structured, let’s see how to use it in your own development workflow.

In this section, we’ll walk through how to import the implementation, instantiate the contract, and call its functions from a regular JavaScript or TypeScript environment.

### **1\. Importing the Implementation**

Once you’ve compiled your Compact contract, the compiler will output three key files in the build directory:

- `index.cjs`  
- `index.cjs.map`  
- `index.d.cts`

You can load the implementation just like any other Node.js module:

`const { Contract, State } = require('./index.cjs');`

If you’re using TypeScript, the accompanying declaration file (`index.d.cts`) will automatically provide type hints for your contract and its methods.

### **2\. Instantiating the Contract**

Every Compact contract implementation expects a [**witness object**](https://docs.midnight.network/develop/reference/compact/lang-ref#declaring-witnesses-for-private-state) when it’s created.  
This object typically contains references to cryptographic keys or helper functions that represent a party’s identity in the ZK system.

Here’s a minimal example:

```javascript
const contract = new Contract({  
	localSecretKey: () =>  
		Buffer.from('aabbccddeeff00112233445566778899', 'hex')  
});
```

The implementation checks that this object is correctly formed before allowing any circuit execution — if you forget a required field, it throws a descriptive `CompactError`.

### **3\. Calling Contract Functions**

Each contract entry point (like `post` or `takeDown` in this example) is exposed as a JavaScript function under `contract.circuits`.

These wrappers prepare the inputs, run the JavaScript code, and return structured results containing the **output**, **context**, and **proof data**.

```javascript
const context = {  
	originalState: { status: State.VACANT },  
	transactionContext: { timestamp: Date.now() }  
};

const message = "Hello from Compact!";

const { result, proofData, context } =   
	contract.circuits.post(context, message);

// result: Circuit result (e.g., new state)  
// proofData: Data you can use for proof verification  
// context: The new context
```

The `proofData` object contains the same type of witness and transcript information that the blockchain implementation would generate during an actual transaction — meaning you can verify or inspect the same structure locally.

### **4\. Writing Unit Tests**

Because the Compact implementation is just a CommonJS module, you can easily integrate it with **Vitest, Jest**, **Mocha**, or any testing framework you prefer.

```javascript
describe('Bulletin Board Contract', () => {  
	it('should accept a new post', () => {  
		const ctx = { originalState: { status: State.VACANT }, transactionContext: {} };
    const result = contract.circuits.post(ctx, "Test message");
    expect(result.result.status).toBe(State.OCCUPIED);  
	});  
});
```

This makes it easy to test your contract logic off-chain, with full control over inputs and without having to run a Midnight node or a proof server.

The implementation thus serves as your **development playground**: a place to test, simulate, and reason about Compact contract logic before deploying it.

In the next section, we’ll look at **why this design matters**, how the JavaScript implementation bridges human-readable code and zero-knowledge execution, and why it’s key to making privacy-preserving smart contracts developer-friendly.

## **Why This Design Matters**

In the previous section, we saw how you can import the generated implementation, instantiate your contract, and call its functions just like any normal JavaScript class.

But you might be wondering — *why does Compact bother generating a JavaScript implementation at all?*

Why not just compile directly to zero-knowledge circuits and leave it at that?

The answer comes down to **developer experience**, **reproducibility**, and **trust**.

### **1\. A Bridge Between ZK Circuits and Everyday Code**

Zero-knowledge circuits are powerful, but they’re also complex and opaque, not something you can easily debug or test directly.

The JavaScript implementation acts as a human-friendly bridge between the low-level proof system and the high-level contract logic.

When you call:

`const { result, proofData } = contract.circuits.post(context, "Hello world!");`

You’re running exactly the same logic that the ZK circuit on-chain, but in a form that you can step through, log, and inspect in Node.js.

This means you can **validate the behavior of your contract locally** before you ever need to touch the proof server or submit a transaction to the Midnight network.

### **2\. Type Safety and Consistency Across Environments**

Because the implementation uses Compact’s own type descriptors (`CompactTypeBoolean`, `CompactTypeBytes`, etc.), the data you pass into your JavaScript tests is encoded in the exact same way it will be on-chain.  That consistency eliminates a whole class of subtle bugs, for example, differences in byte order, field alignment, or encoding length:

```javascript
// Your JS test environment
const message = "Hello Midnight!";  
const proof = contract.circuits.post(context, message);

// Your blockchain execution  
// (same inputs, same deterministic behavior)
```

You can test and reason about your contract logic with confidence that the ZK circuit behaves identically.

### **3\. Reproducibility and Proof Transparency**

Each call to a contract method in the implementation returns a structured `proofData` object — the input (along with a representation of the circuit) to the prover.

That data is crucial for **reproducible testing** and **transparent verification**:

```javascript
{
  input: { value: [...], alignment: [...] },
  output: { value: [...], alignment: [...] },
  publicTranscript: [...],
  privateTranscriptOutputs: [...]
}
```

Having this available directly in JavaScript allows you to **record**, **replay**, and **verify** circuit executions as part of your normal testing flow, without relying on external tools.

### **4\. Developer Productivity Without Compromising Privacy**

The implementation design lets Compact developers use familiar tools,TypeScript, Jest, VSCode, Node.js, while still working with privacy-preserving logic.

Instead of being locked into a specialized proving environment, you can:

* Write integration tests in the same language as your app.

* Simulate user flows off-chain.

* Validate logic changes before recompiling circuits.

It’s the best of both worlds: **developer-friendly ergonomics** with **cryptographic guarantees** under the hood.

Compact’s JavaScript implementation isn’t just a convenience feature; it’s what makes zero-knowledge smart contract development *practical*.

By exposing ZK logic through familiar code, it shortens the gap between concept, implementation, and verification.

In the next and final section, we’ll wrap up with a brief summary of what we’ve learned and how you can start experimenting with Compact contracts yourself.

## **Conclusion**

By now, you’ve seen how Compact smart contracts on the Midnight blockchain are more than just cryptographic programs; they’re part of a full developer workflow.

When you compile a Compact contract, you don’t just get zero-knowledge circuits that the blockchain can prove; you also get a **JavaScript implementation** that mirrors those circuits and lets you test, simulate, and understand your contract logic in a familiar environment.

We started by exploring **how this implementation is generated**, then walked through its **structure**, looking at type descriptors, composite data types, and the `Contract` class that wraps each circuit.

From there, we learned how to **use it in practice**:  importing the implementation, creating a witness object, calling contract methods like `post`, and writing repeatable tests in JavaScript.

Finally, we looked at **why this design matters**: it bridges the gap between developer experience and cryptographic correctness, letting you reason about private, verifiable logic with ordinary code.

The Compact implementation is more than a side product; it’s a key part of what makes building zero-knowledge smart contracts approachable. It gives you confidence that what you test locally will behave the same way once deployed on the Midnight network.

So the next time you compile a Compact contract and see an `index.cjs` file appear, take a moment to open it up, you’ll find a window into how your private, provable logic comes to life.
</file>

<file path="docs/develop/guides/wallet-dev-guide.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Midnight wallet - developer guide

There are many flavors of wallet software - browser extensions, wallets used in various backend systems, CLI apps, wallets integrated into testing environments, etc. In Midnight, they all need to implement common functionalities, like:
- deriving keys
- deriving token balance from chain data
- managing coins and data needed to generate necessary zero-knowledge proofs
- managing connection with an indexer instance
- creating token transfers and balancing transactions (i.e. paying fees for a contract call), including proof generation requests

It all, to implement robustly, is a non-trivial amount of work. For that reason, there are a couple of packages available to help with integration of wallet functionality:
- `@midnight-ntwrk/wallet-api` - high-level wallet interfaces, target abstraction to be used by code utilizing wallet functionality (e.g. browser extension implementation);
- `@midnight-ntwrk/wallet` - implementation of the `@midnight-ntwrk/wallet-api`, with some additional tools and helpers
- `@midnight-ntwrk/zswap` - reference implementation of building blocks of [Zswap](/learn/understanding-midnights-technology/zswap)
- `@midnight-ntwrk/dapp-connector-api` - description of the API meant to be injected by browser extensions to enable DApp connections.
- `@midnight-ntwrk/wallet-sdk-hd` - provides support for Hierarchical Deterministic (HD) Wallet.
- `@midnight-ntwrk/wallet-sdk-address-format` - provides support for Bech32m address format, allows parsing from to/hex.

## Installing

The Midnight wallet SDK is provided as an NPM package `@midnight-ntwrk/wallet`. 

:::important
Version 4.0.0 introduces several breaking changes! Ensure you are referencing the correct version as defined in the [release compatibility matrix](../../relnotes/support-matrix).
:::

You can install it using any node package manager, including Yarn. To install the package using Yarn, run the following command:

`yarn add @midnight-ntwrk/wallet/<VERSION>`

Replace `<VERSION>` with the required version of the wallet SDK according to the [release compatibility matrix](../../relnotes/support-matrix).


## Important information

The wallet SDK uses the `@midnight-ntwrk/zswap` library to manage its local state and construct transactions. The serialization format, which ensures transactions are processed correctly depending on the network (eg, TestNet or MainNet) they belong to, relies on the [`NetworkId`](../reference/midnight-api/zswap/enumerations/NetworkId.md) provided when building the wallet.

As of version 4.0.0, secret keys are no longer included in the serialized wallet state. If you're restoring a wallet from a serialized snapshot, you must also provide the associated seed. Ensure that sensitive data is securely managed and not stored in snapshots.

---

## Managing wallet SDK instances

The `@midnight-ntwrk/wallet` package offers a builder that enables you to create wallets in various ways. Once created and started, each wallet will automatically connect to the specified node for submitting transactions, indexer for state synchronization, and proving server for generation of zero-knowledge proofs.

To create a wallet instance, begin by importing the builder from the `@midnight-ntwrk/wallet` package:

```ts
import { WalletBuilder } from '@midnight-ntwrk/wallet';
```

Next, the builder can be used to build instances:
- From a wallet-specific seed
- From a serialized state snapshot (requires the original seed)

:::important
As of version 4.0.0, the `.build()` method requires an explicit seed parameter. The `.buildFromSeed()` method is deprecated and will be removed in a future release.
:::

### Obtaining wallet seed

While in testing scenarios it is fine to take random bytes as the wallet seed (it is used to derive the specific secret keys), in practice, you need an HD wallet derivation. 
The package `@midnight-ntwrk/wallet-sdk-hd` helps with that task. It implements BIP-32-based derivation following the path:
```text
m / 44' / 2400' / account' / role / index
```

Where:
- `account` follows BIP-44 recommendations
- `role` is integer `3` for Zswap role (`Roles.Zswap`); other roles are reserved for future implementations
- `index` follows BIP-44 recommendations

:::note
This package does not handle the mnemonic-to-seed conversion. If you need to use a mnemonic, you need to convert it to a seed first using a BIP-39 implementation.
:::

```typescript
import {
  generateRandomSeed,
  HDWallet,
  Roles,
} from "@midnight-ntwrk/wallet-sdk-hd";

const seed = generateRandomSeed();

function deriveDefaultWalletSeed(seed: Uint8Array) {
  const generatedWallet = HDWallet.fromSeed(seed);

  if (generatedWallet.type != "seedOk") {
    throw new Error("Error initializing HD Wallet");
  }

  const zswapKey = generatedWallet.hdWallet
    .selectAccount(0)
    .selectRole(Roles.Zswap)
    .deriveKeyAt(0);

  if (zswapKey.type === "keyDerived") {
    return zswapKey.key;
  } else {
    throw new Error("Error deriving key");
  }
}

console.log(deriveDefaultWalletSeed(seed));
```

### Creating instance from a wallet seed

The wallet builder offers a method that enables you to instantiate a wallet with a specific seed, resulting in obtaining the same address and keys but with a fresh state that is then synchronized with the indexer. The method requires the following parameters (in the exact order):

| Name | Data type | Required? | Default |
|---|---|---|---|
| **Indexer URL** | String  | Yes | N/A|
| **Indexer WebSocket URL** | String  | Yes | N/A|
| **Proving server URL** | String  | Yes | N/A|
| **Node URL** | String  | Yes | N/A|
| **Seed** | String  | Yes | N/A|
| **Network ID** | NetworkId | Yes | N/A|
| **Log level** | LogLevel  | No | warn |
| **Discard Transaction History** | Boolean  | No | false |


```ts
import { WalletBuilder } from '@midnight-ntwrk/wallet';
import { NetworkId } from '@midnight-ntwrk/zswap';

const wallet = await WalletBuilder.build(
  'https://indexer.testnet-02.midnight.network/api/v1/graphql', // Indexer URL
  'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws', // Indexer WebSocket URL
  'http://localhost:6300', // Proving Server URL
  'https://rpc.testnet-02.midnight.network', // Node URL
  '0000000000000000000000000000000000000000000000000000000000000000',
  NetworkId.TestNet,
  'error' // LogLevel
);
```

### Creating a random, disposable instance

Starting from version 4.0.0, you must provide a seed when creating a wallet instance. The concept of ephemeral wallets (without seed) is deprecated.

This requires the following parameters (in the precise order):

| Name | Data type | Required? | Default |
|---|---|---|---|
| **Indexer URL** | String  | Yes | N/A|
| **Indexer WebSocket URL** | String  | Yes | N/A|
| **Proving server URL** | String  | Yes | N/A|
| **Node URL** | String  | Yes | N/A|
| **Seed** | String  | Yes | N/A|
| **Network ID** | NetworkId | Yes | N/A|
| **Log level** | LogLevel  | No | warn |
| **Discard Transaction History** | Boolean  | No | false |



```ts
import { WalletBuilder } from '@midnight-ntwrk/wallet';
import { NetworkId } from '@midnight-ntwrk/zswap';

import { generateRandomSeed } from '@midnight-ntwrk/wallet-sdk-hd';

const randomSeed = generateRandomSeed();

const wallet = await WalletBuilder.build(
  'https://indexer.testnet-02.midnight.network/api/v1/graphql', // Indexer URL
  'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws', // Indexer WebSocket URL
  'http://localhost:6300', // Proving Server URL
  'https://rpc.testnet-02.midnight.network',  // Node URL
  randomSeed,
  NetworkId.TestNet,
  'error'
);
```

### State snapshots

The wallet state can be serialized for later restoration. This is especially useful in environments like browser extensions or mobile apps, where you want to quickly restore a user's wallet without full resynchronization from genesis.

To create a snapshot of the current wallet state, use the `serialize()` method.

As of version 4.0.0, secret keys are no longer included in the serialized state. To restore a wallet, you must also provide the original seed used to create it.

To create a wallet instance from the serialized state use method `WalletBuilder.restore`. This method requires the following parameters (in the precise order):

| Name | Data type | Required? | Default |
|---|---|---|---|
| **Indexer URL** | String  | Yes | N/A |
| **Indexer WebSocket URL** | String  | Yes | N/A |
| **Proving server URL** | String  | Yes | N/A |
| **Node URL** | String  | Yes | N/A |
| **Serialized state** | String  | Yes | N/A |
| **Log level** | LogLevel  | No | warn |
| **Discard Transaction History** | Boolean  | No | false |

Note that this builder method doesn't provide a network ID parameter, because it is stored in the serialized snapshot.

The example below shows how to prepare a state snapshot and later restore wallet from it:

```ts
import { WalletBuilder } from '@midnight-ntwrk/wallet';

const originalWallet = await WalletBuilder.build(/* ... */);
// Start, sync, and use the wallet...

const serializedState = await originalWallet.serialize();

const restoredWallet = await WalletBuilder.restore(
  'https://indexer.testnet-02.midnight.network/api/v1/graphql', // Indexer URL
  'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws', // Indexer WebSocket URL
  'http://localhost:6300', // Proving Server URL
  'https://rpc.testnet-02.midnight.network', // Node URL
  '0000000000000000000000000000000000000000000000000000000000000000', // seed associated with serializedState
  serializedState,
  'error'
);
```

## Wallet instance lifecycle

Creating a wallet does only initialize its internal state.

To begin synchronizing the wallet with the indexer, use the `start()` method on wallet instance:

```ts
 wallet.start();
```

To gracefully close a wallet instance, use the `close()` method:

```ts
await wallet.close();
```

Returned promise will resolve after all resources used for synchronization are released.

## Accessing the wallet state

The [wallet state](/develop/reference/midnight-api/wallet-api/type-aliases/WalletState) is provided through an `rx.js` observable. You can operate on the state value using various operators supported by `rx.js`. The simplest use is to simply log the state upon each change:

```ts
wallet.state().subscribe((state) => {
  console.log(state);
});
```

## Addresses

Midnight wallet uses Bech32m address format by default, as implemented in `@midnight-ntwrk/wallet-sdk-address-format` package. It provides utilities to encode/decode Bech32m format while handling the Midnight-specific human-readable part, as well as defines types for the addresses in use.

The human-readable prefix of any address consists of following parts, separated by an underscore (`_`):
- constant `mn` indicating it is a Midnight address
- type of address encoded, now, only `shield-addr` for a payment address is used, as well as `shield-esk` when interacting with the Indexer. Future implementations will use other types as well
- network identifier, one of the following:
  - mainnet - omit
  - testnet - "test"
  - devnet - "dev"
  - undeployed - "undeployed" 

An example of encoding and decoding an address for testnet is shown below:
```typescript
import {
  ShieldedAddress,
  ShieldedCoinPublicKey,
  ShieldedEncryptionPublicKey,
  MidnightBech32m,
} from "@midnight-ntwrk/wallet-sdk-address-format";
import { NetworkId } from "@midnight-ntwrk/zswap";
import { Buffer } from "buffer";

const coinPublicKey = new ShieldedCoinPublicKey(
  Buffer.from(
    "064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67",
    "hex",
  ),
);
const encryptionPublicKey = new ShieldedEncryptionPublicKey(
  Buffer.from(
    "0300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a",
    "hex",
  ),
);
const address = new ShieldedAddress(coinPublicKey, encryptionPublicKey);
const encodedAddress: string = ShieldedAddress.codec
  .encode(NetworkId.TestNet, address)
  .asString();
console.log(encodedAddress); //prints addr_test1qe8qj25qkva7ug6qf3rvl3y0a366ydt2nvq30rwk5ckznavfdansxqqx83m48p22agv25y0sf4mm83l25zgcuj4f34027pcymr6v9lp89zv7lwu2wyn472s6ahfflpusy8sfv268xrumgls62hqz4u

const parsedAddress: MidnightBech32m = MidnightBech32m.parse(encodedAddress);
const decodedAddress: ShieldedAddress = ShieldedAddress.codec.decode(
  NetworkId.TestNet,
  parsedAddress,
);
console.log(decodedAddress.coinPublicKeyString()); // prints 064e092a80b33bee23404c46cfc48fec75a2356a9b01178dd6a62c29f5896f67
console.log(decodedAddress.encryptionPublicKeyString()); // prints 0300063c7753854aea18aa11f04d77b3c7eaa0918e4aa98d5eaf0704d8f4c2fc272899efbb8a71275f2a1aedd29f879021e0962b4730f9b47e1a

```


## Working with transactions

Conceptually, preparing a transaction and submitting it to network is done in 3 steps:
1. Prepare an unproven transaction - outline of transaction to be created
2. Compute needed zero-knowledge proofs and convert outline into the final transaction
3. Submit the transaction

:::note

It is important to ensure that wallet's synchronization progress has reached the tip of the chain before preparing a transaction. Otherwise, there is a very likely possibility of spending a coin, which was already spent, but wallet instance has not learned that fact yet, and in turn - node rejecting the transaction because of detected double spend attempt.

:::

### Preparing transaction - making a transfer

The wallet API includes a `transferTransaction()` method that enables you to construct transactions specifying the token type, amount, and recipient address.

This method requires an array of objects containing the following properties:

| Name | Data type | Required? |
|---|---|---|
| **amount** | BigInt  | Yes |
| **type** | TokenType | Yes |
| **receiverAddress** | Address | Yes |


Below, you can see an example of how you can utilize the API:

```ts
import { nativeToken } from '@midnight-ntwrk/zswap';

const transferRecipe = await wallet.transferTransaction([
  {
    amount: 1n,
    receiverAddress: '<midnight-wallet-address>',
    type: nativeToken() // tDUST token type
  }
]);
```

### Preparing transaction - balancing an existing transaction

Balancing an existing transaction is particularly useful, when working with DApps or complementing a swap. It is a process, where transaction is inspected for imbalances between values of provided inputs and outputs, and then a complementary transaction is created, which provides or extracts value (by adding inputs or outputs) needed to pay fees and reduce imbalances. It can be done with `balanceTransaction` method, which requires the following parameters:

| Name | Data type | Required? |
|---|---|---|
| **transaction** | Transaction  | Yes |
| **newCoins** | CoinInfo[]  | No |

:::note

The `newCoins` parameter is intended for cases where a new coin is created, such as when a DApp mints one and intends to send it to the wallet. Due to the nature of the Midnight TestNet, these newly created coins must be explicitly provided to the wallet using this method. This allows the wallet to monitor and incorporate them into its state effectively.

:::

```ts
const balancedRecipe = await wallet.balanceTransaction(transaction);
```

### Proving a transaction

Once unproven transaction is ready - it can be proven. Wallet does wrap the results of `transferTransaction` and `balanceTransaction` into objects called `ProvingRecipe` - they allow passing the results of these methods directly to `proveTransaction` method, without conditional logic between to decide what exactly needs to be proven and merged. It takes following parameters:

| Name | Data type | Required? |
|---|---|---|
| **provingRecipe** | ProvingRecipe  | Yes |


For example, the `transferRecipe` created [above](#preparing-transaction---making-a-transfer) has a following shape and can be proven like below:

```ts
import { TRANSACTION_TO_PROVE } from '@midnight-ntwrk/wallet-api';

const recipe = {
  type: TRANSACTION_TO_PROVE, // available from the Wallet API
  transaction: anUnprovenTransferTransaction // this is a balanced, unproven transaction
};

const provenTransaction = await wallet.proveTransaction(recipe);
```

:::note

Computing zero-knowledge proofs is a very computationally heavy operation. For that reason one needs to expect that calls to `proveTransaction` take tens of seconds. This is also reason why a proving server is needed at this moment - running native code makes the zero-knowledge technology feasible to use in Midnight.

:::


### Submitting a transaction

Once final, proven transaction is created, it can be submitted. To submit a transaction, you need to use the `submitTransaction` method, which requires the following parameters:

| Name | Data type | Required? |
|---|---|---|
| **transaction** | Transaction  | Yes |


The transaction must be balanced (value of tokens in inputs needs to be at least equal to value of tokens in output, as well as cover fees) and proven for it to be accepted by the node.

The example below uses the `provenTransaction` from the section above:

```ts
const submittedTransaction = await wallet.submitTransaction(provenTransaction);
```

## Connecting to a DApp

See the [DApp connector overview](/develop/reference/midnight-api/dapp-connector/) and [Wallet Provider](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/WalletProvider) for more details. The former is the API expected to be injected by a browser extension wallet, the latter is interface used by Midnight.js to interact with wallet.

## Examples

In this section, you'll find examples of how you can fully utilize the wallet APIs.

### Transferring tDUST

This example instantiates a new wallet and uses it to transfer one tDUST to another wallet:

```ts
import { WalletBuilder } from '@midnight-ntwrk/wallet';
import { NetworkId, nativeToken } from '@midnight-ntwrk/zswap';

try {
  const wallet = await WalletBuilder.build(
    'https://indexer.testnet-02.midnight.network/api/v1/graphql',
    'wss://indexer.testnet-02.midnight.network/api/v1/graphql/ws',
    'http://localhost:6300',
    'https://rpc.testnet-02.midnight.network',
    '0000000000000000000000000000000000000000000000000000000000000000',
    NetworkId.TestNet
  );

  wallet.start();

  const transferRecipe = await wallet.transferTransaction([
    {
      amount: 1n,
      type: nativeToken(),
      receiverAddress: 'mn_shield-addr_test1kjwksfp8x2tachehsfvufsdl35ljg5cxzdcysjdn6ntadspyxn3qxqrxypgjm055c2azrpuyn7un0ge2vm25vkfv38d24rj3ewcku5wmdc94gjr9' // Example Bech32m address
    }
  ]);

  const provenTransaction = await wallet.proveTransaction(transferRecipe);
  const submittedTransaction = await wallet.submitTransaction(provenTransaction);

  console.log('Transaction submitted:', submittedTransaction);
} catch (error) {
  console.error('An error occurred:', error);
}
```
</file>

<file path="docs/develop/how-midnight-works/_circuit_constraints.mdx">
```text title="Circuit constraints"
guess_number:
  inputs:
    public: n1, n2, n3,
      transcript code
    private: a1, b1, a2, b2
  constraints:
    a1 != 1
    b1 != 1
    a1 * b1 = n2
    a2 != 1
    b2 != 1
    n3 = a2 * b2
    // Additional constraints
    // enforcing the shape of
    // the public transcript
```
</file>

<file path="docs/develop/how-midnight-works/_circuit_example.mdx">
```python title="In-circuit code"
def guess_number():



  assert(a != 1 and b != 1, "...")


  assert(a * b == n2, "...")


  assert(a != 1 and b != 1, "...")

  n3 = a * b

```
</file>

<file path="docs/develop/how-midnight-works/_ledger_assignments.mdx">
```python title="Public transcript"
n1 = 35
n2 = 35
n3 = 12

assert(n1 == number)
assert(n2 == number)
number = n3
```
</file>

<file path="docs/develop/how-midnight-works/_ledger_example.mdx">
```python title="On-chain code"

n1 = number




n2 = number






number = n3
```
</file>

<file path="docs/develop/how-midnight-works/_private_assignments.mdx">
```text title="Private transcript"
a1 = 5
b1 = 7
a2 = 2
b2 = 6
```
</file>

<file path="docs/develop/how-midnight-works/_private_example.mdx">
```python title="Off-chain code"


(a, b) = local.
  guess_factors(n1)




(a, b) = local.
  new_challenge()




```
</file>

<file path="docs/develop/how-midnight-works/building-blocks.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Building blocks

Midnight's transaction structure is unique and may not be immediately
intuitive. 

## Transactions

In Midnight, transactions consist of:
- a 'guaranteed' [Zswap offer](./zswap.mdx#offers)
- an optional 'fallible' Zswap
  offer
- an optional contract calls segment, consisting of:
  - a sequence of [contract calls](#contract-calls) or [contract deploys](#contract-deployments)
  - a cryptographic binding commitment (see: [transaction integrity](#transaction-integrity))
- a binding randomness (see transaction integrity).

## Contract deployments

A contract deployment creates a new contract if it does not already exist and
fails otherwise. It is executed entirely as part of the
'fallible' execution step.

Contract deployment transaction parts consist of a [contract
state](./semantics#contract-state) and a nonce, creating a new contract at the
address that is a hash of the deploy part.

## Contract calls

A contract call invokes a specific contract address and entry point at this
address. Entry points are keys into the contracts' [operation map](./semantics#contract-state).  Combined, the two select the verifier key that a
contract call will be validated against.

A contract call declares a guaranteed and
fallible
[*transcript*](./impact#transcripts), which declares the visible effects of
this call. It further contains a *communication commitment*, which may be used
for cross-contract interaction.

:::info

Cross-contract interaction is still under development and is not available for
use at this time. The team is keen to hear what kinds of interactions you would like
to be able to do.

:::

Finally, a contract call includes a zero-knowledge proof that the transcripts
are valid for this contract and binding to other transaction elements.

## Merging

Zswap permits atomic swaps by allowing transactions to be merged.
Currently, contract call sections cannot be merged, but 
two transactions can be merged if at least one of them has an empty contract call
section. This outputs a new, composite transaction and has the effect of both
input transactions combined.

## Transaction integrity

Midnight inherits the basic transaction integrity mechanism from Zswap,
which, due to the ability to merge, uses Pedersen commitments for transaction
integrity. These commitments commit to the value of each input and output of a
transaction and are homomorphically summed before the whole transaction is
checked for integrity by opening the composite commitment. Only people who
created the individual components of the transaction know the opening
randomnesses summed to decompose the transaction. This ensures a form of
binding that guarantees that the user's funds are spent as they originally
intended.

This binding is extended to contract calls by the contract call section
contributing to the overall Pedersen commitment. This contribution is further
restricted to carry no value vector, by requiring knowledge of an exponent of
the generator, in the form of a Fiat-Shamir transformed Schnorr proof.
</file>

<file path="docs/develop/how-midnight-works/impact.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# The Impact VM

:::info

Impact is still under active revision. Expect its attributes, including storage-related costs, to change.

Currently, users cannot write Impact manually; this feature may be added in the future.

:::

On-chain parts of programs are written in *Impact*, our on-chain VM language.
You should not need to worry about the details of impact when writing
contracts; however, you may see it appear when inspecting transactions and
contract outputs.

Impact is a stack-based, non-Turing-complete state manipulation language. A
contract is executed on a stack containing three things:
- a 'context' object describing context related to the containing transaction
- an 'effects' object gathering actions performed by the contract during the execution
- the contract's current state.

Program execution proceeds linearly, with no operations being able to decrease
the program counter and every operation being bounded in the time it takes.
Program execution has an attached cost, which may be bounded by a 'gas' limit.
Programs can either abort, invalidating this (part of) a transaction, or
succeed, in which case they must leave a stack in the same shape as they
started. The resulting effects must match the transcript's
declared effects, and the contract state must be marked as storable, in which
case it is adopted as the updated state.

## Transcripts

Execution transcripts consist of:
- a declared gas bound, used to derive the fees for this call
- a declared effects object, used to bind the contract's semantics to that of
  [other parts](./semantics.mdx)
- the program to execute.

## Values

The Impact stack machine operates on the following state values:
- `null`
- `<x: y>`, a field-aligned binary cell
- `Map { k1: v1, k2: v2, ... }`, a map from field-aligned binary values to
  state values
- `Array(n) [ v0, v1, ... ]`, an array of `0 < n < 16` state values
- `MerkleTree(d) { k0: v1, k2: v2, ... }`, a sparse, fixed-depth `1 <= d <= 32`
  Merkle tree, with the slots `k0`, `k2`, ..., containing the leaf hashes `v1`,
  `v2`, ... (typically represented as hex strings).

## Field-aligned binary

The basic data types used in Impact are 'field-aligned binary' (FAB) values. These
values can store complex data structures in a binary representation while 
keeping the information necessary to encode them as field elements in any prime
field.

Aligned values consist of a sequence of aligned *atoms*, each of which consists
of a byte string and an alignment atom, where alignment atoms are one of:
- `f`, indicating a field alignment: the atom will be interpreted as a
  little-endian representation of a field element.
- `c`, indicating a compression alignment: the atom will be interpreted as a 
field element derived by hashing its value.
- <code>b<em>n</em></code>, indicating an <code>n</code>-byte alignment: the
  atom will be interpreted as a sequence of field elements depending on the
  prime field and curve to compactly encode <code>n</code> bytes.

### Programs

A program is a sequence of operations, consisting of an opcode, potentially
followed by a number of arguments depending on the specific opcode. Programs
can be run in two modes: *evaluating* and *verifying*. In verifying mode,
`popeq[c]` arguments are enforced for equality, while in evaluating mode, the
results are gathered instead.

Each `Op` has a fixed effect on the stack, which will be written as `-{a, b}
+{c, d}`: consuming items `a` and `b` being at the top of the stack (with `a`
above `b`), and replacing them with `c` and `d` (with `d` above `c`). The
number of values here is just an example. State values are _immutable_ from the
perspective of programs: a value on the stack cannot be changed, but it can be
replaced with a modified version of the same value. We write `[a]` to refer to
the value stored in the cell `a`. Due to the ubiquity of it, we write
'sets `[a] := ...`' for 'create `a` as a new cell containing `...`'. We
prefix an output value with a `'` to indicate this is a *weak* value, kept
solely in-memory, and not written to disk, and an input value with `'` to
indicate it *may* be a weak value. We use `"` and `†` to indicate that an input
*may* be a weak value, and *iff* it is, the correspondingly marked output will
be a weak value.

Where arguments are used, we use `State` for a state value, `u21` for a 21-bit
unsigned integer, and `path(n)` for a sequence of *either* field-aligned binary
values, *or* the symbol `stack`, indicating keys to use in indexing, either
directly, or to use stack values instead.

| Name      | Opcode  | Stack                             | Arguments                       | Cost (unscaled) | Description |
| :---      | ------: | :-----                            | ------------------------------: | --------------: | ----------- |
| `noop`    |    `00` | `-{}               +{}`           |                        `n: u21` |             `n` | nothing |
| `lt`      |    `01` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [a] < [b]` |
| `eq`      |    `02` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [a] == [b]` |
| `type`    |    `03` | `-{'a}             +{b}`          |                               - |             `1` | sets `[b] := typeof(a)` |
| `size`    |    `04` | `-{'a}             +{b}`          |                               - |             `1` | sets `[b] := size(a)` |
| `new`     |    `05` | `-{'a}             +{b}`          |                               - |             `1` | sets `[b] := new [a]` |
| `and`     |    `06` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [a] & [b]` |
| `or`      |    `07` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [a] | [b]` |
| `neg`     |    `08` | `-{'a}             +{b}`          |                               - |             `1` | sets `[b] := ![a]` |
| `log`     |    `09` | `-{'a}             +{}`           |                               - |             `1` | outputs `a` as an event |
| `root`    |    `0a` | `-{'a}             +{b}`          |                               - |             `1` | sets `[b] := root(a)` |
| `pop`     |    `0b` | `-{'a}             +{}`           |                               - |             `1` | removes `a` |
| `popeq`   |    `0c` | `-{'a}             +{}`           |   `a: State` only when validating |         `|a|` | returns `a` |
| `popeqc`  |    `0d` | `-{'a}             +{}`           |   `a: State` only when validating |         `|a|` | returns `a`, which must already be in memory |
| `addi`    |    `0e` | `-{'a}             +{b}`          |                        `c: State` |             `1` | sets `[b] := [a] + c`, where addition is defined below |
| `subi`    |    `0f` | `-{'a}             +{b}`          |                        `c: State` |             `1` | sets `[b] := [a] - c`, where subtraction is defined below |
| `push`    |    `10` | `-{}               +{'a}`         |                        `a: State` |         `|a|` | sets `a` |
| `pushs`   |    `11` | `-{}               +{a}`          |                        `a: State` |         `|a|` | sets `a` |
| `branch`  |    `12` | `-{'a}             +{}`           |                        `n: u21` |             `1` | if `a` is non-empty, skip `n` operations. |
| `jmp`     |    `13` | `-{}               +{}`           |                        `n: u21` |             `1` | skip `n` operations. |
| `add`     |    `14` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [a] + [b]` |
| `sub`     |    `15` | `-{'a, 'b}         +{c}`          |                               - |             `1` | sets `[c] := [b] - [a]` |
| `concat`  |    `16` | `-{'a, 'b}         +{c}`          |                        `n: u21` |             `1` | sets `[c] = [b] ++ [a]`, if `|[a]| + |[b]| \< n` |
| `concatc` |    `17` | `-{'a, 'b}         +{c}`          |                        `n: u21` |             `1` | as `concat`, but `a` and `b` must already be in-memory |
| `member`  |    `18` | `-{'a, 'b}         +{c}`          |                               - |       `size(b)` | sets `[c] := has_key(b, a)` |
| `rem`     |    `19` | `-{a, "b}          +{"c}`         |                               - |       `size(b)` | sets `c := rem(b, a, false)` |
| `remc`    |    `1a` | `-{a, "b}          +{"c}`         |                               - |       `size(b)` | sets `c := rem(b, a, true)` |
| `dup`     |    `3n` | `-{x*, "a}         +{"a, x*, "a}` |                               - |             `1` | duplicates `a`, where `x*` are `n` stack items |
| `swap`    |    `4n` | `-{"a, x*, †b}     +{†b, x*, "a}` |                               - |             `1` | swaps two stack items, with `n` items `x*` between them |
| `idx`     |    `5n` | `-{k*, "a}         +{"b}`         |                    `c: path(n)` | `|c| + sum size(x_i)` | where `k*` are `m` stack items, `k_1` - `k_{m+1}`, matching the `stack` symbols in `c`. Sets `"x_1 = "a`, `key_j = if c_j == 'stack' then k_{i++} else c_j`, `"x_{j+1} = "x_j.get(key_j, cached)`, `"b = "x_{n+2}`  for `i` initialized to 1, with `cached` set to `false` |
| `idxc`    |    `6n` | `-{k*, "a}         +{"b}`         |                    `c: path(n)` | `|c| + sum size(x_i)` | like `idx`, but with `cached` set to `true` |
| `idxp`    |    `7n` | `-{k*, "a}         +{"b, pth*}`   |                    `c: path(n)` | `|c| + sum size(x_i)` | as `idx`, with `pth*` set to `{key_{n+1}, "x_{n+1}, ..., key_1, "x_1}` |
| `idxpc`   |    `8n` | `-{k*, "a}         +{"b, pth*}`   |                    `c: path(n)` | `|c| + sum size(x_i)` | as `idxp`, but with `cached` set to `true` |
| `ins`     |    `9n` | `-{"a, pth*}       +{†b}`         |                               - | `sum size(x_i)` | where `pth*` is `{key_{n+1}, x_{n+1}, ..., key_1, x_1}` set `x'_{n+2} = a`, `x'_j = ins(x_j, key_j, cached, x'_{j+1})`, `b = x'_1`. `†` is the weakest modifier of `a` and `x_j`s, and `cached` set to `false` |
| `insc`    |    `an` | `-{"a, pth*}       +{†b}`         |                               - | `sum size(x_i)` | as `ins`, but with `cached` set to `true` |
| `ckpt`    |    `ff` | `-{}               +{}`           |                                 |             `1` | denotes boundary between internally atomic program segments. Should not be crossed by jumps. |

In the description above, the following short-hand notations are used. Where
not specified, result values are placed in a `Cell` and encoded as FAB values.

* `a + b`, `a - b`, or `a < b` (collectively `a op b`), for applying `op` on
  the contents of cells `a` and `b`, interpreted as 64-bit unsigned integers,
  with alignment `b8`.
* `a ++ b` is the field aligned binary concatenation of `a` and `b`.
* `a == b` for checking two cells for equality, at least one of which must
  contain at most 64 bytes of data
* `a & b`, `a | b`, `!a` are processed as boolean and, or, and not over the
  contents of cells `a` and maybe `b`. These must encode 1 or 0.
* `typeof(a)` returns a tag representing the type of a state value:
  * `<a: b>`: 0
  * `null`: 1
  * `Map { ... }`: 2
  * `Array(n) { ... }`: 3 + n * 32
  * `MerkleTree(n) { ... }`: 4 + n * 32
* `size(a)` returns the number of non-null entries is a `Map`, `n` for
  an `Array(n)` or `MerkleTree(n)`.
* `has_key(a, b)` returns `true` if `b` is a key to a non-null value in the
  `Map` `a`.
* `new ty` creates a new instance of a state value according to the tag `ty` (as
  returned by `typeof`):
  * cell: Containing the empty value.
  * `null` for itself
  * `Map`: The empty map
  * `Array(n)`: An array on `n` `null`s
  * `MerkleTree(n)`: A blank Merkle tree
* `a.get(b, cached)` retrieves the sub-item indexed with `b`. If the
  sub-item is *not* loaded in memory, *and* `cached` is `true`, this command
  fails. For different `a`:
  * `a: Map`, the value stored at the key `b`
  * `a: Array(n)`, the value at the index `b` < n
* `rem(a, b, cached)` removes the sub-item indexed (as in `get`) with `b` from `a`. If the
  sub-item is *not* loaded in memory, *and* `cached` is `true`, this command
  fails.
* `ins(a, b, cached, c)` inserts `c` as a sub-item into `a` at index `c`. If
  the path for this index is *not* loaded in memory, *and* `cached` is `true`,
  this command fails.
* `root(a)` outputs the Merkle-tree root of the `MerkleTree(n)` `a`.

## Context and effects

The `context` is an `Array(_)`, with the following entries, in order:

:::caution

Currently, only the first two of these are correctly initialized!

:::

1. A `Cell` containing the 256-bit aligned current contract's address.
2. A `Map` from `CoinCommitment` keys to 64-bit aligned Merkle tree indicies,
   for all newly allocated coins.
3. A `Cell` containing the block's 64-bit aligned seconds since the UNIX epoch
   approximation.
4. A `Cell` containing the block's 32-bit aligned seconds indicating the
   maximum amount that the former value may diverge.
5. A `Cell` containing the block's 256-bit hash.

This list may be extended in the future in a minor version increment.

The `effects` is an `Array(_)`, with the following entries, in order:

1. A `Map` from `Nullifier`s to `null`s, representing a set of claimed nullifiers.
2. A `Map` from `CoinCommitment`s to `null`s, representing a set of received coins claimed.
3. A `Map` from `CoinCommitment`s to `null`s, representing a set of spent coins claimed.
4. A `Map` from `(Address, Bytes(32), Field)` to `null`, representing the contract calls claimed.
5. A `Map` from `Bytes(32)` to cells of `u64`, representing coins minted for any specialization hash.

This list may be extended in the future in a minor version increment.

`effects` is initialized to `[{}, {}, {}, {}, {}]`.

All of `context` and `effects` may be considered cached. To prevent cheaply
copying data into the contract state with as little as two opcodes, both are
flagged as *weak*, and any operations performed with them. If the final
`state'` is tainted, the transaction fails, preventing this from being directly
copied into the contract's state.
</file>

<file path="docs/develop/how-midnight-works/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
slug: concepts/index
---

# Concepts

Understand the core ideas behind Midnight, including confidentiality with zero-knowledge proofs, contracts, and verifiable computation.

<details>
  <summary><strong>Core concepts cover these terms</strong></summary>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Explanation</th>
      </tr>
    </thead>

    <tbody>

      <tr>
        <td><strong>Who interacts</strong></td>
        <td>
          <strong>Accounts</strong> define who participates on Midnight.
          They manage keys, addresses, and authorization.
          This shows <em>who acts in the system</em>.
        </td>
      </tr>

      <tr>
        <td><strong>Where data lives</strong></td>
        <td>
          <strong>Ledgers</strong> store state.
          Midnight keeps a public ledger for visible data and a private ledger for shielded data.
          This shows <em>where state is stored and who can see it</em>.
        </td>
      </tr>

      <tr>
        <td><strong>How value moves</strong></td>
        <td>
          <strong>The UTXO model</strong> defines spendable pieces of value or state.
          Midnight extends this model with private state elements.
          This shows <em>how value flows through the system</em>.
        </td>
      </tr>

      <tr>
        <td><strong>How apps connect</strong></td>
        <td>
          <strong>Web3</strong> explains how wallets, connectors, and dApps communicate with contracts.
          This shows <em>how users and applications interact with Midnight</em>.
        </td>
      </tr>

      <tr>
        <td><strong>How privacy is enforced</strong></td>
        <td>
          <strong>Zero-knowledge proofs</strong> verify correctness without exposing sensitive data.
          This shows <em>how private actions stay verifiable</em>.
        </td>
      </tr>

      <tr>
        <td><strong>How computation is proved</strong></td>
        <td>
          <strong>Kachina</strong> is Midnight’s proving system.
          It converts private computation into verifiable proofs.
          This shows <em>how we trust execution we cannot see</em>.
        </td>
      </tr>

      <tr>
        <td><strong>How it all comes together</strong></td>
        <td>
          <strong>ZSwap</strong> applies these concepts in practice.
          It uses private state, proofs, and confidential execution.
          This shows <em>how a real private dApp works end-to-end</em>.
        </td>
      </tr>

    </tbody>
  </table>

</details>


<div className="mn-grid">

  <a className="mn-tile" href="/learn/understanding-midnights-technology/account">
    <h3>Accounts</h3>
    <p>Learn how Midnight accounts, addresses, and keys relate to each other.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/ledgers">
    <h3>Ledgers</h3>
    <p>See how public and private ledgers track state and interact securely.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/utxo">
    <h3>UTXO model</h3>
    <p>Review how UTXOs represent value and how Midnight extends the model.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/web3">
    <h3>Web3</h3>
    <p>Understand how Midnight fits into wallets, dApps, and existing tooling.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/zero-knowledge-proofs">
    <h3>Zero-knowledge proofs</h3>
    <p>Understand how ZK proofs protect data while proving correctness.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/kachina">
    <h3>Kachina</h3>
    <p>Learn about the proving system that powers Midnight’s confidential computation.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/learn/understanding-midnights-technology/zswap">
    <h3>ZSwap</h3>
    <p>See how confidential swaps preserve privacy while enabling efficient exchange.</p>
    <span className="mn-cta">Read →</span>
  </a>

</div>

---

Midnight uses zero-knowledge proofs to keep sensitive data private while still verifying contract logic. Its smart contracts operate across public and private ledgers, reducing transaction correlation and supporting secure, confidential on-chain atomic swaps of tokens and metadata.

<div className="mn-grid">

  <a className="mn-tile" href="/develop/how-midnight-works/building-blocks">
    <h3>Learn the building blocks</h3>
    <p>Review circuits, ledgers, and assignments that form Midnight’s foundation.</p>
    <span className="mn-cta">Explore →</span>
  </a>

  <a className="mn-tile" href="/develop/how-midnight-works/smart-contracts">
    <h3>Explore Compact contracts</h3>
    <p>See how Compact defines confidential logic and interacts with verified data.</p>
    <span className="mn-cta">Open →</span>
  </a>

  <a className="mn-tile" href="/develop/how-midnight-works/keeping-data-private">
    <h3>Keep data private</h3>
    <p>Learn the patterns that restrict data visibility to authorized participants.</p>
    <span className="mn-cta">Learn →</span>
  </a>

  <a className="mn-tile" href="/develop/how-midnight-works/semantics">
    <h3>Understand Compact semantics</h3>
    <p>Trace how the runtime enforces rules over public and private data.</p>
    <span className="mn-cta">Read →</span>
  </a>

  <a className="mn-tile" href="/develop/how-midnight-works/zswap">
    <h3>Examine ZSwap</h3>
    <p>See how confidential swaps maintain privacy and efficiency.</p>
    <span className="mn-cta">See →</span>
  </a>

  <a className="mn-tile" href="/develop/how-midnight-works/impact">
    <h3>Assess the impact</h3>
    <p>Consider how privacy-preserving computation changes decentralized systems.</p>
    <span className="mn-cta">Assess →</span>
  </a>

</div>
</file>

<file path="docs/develop/how-midnight-works/keeping-data-private.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Private data

This document describes some strategies for keeping data private in
Midnight contracts. This is not an exhaustive list, but it should help
you get started.

The most crucial thing to bear in mind is that, except for
`[Historic]MerkleTree` data types, anything that is passed as an
argument to a `ledger` operation in Compact, as well as all reads and
writes of the ledger itself, are publicly visible and should be
treated as such.  What is public is the argument or ledger value
itself, not the code that manipulates it. For instance:

```compact
export ledger items: Set<Field>;
export ledger others: MerkleTree<10, Field>;

// Reveals `item1`
items.insert(item1);
// Reveals the *value* of `f(x)`, but not `x` directly
items.member(f(x));
// The exception: Does *not* reveal `item2`, though someone that
// guesses the value of `item2` can check it!
others.insert(item2);
```

However, sometimes you need to reference shielded data in the public state. In
those cases, one of the patterns below may help.

## Hashes and commitments

The most basic approach to storing data in public, while keeping it shielded, is
to store only a hash or commitment of data, rather than the full data itself.

Compact's standard library provides two primary primitives for this:

- [`persistentHash`](../reference/compact/compact-std-library/exports#persistentHash),
  a building block to hash binary data
- [`persistentCommit`](../reference/compact/compact-std-library/exports#persistentCommit),
  a primitive for creating commitments from any Compact type.

Both of these effectively create a hash of their inputs, with `persistentHash`
being limited to the `Bytes<32>` data type and `persistentCommit` hashing
arbitrary data together with a `Bytes<32>` random value.  Hashes guarantee that
the input cannot be computed from the output, nor any information about the
input guessed, unless the whole input is guessed.  This is one reason the additional
randomness input of `persistentCommit` is important: it prevents someone from
guessing the value itself and checking that the hash matches.  This is
especially useful when there are a small number of possible values, such as an
individual vote in an election.

The other advantage of randomness is that it prevents correlating equal values:
even if I can't guess someone's password, for instance, I might recognize if the
same hashed version appears twice, which might unintentionally leak information about who made
a state change.

With sufficient randomness used, the commitment of a value can be stored on the
ledger without revealing it.

### Randomness and rounds in commitments

Fresh randomness for each commitment is desirable, but in some cases, it is
possible to re-use existing randomness by guaranteeing that the
*data* will never be the same for the same randomness.  We use this in some of
our example applications, where we reuse a secret key as a randomness source, 
together with a round counter to ensure unlinkability between rounds.

:::caution

Be careful working with randomness! It's easy to get wrong, and erring on
the safe side is generally advisable.

:::

### Authenticating with hashes

One of the most useful features of zero-knowledge proofs is that it's possible to emulate
signatures just by using hashes in a circuit. That is, just by hashing a secret
key and comparing that with a known 'public key', a contract can guarantee that only
someone that knows the secret key can continue the transaction. For instance,
here's a contract that allows only the creator to use it:

```compact
import CompactStandardLibrary;

witness secretKey(): Bytes<32>;

export ledger organizer: Bytes<32>;
export ledger restrictedCounter: Counter;
constructor() {
  organizer = publicKey(secretKey());
}

export circuit increment(): [] {
  assert(organizer == publicKey(secretKey()), "not authorized");
  restrictedCounter.increment(1);
}

circuit publicKey(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "some-domain-seperator"), sk]);
}
```

## Making use of Merkle trees

Merkle trees, exposed in Compact as the `MerkleTree<n, T>` and
`HistoricMerkleTree<n, T>` types, are a very useful tool for shielding the
values contained in a set. Their key feature is making it possible to
assert publicly that some value is contained within the `MerkleTree`, without
revealing *which* value this is.

This goes above and beyond having, for instance, a `Set<Bytes<32>>` storing
commitments and testing if a commitment is inside it, because a `MerkleTree` does
not reveal which entry's membership is proven. This property can be used, for
instance, to authorize a set of secret keys to do specific operations, without
each operation revealing which key was used to authorize it.

In practice, this works by a circuit proving that it has knowledge of
a path to an inserted value in the tree and checking that the hash of
this path matches the expected path of the tree.

The Compact standard library and compact JavaScript target ADTs provide tools
for these operations. Specifically, examine the 
[`MerkleTreePath<n, T>`](../reference/compact/compact-std-library/exports#merkletreepath) type, the
[`merkleTreePathRoot<n, T>()`](../reference/compact/compact-std-library/exports#merkle_tree_path_root)
circuit, and the `pathForLeaf()` and `findPathForLeaf()` functions exposed
on the `MerkleTree`/`HistoricMerkleTree` JavaScript state objects, as described in
the [ledger data types](../reference/compact/ledger-adt) specification.

Together, they can be used as follows:

```compact
import CompactStandardLibrary;

export ledger items: MerkleTree<10, Field>;

witness findItem(item: Field): MerkleTreePath<10, Field>;

export circuit insert(item: Field): [] {
  items.insert(item);
}

export circuit check(item: Field): [] {
  const path = findItem(item);
  assert(items.checkRoot(merkleTreePathRoot<10, Field>(path.value)), "path must be valid");
}
```

With the `findItem` implementation:

```typescript
function findItem(context: WitnessContext, item: bigint): MerkleTreePath<bigint> {
    return context.ledger.items.findPathForLeaf(item)!;
}
```

Note that `pathForLeaf` is preferable when possible, as it does not require an
*O(n)* scan of the tree, although it does require knowledge of where the item was
originally placed.

The distinction between `MerkleTree<n, T>` and `HistoricMerkleTree<n, T>` is
that `checkRoot` for the latter accepts proofs made against prior versions of
the Merkle tree. This is helpful if a tree has frequent insertions, as these
otherwise invalidate old proofs, although `HistoricMerkleTree` is not suitable if
items are frequently removed or replaced, as this could lead to proofs being
considered valid which should not be.

### The commitment/nullifier pattern

One powerful shielding pattern is to keep data in two different committed forms (referred
to as "commitments" and "nullifiers"), with the former kept in a Merkle tree,
and the latter in a `Set`. This lets us make single-use authentication tokens
by first creating an entry in the Merkle tree and then when using it, proving
its existence and adding the nullifier to a `Set`, asserting that it is not already
there. This ensures that re-using the token isn't possible, while still not
revealing which token was used. This is the underlying pattern of Zerocash and [Zswap](./zswap.mdx), which uses it to build shielded UTXOs.

It's crucial that the commitments and nullifiers use a domain separator to
ensure they are not equal for the same secret data and, optionally, that creating the nullifier requires
secret knowledge (as in the [authenticating with hashes
section](#authenticating-with-hashes)), which ensures that the initial
authorizer can't identify the token's use either.

Here's an example where public keys are authorized to increment a counter, once
only:

```compact
import CompactStandardLibrary;

witness findAuthPath(pk: Bytes<32>): MerkleTreePath<10, Bytes<32>>;
witness secretKey(): Bytes<32>;

export ledger authorizedCommitments: HistoricMerkleTree<10, Bytes<32>>;
export ledger authorizedNullifiers: Set<Bytes<32>>;
export ledger restrictedCounter: Counter;

export circuit addAuthority(pk: Bytes<32>): [] {
  authorizedCommitments.insert(pk);
}

export circuit increment(): [] {
  const sk = secretKey();
  const authPath = findAuthPath(publicKey(sk));
  assert(authorizedCommitments.checkRoot(merkleTreePathRoot<10, Bytes<32>>(authPath)),
    "not authorized");
  const nul = nullifier(sk);
  assert !authorizedNullifiers.member(nul) "already incremented";
  authorizedNullifiers.insert(disclose(nul));
  restrictedCounter.increment(1);
}

circuit publicKey(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "commitment-domain"), sk]);
}

circuit nullifier(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}
```
</file>

<file path="docs/develop/how-midnight-works/semantics.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Transaction semantics

## Ledger states

Midnight's ledger consists of two items:
- Zswap's state
  - a Merkle tree of coin commitments
  - an index to the first free slot of the coin commitment tree
  - a set of nullifiers
  - a set of valid past Merkle tree roots
- a map from contract addresses to contract states.

### Contract state

A contract state consists of:
- an [Impact state value](./impact#values)
- a map of entry point names to operations, where entry points
  correspond to exported circuits in a contract.

A contract operation consists of a Snark verifier key that is used to validate
contract calls made against this contract and entry point.

## Transaction fallibility

Transactions execute in three stages:
- well-formedness check
- guaranteed phase
- fallible phase.

The well-formedness check is run without any state and checks the general
integrity and consistency of the transaction. In contrast, both the guaranteed
and fallible phases are run against the ledger state and either produce a new 
state or fail. If a transaction fails during the guaranteed phase, it is *not
included in the ledger*. If it fails during the fallible phase,
any effects of the guaranteed phase *still apply*, and the ledger will record
the transaction as a *partial success*.

The fees for all phases of execution are collected in the *guaranteed* phase
and are forfeited if a transaction fails in the fallible phase.

## Well-formedness

The well-formedness check verifies that a transaction is in a canonical format, and that:
- all zero-knowledge proofs in [Zswap](./zswap.mdx) offers can be verified
- the Schnorr proof in the contract section can verified
- the guaranteed offer is balanced with respect to the following adjustments:
  - subtraction of the fees of the entire transaction
  - addition of any mints performed in guaranteed transcripts
- the fallible offer is balanced with respect to the following adjustment:
  - Addition of any mints performed in fallible transcripts
- each contract-owned input or output is claimed exactly once by the same
  contract in the effects section of the transcript matching the fallibility of
  the offer it appears in
- any outputs claimed as being created by a contract in the effects section of a
  transcript are claimed at most once, and they appear in the offer matching the
  fallibility of the transcript
- any contract calls that are claimed in a transcript are present and claimed at most
  once
- if a contract call has both a guaranteed and fallible section, the fallible
  section starts with a `ckpt` operation.

## Phase execution

Other than the notes in the [transaction fallibility
section](#transaction-fallibility), the guaranteed and fallible phases operate
similarly, except that the following additional work is performed in
the guaranteed phase:
- contract operations for all calls are looked up, and the zero-knowledge
  proofs are verified against them
- the fallible Zswap section is also applied during the guaranteed section, to
  ensure that it cannot invalidate the fallible section by itself. [^1]

Then:
1. The phase's Zswap offer is applied, by inserting new commitments
into the Merkle tree and nullifiers into the nullifier set (aborting if they are
already present), checking that the Merkle roots used are valid past roots
(aborting otherwise), and updating the past roots set
2. The above additional checks for the guaranteed phase are performed, if
   applicable
3. For each contract call in sequence, the transcript relevant to this
   execution phase is applied
   1. The contract's current state is loaded
   2. The context is set up from the transaction
   3. The [Impact](./impact.mdx) program is executed against the context, an empty
      effects set, the transcript program, and the declared gas limit, in
      verification mode
   4. The resulting effects are tested to be equal to the declared effects
   5. The resulting state is stored as the contract's state, iff it is "strong".

[^1] This would permit invalidating any fallible section by merging with an
invalid spend otherwise.
</file>

<file path="docs/develop/how-midnight-works/smart-contracts.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---
import CodeBlock from '@theme/CodeBlock';
import PrivateExample from './_private_example.mdx';
import CircuitExample from './_circuit_example.mdx';
import LedgerExample from './_ledger_example.mdx';
import PrivateAssignments from './_private_assignments.mdx';
import CircuitConstraints from './_circuit_constraints.mdx';
import LedgerAssignments from './_ledger_assignments.mdx';

# Smart contracts on Midnight

While you may have some familiarity with smart
contracts, designing smart contracts for data protection provides unique
challenges and perspectives. This article will therefore briefly walk through key points
in which Midnight differs from more public smart contract solutions and how
this should inform your construction of contracts in Midnight.

## Replicated state machines

All blockchain systems are replicated state machines at their core: They keep a
*ledger state*, which is modified by *transactions*. Various blockchains
differ in which transactions are considered valid and what effect they have on
a ledger state.

Smart-contract-enabled blockchains allow transactions to program parts of the
blockchain's validity criteria that subsequent transactions have to satisfy.
The focus here is on the *account model*, where contracts are *deployed* by a
transaction, which assigns a unique address to the contract in the blockchain.
This contract can define the validation criteria and state transitions for the
transactions that interact with it.

The following example illustrates these ideas.  Imagine a contract to
support a guessing game, in which the player guesses factors of a
number, stored in the contract's state.  Making a correct guess allows
the player to set the next number for the opposing player(s).  Thus,
when making a guess, the player offers two factors for the current
number and two factors to define the new number.  The logic of a guess
is expressed in pseudocode as follows:

:::note

This is pseudocode, not a functional Compact program.

:::

```python
def guess_number(guess_a, guess_b, new_a, new_b):
  assert(guess_a != 1 and guess_b != 1 and new_a != 1 and new_b != 1,
    "1 is too boring a factor")
  assert(guess_a * guess_b == number,
    "Guessed factors must be correct")
  number = new_a * new_b
```

The contract *could* just let the player provide the new number
directly, instead of its factors, but then they
could (whether by accident or intentionally) also spoil the fun by passing in a
prime number.  Forcing the player to provide 'interesting' factors
eliminates this possibility.

When the contract is deployed, this program is put directly on-chain, typically
in a compressed, bytecode form, along with an initial state of the contract.
Conceptually, this may make the ledger's state look something like this:

```yaml
contracts:
  "<contract address>":
    state:
      number: 35
    entryPoints:
      guess_number: |
        def guess_number(...):
          // ...
```

A transaction can then call this contract by supplying inputs to the function,
for instance:

```yaml
transaction:
  type: "call"
  address: "<contract address>"
  entryPoint: "guess_number"
  inputs: [5, 7, 2, 6]
```

When processed, nodes process this by:
- looking up the `state` at `<contract address>` as well as the program at
  `<contract address>` and `guess_number`
- running the program against the state, and `inputs`
- if the program succeeds, storing the new `state`.

## Midnight contracts, conceptually

You may have noticed that the above program is not a good
implementation for this game, because every time a new number is set, its factors are 
publicly visible as part of the transaction that sets it. Anyone who really
wants to win can read off the factors and use them as their own
'guess'. Where's the sport in that?

To move beyond this problem, imagine that you don't have to worry
about the blockchain and how it processes transactions. Instead, consider
a contract as an interactive program that can interact with the contract's
on-chain state, as well as call arbitrary code on the user's local machine.

In this setting, it's possible to rewrite the above pseudocode program to look something like this:

```python
def guess_number():
  (a, b) = local.guess_factors(number)
  assert(a != 1 and b != 1, "1 is too boring a factor")
  assert(a * b == number, "Guessed factors must be correct")
  (a, b) = local.new_challenge()
  assert(a != 1 and b != 1, "1 is too boring a factor")
  number = a * b
```

While this program is longer than the one in the previous section, it is also
doing slightly more. It tells us where the numbers come from: local calls to
`guess_factors` or `new_challenge` respectively. Often this is what happens
anyway, with transaction inputs needing to be carefully computed ahead of time
to ensure that the corresponding transaction succeeds. Here, the API is clear,
and the `guess_factors` routine is even given the number for which it should
guess (which previously you'd have to figure out for yourself).

On the chain, this interaction would have the following interactions:
- retrieving `number` ledger field
- setting `number` ledger field.

Neither of these reveals the details of the factors - neither the ones guessed,
nor the ones the new challenge consists of.

A practical challenge with this approach is how to ensure that the contract is
correctly used. For the `local` calls, this is an accepted risk; we don't want
to prescribe how `guess_factors` works, for instance, just that it outputs
correct guesses (hence the input validation). For the contract program itself,
we want other users to be convinced that we ran the right program and that the
changes made to the contract's state are sensible.

## Transcripts and ZK Snarks

The key technology that makes everything work is the [ZK Snark](/docs/learn/04-glossary.mdx#zk-snarks).
At their core, ZK Snarks (and more broadly
zero-knowledge proofs) are a way to prove that you know how to assign values to
a number of variables, so that they satisfy some set of clear, mathematical
conditions. Some of these variables are *public*, while most are not.

The above program can be cleanly split into three interacting parts, each
run in a separate environment: The `local` part, the `ledger` part, and the
glue that links the two together and encodes the core program
logic. This 'glue' can be converted into a series of variable
assignments and equations that can be transformed into a ZK Snark,
while the ledger interactions can be converted into a program that
runs on-chain.

Here, in the example of factoring the current state of `35` into `5 *
7` and replacing it with `2 * 6`:

<div>
<div style={{ width: "32%", float: "left", marginRight: "2%" }} class="private">
<PrivateExample />
<div style={{ textAlign: "center", fontSize: "300%", marginBottom: "0.5ex" }}>⇓</div>
<PrivateAssignments />
</div>
<div style={{ width: "32%", float: "left", marginRight: "2%" }}>
<CircuitExample />
<div style={{ textAlign: "center", fontSize: "300%", marginBottom: "0.5ex" }}>⇓</div>
<CircuitConstraints />
</div>
<div style={{ width: "32%", float: "left" }} class="public">
<LedgerExample />
<div style={{ textAlign: "center", fontSize: "300%", marginBottom: "0.5ex" }}>⇓</div>
<LedgerAssignments />
</div>
</div>
<br clear="all" />

More complex programs, with function calls, conditionals,
iterations, and complex primitives such as hash function calls can also be
translated in this way. See the [writing a contract](/docs/develop/reference/compact/writing.mdx) section of this
documentation for a description of the language we use to write these programs.

In the preceding example, it is possible to prove that, for public `n1`, `n2`
and `n3`, we know values of `a1`, `b1`, `a2`, and `b2` for which these
equations hold. This proof does not say that anyone actually ran the above program,
but it _does_ say that the program's rules were followed, which is what a
skeptical user truly cares about.

The sequence of assignments, `n1`, `n2`, and `n3`, and the program that
produces or uses them is referred to as the *public transcript*, and
conversely `a1`, `b1`, `a2`, and `b2` are the *private transcript*.
Public transcripts are encoded as bytecode[^1], and the shape of this bytecode
is directly enforced by the circuit.

Transactions in Midnight then are essentially made up of the public transcript
and a zero-knowledge proof that this transcript is correct. Each transaction is made with
respect to a contract and a specific *circuit*[^2] on that contract. On-chain,
instead of storing the code for `guess_number()`, a cryptographic key used to
verify zero-knowledge proofs *for* `guess_number()` is stored. This
cryptographically encodes and enforces all of the equations listed in the
circuit above.

Broadly, the state looks something like this:

```yaml
contracts:
  "<contract address>":
    state:
      number: 35
    entryPoints:
      guess_number: "<verifier key>"
```

And a transaction made against this state might look something like:

:::note

This is a sketch of a transaction.

:::

```yaml
transaction:
  type: "call"
  address: "<contract address>"
  entryPoint: "guess_number"
  transcript: |
    n1 = 35
    n2 = 35
    n3 = 12
    assert(n1 == number)
    assert(n2 == number)
    number = n3
  proof: "<zero-knowledge proof>"
```

This transaction, when it is verified, will check that the proof is valid with
respect to the verifier key and then *run* the transcript. Here it checks that
things are still as expected; if the current `number` *isn't* `35`
the transaction is no longer valid – whoever made it did not guess the factors of
35, after all. The result of the transaction (if it succeeds) is updating the
state to contain `12` – and importantly, *this* transaction tells no one which 
factors were used there, or in the guess!

A reasonable question is why the `number` check occurs twice, and in practice, this
is a valid observation: There is no need to read the same value multiple times.
However, this way of handling external interactions means that the operations
performed here are arbitrary; the zero-knowledge proof had no knowledge of what
a `read` is or that the values of `n1` and `n2` are necessarily the
same, and this allows the use of more interesting
operations, such as `increment` or `insert`. These are particularly useful to
avoid making transactions invalid due to results not matching, as in the case
of `35` above. Contrast two simultaneous invocations of `increment`
with two simultaneous sequences of `read`ing
a value, adding `1`, and `write`ing it again; the `increment` will (almost) always
succeed, while the read-add-write sequence is prone to failure.

## Putting value at stake

It's not immediately obvious how the notion of *value* fits into this model. In
public blockchains, it's easy for a smart contract to have a value as well as a
state, which can be used to pay into and out of the contract. As this
transfer of value is important to many applications, it is necessary
to achieve such transfers in a setting that preserves data privacy.

The Midnight token currently uses an implementation of
[Zswap](../how-midnight-works/zswap.mdx), which operates similarly to
UTXOs, but shields the token values, types, and fund holders.
An exception to total shielding applies to the funds held by a contract; the value and type
of these are still shielded by default, but holding and releasing them *is*
linked to the contract.

These UTXOs are represented in contracts as individual coins, which are just
data until they are explicitly *received*. Once received, they can be handled
like any other data – whether they are stored publicly, encrypted, or stored privately is
up to the contract itself. When a contract wishes, they can then be *sent* to 
another contract or to a user address.

Coin *receives* and *sends* have special semantics: They are recorded as
operations in the public transcript but have no effect on the contract's state.
Instead, they require a corresponding input or output to be included in the
same transaction, ensuring that a contract doesn't receive funds that don't
exist or send funds it doesn't have.

Again in pseudocode, wagers can be attached to the example:

```python
def guess_number(new_wager):
  (a, b) = local.guess_factors(number)
  builtin.send(wager, local.self())
  assert(a != 1 and b != 1, "1 is too boring a factor")
  assert(a * b == number, "Guessed factors must be correct")
  (a, b) = local.new_challenge()
  assert(a != 1 and b != 1, "1 is too boring a factor")
  number = a * b
  builtin.receive(new_wager)
  wager = new_wager
```

## Factoring and keys

The example of factoring may seem like a toy, and it is somewhat arbitrary,
but it is worth noting that factoring large integers is an important
problem in cryptography. Knowing the factors of large numbers is the basis of
the RSA cryptographic algorithms, and the simple guessing game
corresponds to proving that
you know the secret keys for an RSA public key. This shows the power
of zero-knowledge proofs and that they can serve the same purposes as
signature schemes. Not only can you prove you know a secret key, but you can then
prove that *the same person* did something else, effectively signing what they
did.

In practice, if you want to authenticate, this construction is not the most
efficient; proving the knowledge of a preimage of hash functions (that is,
knowing `sk` such that `pk = H(sk)`) is a simpler alternative in most cases.

----

[^1] For advanced reading of *how* the operations are encoded, see the details
of [Midnight's on-chain VM, Impact](../how-midnight-works/impact.mdx).

[^2] Circuits are named such as the compilation of zero-knowledge proofs has
many similarities with assembling a special-purpose logic circuit
</file>

<file path="docs/develop/how-midnight-works/zswap.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Zswap

:::info

The details of Midnight's native currency implementation are not yet stable and will
undergo further revisions. The performance of basic operations has not been
optimized at this time.

:::

Zswap[^1] is a shielded token mechanism, based on Zerocash[^2], extended
with *native token support* and *atomic swaps*. Zswap's basic component is
an [offer](#offers), which conceptually is a set of [inputs](#inputs) and
[outputs](#outputs). In this matter, it matches the UTXO model, although the
set of unspent transactions itself is not computable due to the inability to
link matching inputs and outputs, a property inherited from Zerocash.

This section describes a slight variation of Zswap used in Midnight that
permits contracts to hold funds.

## Offers

A Zswap offer consists of four elements:

- a set of [input](#inputs) coins (also called 'spends')
- a set of [output](#outputs) coins
- a set of transient coins
- a balance vector.

Transient coins are coins that are both created and spent in the same
transaction. This may seem superfluous, but it extends the ability for
contracts to manage coins. Conceptually, this is an [output](#outputs)
immediately followed by an [input](#inputs), with the sole distinction that the
input spends from a locally created coin commitment set, as opposed to the
global one, to prevent index collisions.

The balance vector is a vector of the total value of this offer. Its
dimensions are all possible [token types](#token-types), with each dimension
carrying its own value. An input of a given type counts positively towards this
vector and negatively towards an output. A balance vector is considered *balanced* if,
for all dimensions, it is non-negative. Typically, it is *adjusted* before
checking for balance, to account for token mints and fee deductions.

### Outputs

A Zswap output creates a new coin and places a corresponding *commitment* in a
global Merkle tree. It consists of:

- the commitment itself
- a multi-base Pedersen commitment to the type/value vector
- an optional contract address, iff (if and only if) this output is targeted at a contract
- an optional ciphertext, if the output is toward a user that must receive it
- a zero-knowledge proof that the former are correct with respect to each other.

Outputs are valid if their zero-knowledge proof is verified.

### Inputs

A Zswap input spends an existing coin, by referencing (without revealing) its
original commitment in the global Merkle tree and producing a corresponding
(but unlinkable) *nullifier*. It consists of:

- the nullifier itself
- a multi-base Pedersen commitment to the type/value vector
- an optional contract address, iff the output is targeted at a contract
- a Merkle tree of a tree containing the commitment corresponding to the nullifier
- a zero-knowledge proof that the former are correct with respect to each other.

Inputs are valid iff the zero-knowledge proof verifies *and* the Merkle tree
root is in the set of past roots.

### Token types

A token type in Midnight is a 256-bit collision-resistant hash output or the
pre-defined zero value, which represents the native token. Users can issue their own tokens
from contracts, with these token types being derived as a hash of the
contract's address and a domain-separator given by the user.

[^1] Engelmann, F., Kerber, T., Kohlweiss, M., & Volkhov, M. 2022. Zswap: zk-SNARK based non-interactive multi-asset swaps. *Proceedings on Privacy Enhancing Technologies (PoPETs)* 4 (2022), 507-527. <tt>https://eprint.iacr.org/2022/1002.pdf</tt>

[^2] Ben-Sasson, E., Chiesa, A. Garman, C., Green, M., Miers, I., Tromer, E., & Virza, M. 2014. Zerocash: Decentralized Anonymous Payments from Bitcoin. *2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014*, 459-474. <tt>https://eprint.iacr.org/2014/349.pdf</tt>
</file>

<file path="docs/develop/how-to/acquire-tokens.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Acquire tokens"
---

# Token acquisition

In the production Midnight network, to run a DApp you need
to hold some DUST in a persistent wallet and spend some of it on each
transaction.  On the testnet, however, a supply of free tDUST is
available for developers who want to experiment with Midnight DApps.

## Get tDUST

1. Copy your receiving address from your Lace wallet.

  :::note Bech32m Address Format
  All wallet addresses are shown in Bech32m format by default. The faucet supports both formats, however the legacy (HEX) format will be dropped in future versions.
  :::

2. Visit the [Midnight testnet faucet ](https://midnight.network/test-faucet/) and enter your wallet address.
3. Select **Request tokens**. This may take a few seconds to process and returns something similar to the following:

`Transaction submitted. Its ID is 1644b988ac71dc6bd6...`

4. You should have received 1000.0 tDUST from the faucet.
</file>

<file path="docs/develop/how-to/fix-version-mismatch-errors.mdx">
---
title: Fix version mismatch errors
description: Resolve version compatibility issues between Midnight compiler, runtime, and other components using the official compatibility matrix.
sidebar_label: Fix version mismatches
sidebar_position: 4
tags: [troubleshooting, version, compatibility, errors]
slug: /how-to/fix-version-mismatches
toc_max_heading_level: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Step, { StepsProvider } from "@site/src/components/Step/Step";

# Fix version mismatch errors

Learn how to resolve version compatibility issues between Midnight components that cause build failures and runtime errors.

## Understanding version mismatches

Midnight consists of multiple components that must work together in compatible versions:

- **Compact compiler**
- **Runtime libraries** (`@midnight-ntwrk/compact-runtime`, `@midnight-ntwrk/ledger`, etc.)
- **Proof server**
- **Indexer** (if used)

When these components are out of sync, you may encounter build errors, deployment failures, or runtime issues.

:::info Check the compatibility matrix
Always refer to the official [release compatibility matrix](/relnotes/support-matrix) to verify which versions work together.
:::

## Check your current versions

Identify which components need updating.

<StepsProvider>

<Step>

### Check the compiler version

```bash
compact --version
```

Compare the output with the [compatibility matrix](/relnotes/support-matrix).

</Step>

<Step>

### Check runtime package versions

```bash
npm list @midnight-ntwrk/compact-runtime
npm list @midnight-ntwrk/ledger
npm list @midnight-ntwrk/zswap
```

All runtime packages should use the same version number.

</Step>

<Step>

### Check proof server version

If running the proof server using Docker:

```bash
docker ps | grep proof-server
docker logs [proof-server-container-id] | head -20
```

Look for version information in the startup logs.

</Step>

<Step>

### Compare versions with the compatibility matrix

Review the [release compatibility matrix](/relnotes/support-matrix) and verify your versions are compatible.

All components show compatible versions according to the official matrix.

</Step>

</StepsProvider>

## Align component versions

Update components to compatible versions using the official compatibility matrix.

<StepsProvider>

<Step>

### Consult the compatibility matrix

Review the [release compatibility matrix](/relnotes/support-matrix) to find compatible versions for:

- Compact compiler
- Runtime packages
- Proof server
- Indexer (if used)

</Step>

<Step>

### Update runtime packages

Update your `package.json` with compatible versions from the matrix:

```json title="package.json"
{
  "dependencies": {
    "@midnight-ntwrk/compact-runtime": "x.x.x",
    "@midnight-ntwrk/ledger": "x.x.x",
    "@midnight-ntwrk/zswap": "x.x.x",
    "@midnight-ntwrk/wallet": "x.x.x"
  }
}
```

Install the updated packages:

```bash
npm install
```

</Step>

<Step>

### Update proof server

If using Docker, update your container image to a compatible version:

```bash
# Stop current container
docker-compose down

# Update docker-compose.yml with compatible version
# Then restart
docker-compose up -d
```

</Step>

<Step>

### Update the compiler

Download and install the compatible compiler version from the [Compact releases](https://github.com/midnightntwrk/compact/releases).

Verify installation:

```bash
compact --version
```

</Step>

<Step>

### Recompile contracts

After updating components, recompile your smart contracts:

```bash
# Clean old artifacts
rm -rf contract/*.cjs contract/*.prover contract/*.verifier

# Recompile using direct compact command
compact compile src/contract.compact contract/
```

</Step>

</StepsProvider>

:::warning Keep components in sync
When updating any component, check the compatibility matrix and update all related components together to maintain compatibility.
:::

## Lock exact versions

Prevent automatic version updates that could break compatibility.

<StepsProvider>

<Step>

### Use exact version numbers

In your `package.json`, specify exact versions without range operators:

```json title="package.json"
{
  "dependencies": {
    "@midnight-ntwrk/compact-runtime": "x.x.x",
    "@midnight-ntwrk/ledger": "x.x.x"
  }
}
```

:::caution Avoid version ranges
Don't use `^x.x.x` or `~x.x.x`. Always specify exact versions like `x.x.x` to prevent unexpected updates.
:::

</Step>

<Step>

### Use npm ci for installations

Use `npm ci` instead of `npm install` for reproducible builds:

```bash
# Clean install from lock file
rm -rf node_modules
npm ci
```

This installs exact versions from `package-lock.json`.

</Step>

<Step>

### Document your versions

Create a `VERSIONS.md` file documenting your component versions:

```markdown title="VERSIONS.md"
# Component Versions

Last verified: 2025-10-17

## Versions in Use

- Compact compiler: x.x.x
- Runtime packages: x.x.x
- Proof server: x.x.x
- Node.js: xx.x.x

## Compatibility Reference

See: /relnotes/support-matrix
```

</Step>

</StepsProvider>

## Platform-specific considerations

<Tabs>
<TabItem value="linux" label="Linux">

Ensure all components are properly installed and accessible:

```bash
# Check compiler location
which compact

# Verify Node.js version
node --version
```

</TabItem>
<TabItem value="mac" label="macOS">

For Apple Silicon (M1/M2), ensure Docker images use the correct architecture:

```bash
# Check Docker architecture
docker info | grep Architecture
```

</TabItem>
<TabItem value="windows" label="Windows/WSL">

Use WSL-native paths for consistency:

```bash
# Use native WSL paths
cd /home/username/project  # Not /mnt/c/...

# Verify compiler access
compact --version
```

</TabItem>
</Tabs>

## Create a version check script

Automate version checking with this script:

```bash title="check-versions.sh"
#!/bin/bash

echo "=== Midnight Version Check ==="
echo ""

echo "Compiler:"
compact --version || echo "❌ Compiler not found"
echo ""

echo "Runtime packages:"
npm list --depth=0 | grep @midnight-ntwrk || echo "❌ No Midnight packages found"
echo ""

echo "Node.js:"
node --version
echo ""

echo "⚠️  Compare these versions with:"
echo "/relnotes/support-matrix"
```

Run the check:

```bash
chmod +x check-versions.sh
./check-versions.sh
```

## Backup before upgrading

Always backup your project before upgrading components:

```bash
# Back up package.json
cp package.json package.json.backup

# Back up contract artifacts
cp -r contract contract-backup

# Commit current state to git
git add -A
git commit -m "Backup before version upgrade"
```

## Verify after updates

After aligning versions, confirm everything works:

```bash
# Test compilation
compact compile src/contract.compact contract/

# Run tests
npm test

# Check for errors
docker logs [proof-server-container-id]
```

## Common mistakes to avoid

:::caution

- **Don't mix version ranges** - Use exact versions only
- **Don't update one component** - Update all related components together
- **Don't skip the compatibility matrix** - Always verify compatibility first
- **Don't forget to recompile** - Recompile contracts after compiler updates
  :::

## Get help

If version issues persist:

1. **Check the compatibility matrix**: [Release compatibility matrix](/relnotes/support-matrix)
2. **Review release notes**: Check for breaking changes in component updates
3. **Ask for help**: Post in #developer-support on Discord with your version details

:::tip Related guides

## Install Development Tools

- [Installation guide](/getting-started/installation) - Comprehensive setup guide covering the Lace wallet, test tokens, Compact compiler, and proof server installation

- [Build a DApp tutorial](/develop/tutorial/building/) - Detailed instructions for building your first DApp with the Compact developer tools

- [Using Midnight tutorial](/develop/tutorial/using/) - Prerequisites and setup instructions for connecting to the Midnight network

## Configure Your Environment

- [Development Environment for Writing and Deploying Midnight Applications](/academy/module-5#development-environment-for-writing-and-deploying-midnight-applications) - Step-by-step environment setup including Docker, Chrome browser, Lace wallet, and proof server configuration

- [Environment Setup and First Contract](/academy/module-6#environment-setup-and-first-contract) - Foundational steps for configuring your development environment with all necessary tools

## Reference

- [Release compatibility matrix](/relnotes/support-matrix) - Official version compatibility reference for all Midnight components

These guides cover everything from basic prerequisites to advanced version management for maintaining a stable development environment.

:::
</file>

<file path="docs/develop/how-to/lace-wallet.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Set up the Lace wallet"
---

# Lace wallet

The Lace wallet is a Chrome extension.

:::important Chrome browser

You must use the Chrome web browser or its derivatives to complete
web-based transactions on the Midnight testnet.

Only the Chrome browser itself is fully supported. The Lace
wallet may not be able to connect to your local proof server from
Chrome derivatives. If you choose to use Brave, for example, it is
necessary to disable Brave shields when running this tutorial's
welcome DApp, so that the DApp (hosted at one address) can contact
your local proof server (hosted on your system, at a different
address) through the Lace extension.

:::

## Install Lace wallet

1. Go to the [Lace wallet](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg).
2. Install the extension.

You may want to go to the Lace wallet extension's detailed settings
and enable the toggle-switch labeled **Pin to toolbar**, so that the
wallet is easily accessible.

## Set up Lace wallet

1. Start the extension, either by clicking its icon on the web
   browser's toolbar (if you pinned it there after the preceding
   steps) or by clicking on it in the list of extensions under the
   extensions icon in your browser's toolbar.
2. The first page you see presents the options of creating a new
   wallet or restoring an existing one.
   ![new Lace wallet](/img/midnight-lace/lace-create-restore.png)
   At this point, create a new wallet.
3. Read and accept the 'Lace Terms of Use'.
   ![Lace Terms of Use](/img/midnight-lace/lace-terms.png)
4. Give your wallet a name to help you identify it later, maybe a name
   like _Midnight testnet_.
   ![Lace wallet name](/img/midnight-lace/lace-wallet-name.png)
5. Choose and save a strong password for your wallet. Please make sure to keep your password in a safe place. No one will have
access to or the ability to retrieve or recover your password.
If you lose your password, you will need to restore your wallet with your secret passphrase.
6. In the next step, the wallet asks for the network addresses and
   ports of the three client service components it needs:

   - the Midnight network you are going to connect to. If you're connecting to our testnet, choose the "Testnet" option. If you're running a local version of midnight testnet, choose the "Undeployed" option.
   - the Midnight network node through which transactions are to be
     submitted
   - the Midnight Indexer of the blockchain, which
     transmits ledger updates to the wallet
   - the proof server, which generates zero-knowledge proofs of the
     validity of your Midnight transactions


   ![Lace server configuration](/img/midnight-lace/lace-server-config.png)

:::important
   Notice that the default proof server address points to a local instance
   that you have installed. This is because the proof server requires
   private data as inputs, and using a remote instance could compromise
   users' private data.
:::

7. Fill in all the words for a secret passphrase, which may
   be needed to restore your wallet in the future.
   _Do not lose this passphrase! Please write down and keep your passphrase in a safe place. No one will have access to or the ability to retrieve or recover your passphrase. If you lose your passphrase, you will not be able to restore your wallet._
   ![Lace secret passphrase](/img/midnight-lace/lace-passphrase.png)

8. After you have verified your passphrase, a page confirming that you
   have completed the setup is displayed.
   ![Lace setup complete](/img/midnight-lace/lace-done.png)

Then the main page for your new wallet appears, with 0.00 tDUST as its
initial balance. You can access this view at any time by clicking on the Lace wallet extension icon again.

Before your wallet has received any tDUST, the main page displays the
wallet address, so that you can copy it into some place that can
transfer funds to the wallet.


Later, you can access the wallet address at any time by clicking **Receive** at the top of the
page.
![Lace receive](/img/midnight-lace/lace-receive.png)
</file>

<file path="docs/develop/how-to/nextjs-wallet-connect.mdx">
---
title: Create a NextJs wallet connector
description: Learn how to create a NextJs application that connects to a wallet using the Midnight DApp Connector API.
sidebar_position: 3
sidebar_label: Create a NextJs wallet connector
tags: [wallet, NextJs, tutorial]
slug: /how-to/nextjs-wallet-connect
toc_max_heading_level: 2
---

import Step, { StepsProvider } from "@site/src/components/Step/Step";

# Set up a wallet connect button

A wallet connect button is required for actions such as initiating transfers or interacting with smart contracts like lending protocols. 

You can add a wallet connect button in a Next.js app using the Midnight dapp connector API and the Lace wallet.
	
Establishing a connection enables secure account access and transaction prompts from the browser.

:::warning
- Midnight Network works on Mac or Linux system.
- [Lace Wallet](https://chromewebstore.google.com/detail/lace-midnight-preview/hgeekaiplokcnmakghbdfbgnlfheichg) must be installed in Chrome
:::

Start from a new Next.js project.

Learn more about the framework in the [documentation](https://nextjs.org/).


# Create a wallet connect component

<div align="center">
```mermaid
graph TD;
    A[User lands on the page.] --> B[User decides to connect their account.]
    B --> C[User clicks the button. A modal from the wallet appears.]
    C --> D[User clicks Approve.]
    D --> E[Wallet connects and the button updates to show success.]
```
</div>

## Run the UI

<StepsProvider>
    <Step>Start the development server. Run npm run dev at the root of the project.</Step>
    <Step>The website  appears in the browser at http://localhost:3000/</Step>
</StepsProvider>

## Create the component

<StepsProvider>
    <Step>Install the DApp connector api package to access the wallet’s state, and wallet interactions. Run: `npm install @midnight-ntwrk/dapp-connector-api`</Step>
    <Step>Create the components folder in the app folder.</Step>
    <Step>Create a component named `ConnectWalletButton.tsx`</Step>
    <Step>Implement a basic button with minimal styling that prompts your Lace wallet to connect to your application.</Step>

```ts
"use client"; // Next.js directive for client-side rendering
import "@midnight-ntwrk/dapp-connector-api"; // Import Midnight wallet connector

export default function ConnectWalletButton() {

    const handleClick = async () => {
        try {
            const api = await window.midnight.mnLace.enable(); // Prompt Lace wallet to connect
        } catch (error) {
            console.log("failed to connect", error); // Log errors
        }
    };

    return (
        <nav className="flex items-center w-full">
            <div className="mx-2 flex gap-4" /> {/* Spacer */}
            <button
                type="button"
                onClick={handleClick} // Call connect handler
                className="ml-auto m-2 px-2 py-1 rounded-2xl bg-black text-white"
            >
Connect Wallet 
            </button>
        </nav>
    );
}
```
</StepsProvider>

To use a different wallet, replace `mnLace` with that wallet’s namespace exposed on window.midnight.

For more information on the Dapp Connector API, see the [documentation](https://docs.midnight.network/develop/reference/midnight-api/dapp-connector/).

## View the component

<StepsProvider>
    <Step>In layout.tsx, import the ConnectWalletButton component: `import ConnectWalletButton from "./components/ConnectWalletButton";`</Step>
    <Step>Render it near the top of the layout body: `<ConnectWalletButton />`</Step>
    <Step>Refresh the browser. The Connect Wallet button is displayed in the top right corner of the screen.</Step>
</StepsProvider>

## Connect the wallet

<StepsProvider>
    <Step>Click Connect Wallet.</Step>
    <Step>A Lace connection modal appears. Click Authorize.</Step>
    <Step>Choose Always  or Only once, to select your preferred access.</Step>
</StepsProvider>

The wallet is now connected to the website.

## Verify wallet connection in wallet

<StepsProvider>
    <Step>Open the Lace wallet extension.</Step>
    <Step>Click the desired Lace wallet in the top right corner of the site and click  Settings.</Step>
    <Step>Click Authorized DApps.</Step>
    <Step>If the wallet is connected to the website, http://localhost:3000 appears in the authorized DApps panel.</Step>
</StepsProvider>

The Lace wallet is now connected to the website and can be prompted to process transactions, and read personal data.

## Manage state

Reloading an entire page to reflect that a wallet is connected is inefficient. The connection status can instead be reflected directly in the button component by managing its state. The button should display “Connect Wallet” before authorization, and switch to “Connected” once the wallet is successfully enabled.

This is done by using React’s `useState` hook. The essential pieces look like this:
```ts
// Import the React Hook that tracks state inside the component
import { useState } from "react";

// Declare a new state variable to track connection status
const [connected, setConnected] = useState(false);

// If the wallet connection succeeded, update the state to "connected"
if (api) setConnected(true);

// Display "Connected" if the state is true, otherwise show "Connect Wallet"
{connected ? "Connected" : "Connect Wallet"}
```

All of these lines are part of the button component. The complete example is included below to show how they fit together.

```ts
import { useState } from "react"; // React hook for state

export default function ConnectWalletButton() {
    const [connected, setConnected] = useState(false); // Track wallet connection status
    const handleClick = async () => {
        try {
            const api = await window.midnight.mnLace.enable(); // Prompt Lace wallet to connect
            if (api) setConnected(true); // Update state if connection succeeds
        } catch (error) {
            console.log("an error occurred", error); // Log errors
        }
    };

    return (
        <nav className="flex items-center w-full">
            <div className="mx-2 flex gap-4" /> {/* Spacer */}
            <button
                type="button"
                onClick={handleClick} // Call connect handler
                className="ml-auto m-2 px-2 py-1 rounded-2xl bg-black text-white"
            >
                {connected ? "Connected" : "Connect Wallet"} {/* Change text based on state */}
            </button>
        </nav>
    );
}

```

Navigate to the browser and connect a wallet if not connected. The button will update to show Connected. Now the application will update the UI when a user connects.
</file>

<file path="docs/develop/how-to/react-wallet-connect.mdx">
---
title: Create a React wallet connector
description: Learn how to create a React application that connects to a wallet using the Midnight DApp Connector API.
sidebar_position: 3
sidebar_label: Create a React wallet connector
tags: [wallet, react, tutorial]
slug: /how-to/react-wallet-connect
toc_max_heading_level: 2
---

import Step, { StepsProvider } from "@site/src/components/Step/Step";

# Build a React wallet connector

Create a React application that connects to a wallet using the Midnight DApp Connector API.

The following code examples intentionally omit CSS and visual styling to keep the examples focused and easy to read. The actual [example app code](https://github.com/bochaco/react-mn-wallet-connect) includes full styling (Tailwind classes and additional CSS) so the components are displayed with a polished, user-friendly appearance.

Also, the code is framework-agnostic and can be used with any React framework. You can use these components and logic in projects created with Vite, Create React App, Next.js, Remix, Gatsby, or custom setups. You might only need to edit the entry file (for example `src/main.tsx vs src/index.tsx`), routing, or build configuration to match your chosen scaffold.

## Prerequisites
The following is required:

- Familiarity with TypeScript/JavaScript
- Basic understanding of React
- [Midnight Lace wallet extension](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg) installed in your browser.

After using this tutorial, you should:

- Understand basic Midnight wallet connection flow
- Know how to use @midnight-ntwrk/dapp-connector-api
- Have working starter code to build your own applications

<StepsProvider>
<Step>

**Define TypeScript Interfaces**

Let's first define a interface for the props passed between the component we are going to create. Their main purpose is to provide type safety and clear contracts for components. WalletCard describes the connection state and callbacks used by the app to trigger connect/disconnect actions.

The actual implementation of the interfaces shown below can be found in the example app at [src/types.ts](https://github.com/bochaco/react-mn-wallet-connect/blob/main/src/types.ts).

```typescript
export interface WalletCardProps {
  isConnected: boolean;
  walletAddress: string | null;
  onConnect: () => void;
  onDisconnect: () => void;
}
```

</Step>
<Step>

**Create the WalletCard Component**

The `WalletCard` aggregates UI and actions related to the wallet connection: it shows status, displays the address when available, and exposes connect/disconnect actions via the Button component. 

Its main role in the app is to be the single visible component that reflects the wallet connection state and triggers the logic handled by the `App` component we'll define afterwards.

The `WalletCard` component as implemented in the example app can be found at [src/WalletCard.tsx](https://github.com/bochaco/react-mn-wallet-connect/blob/main/src/WalletCard.tsx).

```typescript
import React from "react";
import type { WalletCardProps } from "./types";

const WalletCard: React.FC<WalletCardProps> = ({
  isConnected,
  walletAddress,
  onConnect,
  onDisconnect,
}) => {
  return (
    <div>
      <div>
        <h2>Connection Status</h2>
        <div className={isConnected ? "text-green-400" : "text-red-400"}>
          {isConnected ? "Connected" : "Disconnected"}
        </div>
      </div>

      <div>
        {isConnected && walletAddress ? (
          <>
            <p>Wallet Address:</p>
            <p title={walletAddress}>{walletAddress}</p>
          </>
        ) : (
          <p>Please connect your wallet to proceed.</p>
        )}
      </div>

      <div>
        {isConnected ? (
          <button onClick={onDisconnect}>Disconnect Wallet</button>
        ) : (
          <button onClick={onConnect}>Connect Wallet</button>
        )}
      </div>
    </div>
  );
};
```

</Step>
<Step>

**Create Main App Component**

We need one last component, the `App` component, which manages state and business logic: it holds connection state and the current wallet address, and provides callbacks to child components to change that state. 

To begin with, the connect handler is a stub producing a dummy wallet address; later on we will call the Midnight DApp Connector. `App` wires UI (WalletCard) to the connector logic and is the central coordinator for the application.

The `App` component shown below is implemented in the example app at [src/App.tsx](https://github.com/bochaco/react-mn-wallet-connect/blob/main/src/App.tsx).

```typescript
import React, { useState } from 'react';
import WalletCard from './WalletCard';

const App: React.FC = () => {
  const [isConnected, setIsConnected] = useState<boolean>(false);
  const [walletAddress, setWalletAddress] = useState<string | null>(null);

  const handleConnect = () => {
    // We will replace this to actually use the Midnight DApp connector API.
    const fakeAddress = `0x${Array(40).fill(0).join("")}`;
    setWalletAddress(fakeAddress);
    setIsConnected(true);
  };

  const handleDisconnect = () => {
    setWalletAddress(null);
    setIsConnected(false);
  };

  return (
    <div>
      <header>
        <h1>Midnight Wallet Connector</h1>
      </header>
      <main>
        <WalletCard
          isConnected={isConnected}
          walletAddress={walletAddress}
          onConnect={handleConnect}
          onDisconnect={handleDisconnect}
        />
      </main>
    </div>
  );
};
```

</Step>
<Step>

**Create Entry Point**

At this point we are ready to bootstrap the React application into the DOM. We can now mount the `App` component and ensure React runs in StrictMode during development.

In the implemented example it also pulls in Tailwind-generated CSS so the UI renders with the intended styling, this can be found at [src/main.tsx](https://github.com/bochaco/react-mn-wallet-connect/blob/main/src/main.tsx).

```typescript
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

Lastly, we create the HTML file providing the hosting page for the single-page app and links the global stylesheet. The HTML used by the example app is available at [index.html](https://github.com/bochaco/react-mn-wallet-connect/blob/main/index.html).

```html
<!doctype html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/index.css">
    <title>React Midnight Wallet Connector</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

Your application should now be displaying a dummy address, so now we are ready to add the last piece to integrate it with the Midnight DApp Connector, to retrieve the actual wallet's address.

</Step>
<Step>

**Integrate Midnight DApp Connector**

Let's now replace `handleConnect` function body in the `App` component with a real implementation using the DApp Connector API.

This code demonstrates how to call the Midnight DApp Connector API to enable the wallet, check whether it's enabled, and retrieve the current wallet state (including the address). With this code, the `WalletCard` displays the real address and connection status:

The DApp connector API should be exposed through the global variable `window.midnight.{walletName}`.

```typescript
const handleConnect = async () => {
  let isConnected = false;
  let address = null;
  try {
    // To authorize a DApp, call the enable() method and wait for 
    // the user to respond to the request.
    const connectorAPI = await window.midnight?.mnLace.enable();

    // Let's now check if the DApp is authorized, using the isEnabled() method
    const isEnabled = await window.midnight?.mnLace.isEnabled();
    if (isEnabled) {
      isConnected = true;
      console.log("Connected to the wallet:", connectorAPI);

      // To get the wallet state, we call the state() API method, that will
      // return the DAppConnectorWalletState object, which is where we can get 
      // the wallet address from.
      const state = await connectorAPI.state();
      address = state.address;
    }
  } catch (error) {
    console.log("An error occurred:", error);
  }

  setIsConnected(isConnected);
  setWalletAddress(address);
};
```

</Step>
</StepsProvider>

Your application should now be running with the Midnight DApp Connector integration, requesting the user to authorise it from the Lace wallet, and displaying the corresponding connection status and wallet address!.

## Next steps

You can consider implementing the following:

- Allowing the user to transfer coins
- Expose a text input for signing messages with the connected wallet
</file>

<file path="docs/develop/how-to/run-proof-server.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Run the proof server"
---

# Proof server

Midnight uses zero-knowledge (ZK) cryptography to enable shielded
transactions and data protection. An essential element of this
architecture is ZK functionality provided by a Midnight *proof
server*, which generates proofs locally that will be verified on-chain. The information that a DApp sends to the proof server includes
private data, such as details of token ownership or a DApp's
private state. To protect your data, you should access only a local
proof server, or perhaps one on a remote machine that you control,
over an encrypted channel.

Run a Midnight proof server on your system in a Docker container. The Lace wallet
Chrome extension (including the wallet) communicates with the proof
server to invoke ZK functionality and generate ZK proofs for your
transactions.

## Install the proof server

1. In the prerequisites from the installation guide, you
installed Docker and verified your access to the [Midnight Testnet docker repo](https://hub.docker.com/u/midnightnetwork).

   - Using the terminal:

      ```shell
      docker search midnightnetwork
      ```

   - Or by searching `midnightnetwork` in the Docker Desktop search bar.

2. To download the Docker image for the Midnight proof server:

   - Via the terminal:

      ```shell
      docker pull midnightnetwork/proof-server:latest
      ```

      If you need to run an older version of the proof-server, Replace `latest` with the required version of the proof server according to the [release compatibility matrix](../../../relnotes/support-matrix).

   - Or by clicking **pull** in the search results of the Docker Desktop.


3. You can verify the download's success by checking that the following
command lists a proof server image.

   - Via the terminal:

      ```shell
      docker images | grep proof-server
      ```
    
   - Or by clicking **>_ Terminal**, clicking **Enable Docker terminal** and running the same command as above.


## Start the proof server

In the terminal, run the proof server with the following command:

```shell
docker run -p 6300:6300 midnightnetwork/proof-server -- 'midnight-proof-server --network testnet'
```

You should see some output indicating that the server has started.

## Stop the proof server

To stop the proof server, simply exit the process you launched with
`docker run`. For example, on most systems, you can type `Ctrl-C` to
stop the process.

**For the next step in this tutorial, the proof server must be
running**, so if you have stopped it, start it again now.

## Your privacy

The proof server exists to protect your privacy.  It does not open any
network connections; it simply listens on its assigned port for
requests from your Chrome extension. One of the lines of output you
may see from the proof server includes this text:

```
Targeting network: TestNet
```

This indicates that the instance you are running is configured
appropriately to generate proofs that are valid on the Midnight
Testnet. It does not indicate a network connection from the proof
server to Testnet.

Please let the DevRel support team know if you have any privacy
concerns regarding the proof server.

## Set up proof server as a systemd service

Optionally for Linux users, you might consider running the proof server as an automatic background process anytime you boot your machine.

1. Create a new file for your systemd service, typically in the `/etc/systemd/system/` directory. For example:

```shell
sudo nano /etc/systemd/system/midnight-proof-server.service
```

2. Add the following contents.

```
[Unit]
Description=Midnight Network Proof Server
After=docker.service
Requires=docker.service

[Service]
ExecStart=/usr/bin/docker run -p 6300:6300 midnightnetwork/proof-server -- 'midnight-proof-server --network testnet'
Restart=always
RestartSec=5

[Install]
WantedBy=default.target
```

Adjust the `Description`, `ExecStart`, and other parameters as needed.

3. Reload systemd manager to apply changes.

```shell
sudo systemctl daemon-reload
```

4. **Start** service.
```
sudo systemctl start midnight-proof-server # start service
```

5. How to **stop** and get **status** of service.

```shell
sudo systemctl enable midnight-proof-server # stop service

sudo systemctl status midnight-proof-server # get status of service
```
</file>

<file path="docs/develop/reference/compact/compact-std-library/exports.md">
# Detailed API reference

## Structs

### `Maybe`

Encapsulates an optionally present value. If `isSome` is `false`, `value`
should be `default<T>` by convention.

```compact
struct Maybe<T> {
  isSome: Boolean;
  value: T;
}
```

### `Either`

Disjoint union of `A` and `B`. Iff `isLeft` if `true`, `left` should be
populated, otherwise `right`. The other should be `default< >` by convention.

```compact
struct Either<A, B> {
  isLeft: Boolean;
  left: A;
  right: B;
}
```

### `CurvePoint`

A point on the proof systems embedded curve, in affine coordinates.

Only outputs of elliptic curve operations are actually guaranteed to lie on the
curve.

```compact
struct CurvePoint {
  x: Field;
  y: Field;
}
```

### `MerkleTreeDigest`

The root hash of a Merkle tree, represented by a single `Field`.

```compact
struct MerkleTreeDigest { field: Field; }
```

### `MerkleTreePathEntry`

An entry in a Merkle tree path, indicating if the path leads left or right, and
the root of the sibling node. Primarily used in [`MerkleTreePath`](#merkletreepath)

```compact
struct MerkleTreePathEntry {
  sibling: MerkleTreeDigest;
  goesLeft: Boolean;
}
```

### `MerkleTreePath`

A path in a depth `n` Merkle tree, leading to a leaf of type `T`.
Primarily used for [`merkleTreePathRoot`](#merkletreepathroot).

This can be constructed from `witness`es that use the compiler output's
`findPathForLeaf` and `pathForLeaf` functions.

```compact
struct MerkleTreePath<#n, T> {
  leaf: T;
  path: Vector<n, MerkleTreePathEntry>;
}
```

### `ContractAddress`

The address of a contract, used as a recipient in [`send`](#send),
[`sendImmediate`](#sendimmediate),
[`createZswapOutput`](#createzswapoutput), and [`mintToken`](#minttoken).

```compact
struct ContractAddress { bytes: Bytes<32>; }
```

### `CoinInfo`

The description of a newly created shielded coin, used in outputting shielded coins, or
spending/receiving shielded coins that originate in the current transaction.

`nonce` can be deterministically derived with [`evolveNonce`](#evolvenonce).

Used in:
- [`receive`](#receive)
- [`sendImmediate`](#sendimmediate)
- [`mergeCoin`](#mergecoin)
- [`mergeCoinImmediate`](#mergecoinimmediate)
- [`createZswapOutput`](#createzswapoutput)

```compact
struct CoinInfo {
  nonce: Bytes<32>;
  color: Bytes<32>;
  value: Uint<128>;
}
```

### `QualifiedCoinInfo`

The description of an existing shielded coin in the ledger, ready to be spent.

Used in:
- [`send`](#send)
- [`mergeCoin`](#mergecoin)
- [`mergeCoinImmediate`](#mergecoinimmediate)
- [`createZswapInput`](#createzswapinput)

```compact
struct QualifiedCoinInfo {
  nonce: Bytes<32>;
  color: Bytes<32>;
  value: Uint<128>;
  mtIndex: Uint<64>;
}
```

### `ZswapCoinPublicKey`

The public key used to output a [`CoinInfo`](#coininfo) to a user, used as a
recipient in [`send`](#send), [`sendImmediate`](#sendimmediate), and
[`createZswapOutput`](#createzswapoutput).

```compact
struct ZswapCoinPublicKey { bytes: Bytes<32>; }
```

### `SendResult`

The output of [`send`](#send) and [`sendImmediate`](#sendimmediate),
detailing the created shielded coin, and the change from spending the input, if
applicable.

```compact
struct SendResult {
  change: Maybe<CoinInfo>;
  sent: CoinInfo;
}
```

## Circuits

### `some`

Constructs a [`Maybe<T>`](#maybe) containing an element of type `T`

```compact
circuit some<T>(value: T): Maybe<T>;
```

### `none`

Constructs a [`Maybe<T>`](#maybe) containing nothing

```compact
circuit none<T>(): Maybe<T>;
```

### `left`

Construct an [`Either<A, B>`](#either) containing the `A` item of the disjoint
union

```compact
circuit left<A, B>(value: A): Either<A, B>;
```

### `right`

Constructs an [`Either<A, B>`](#either) containing the `B` item of the disjoint
union

```compact
circuit right<A, B>(value: B): Either<A, B>;
```

### `transientHash`

Builtin transient hash compression function

This function is a circuit-efficient compression function from arbitrary values
to field elements, which is not guaranteed to persist between upgrades. It
should not be used to derive state data, but can be used for consistency
checks.

Although this function returns a hash of its inputs, it is not considered sufficient
to protect its input from disclosure.
If its input contains any value returned from a witness, the program must acknowledge
disclosure (via a `disclose` wrapper) if the result can be stored in the public ledger,
returned from an exported circuit, or passed to another contract via a cross-contract call.

```compact
circuit transientHash<T>(value: T): Field;
```

### `transientCommit`

Builtin transient commitment function

This function is a circuit-efficient commitment function over arbitrary
types, and a field element commitment opening, to field elements, which is not
guaranteed to persist between upgrades. It should not be used to derive state
data, but can be used for consistency checks.

Unlike `transientHash`, this function is considered sufficient to protect
its input from disclosure, under the assumption that the `rand` argument is
sufficiently random.
Thus, even if its input contains a value or values returned from one or more
witnesses, the program need not acknowledge disclosure (via a `disclose` wrapper) if
the result can be stored in the public ledger, returned from an exported circuit, or
passed to another contract via a cross-contract call.

```compact
circuit transientCommit<T>(value: T, rand: Field): Field;
```

### `persistentHash`

Builtin persistent hash compression function

This function is a non-circuit-optimised compression function from arbitrary values
to a 256-bit bytestring. It is guaranteed to persist between
upgrades, and to consistently use the SHA-256 compression algorithm. It
*should* be used to derive state data, and not for consistency checks where
avoidable.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit persistentHash<T>(value: T): Bytes<32>;
```

### `persistentCommit`

Builtin persistent commitment function

This function is a non-circuit-optimised commitment function from arbitrary
values representable in Compact, and a 256-bit bytestring opening, to a 256-bit
bytestring. It is guaranteed to persist between upgrades, and use the SHA-256
compression algorithm. It *should* be used to derive state data, and not for
consistency checks where avoidable.

The note about disclosing under `transientCommit` also applies to this function.

```compact
circuit persistentCommit<T>(value: T, rand: Bytes<32>): Bytes<32>;
```

### `degradeToTransient`

This function "degrades" the output of a [`persistentHash`](#persistenthash)
or [`persistentCommit`](#persistentcommit) to a field element, which can then
be used in [`transientHash`](#transienthash) or
[`transientCommit`](#transientcommit).

```compact
circuit degradeToTransient(x: Bytes<32>) : Field;
```

### `upgradeFromTransient`
This function "upgrades" a field element to the output of a
[`persistentHash`](#persistenthash) or [`persistentCommit`](#persistentcommit).

```compact
circuit upgradeFromTransient(x: Field): Bytes<32>;

```

### `ecAdd`

This function add two elliptic [`CurvePoint`](#curvepoint)s (in multiplicative
notation)

```compact
circuit ecAdd(a: CurvePoint, b: CurvePoint): CurvePoint;
```

### `ecMul`

This function multiplies an elliptic [`CurvePoint`](#curvepoint) by a scalar
(in multiplicative notation)

```compact
circuit ecMul(a: CurvePoint, b: Field): CurvePoint;
```

### `ecMulGenerator`

This function multiplies the primary group generator of the embedded curve
by a scalar (in multiplicative notation)

```compact
circuit ecMulGenerator(b: Field): CurvePoint;
```

### `hashToCurve`

This function maps arbitrary types to [`CurvePoint`](#curvepoint)s.

Outputs are guaranteed to have unknown discrete logarithm with respect to
the group base, and any other output, but are not guaranteed to be unique (a
given input can be proven correct for multiple outputs).

Inputs of different types `T` may have the same output, if they have the same
field-aligned binary representation.

```compact
circuit hashToCurve<T>(value: T): CurvePoint;
```

### `merkleTreePathRoot`

Derives the Merkle tree root of a [`MerkleTreePath`](#merkletreepath), which
should match the root of the tree that this path originated from.

```compact
circuit merkleTreePathRoot<#n, T>(path: MerkleTreePath<n, T>): MerkleTreeDigest;
```

### `merkleTreePathRootNoLeafHash`

Derives the Merkle tree root of a [`MerkleTreePath`](#merkletreepath), which
should match the root of the tree that this path originated from. As opposed to
[`merkleTreePathRoot`](#merkletreepathroot), this variant assumes that
the tree leaves have already been hashed externally.

```compact
circuit merkleTreePathRootNoLeafHash<#n>(path: MerkleTreePath<n, Bytes<32>>): MerkleTreeDigest;
```

### `nativeToken`

Returns the token type of the native token

```compact
circuit nativeToken(): Bytes<32>;
```

### `tokenType`

Transforms a domain separator for the given contract into a globally namespaced
token type. A contract can issue tokens for its domain separators, which lets
it create new tokens, but due to collision resistance, it cannot mint tokens
for another contract's token type. This is used as the `color` field in 
[`CoinInfo`](#coininfo).

```compact
circuit tokenType(domainSep: Bytes<32>, contract: ContractAddress): Bytes<32>;
```

### `mintToken`

Creates a new shielded coin, minted by this contract, and sends it to the given
recipient. Returns the corresponding [`CoinInfo`](#coininfo). This requires
inputting a unique nonce to function securely, it is left to the user how to
produce this.

```compact
circuit mintToken(
  domainSep: Bytes<32>,
  value: Uint<128>,
  nonce: Bytes<32>,
  recipient: Either<ZswapCoinPublicKey, ContractAddress>
): CoinInfo;
```

### `evolveNonce`

Deterministically derives a [`CoinInfo`](#coininfo) nonce from a counter index,
and a prior nonce.

```compact
circuit evolveNonce(
  index: Uint<64>,
  nonce: Bytes<32>
): Bytes<32>;
```

### `burnAddress`

Returns a payment address that guarantees any shielded coins sent to it are burned.

```compact
circuit burnAddress(): Either<ZswapCoinPublicKey, ContractAddress>;
```

### `receive`

Receives a shielded coin, adding a validation condition requiring this coin to be
present as an output addressed to this contract, and not received by another
call

```compact
circuit receive(coin: CoinInfo): [];
```

### `send`

Sends given value from a shielded coin owned by the contract to a recipient. Any change
is returned and should be managed by the contract.

Note that this does not currently create coin ciphertexts, so sending to a user
public key except for the current user will not lead to this user being
informed of the coin they've been sent.

```compact
circuit send(input: QualifiedCoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): SendResult;
```

### `sendImmediate`

Like [`send`](#send), but for coins created within this transaction

```compact
circuit sendImmediate(input: CoinInfo, target: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>): SendResult;
```

### `mergeCoin`

Takes two coins stored on the ledger, and combines them into one

```compact
circuit mergeCoin(a: QualifiedCoinInfo, b: QualifiedCoinInfo): CoinInfo;
```

### `mergeCoinImmediate`

Takes one coin stored on the ledger, and one created within this transaction,
and combines them into one

```compact
circuit mergeCoinImmediate(a: QualifiedCoinInfo, b: CoinInfo): CoinInfo;
```

### `ownPublicKey`

Returns the [`ZswapCoinPublicKey`](#zswapcoinpublickey) of the end-user
creating this transaction.

```compact
circuit ownPublicKey(): ZswapCoinPublicKey;
```

### `createZswapInput`

Notifies the context to create a new Zswap input originating from this call.
Should typically not be called manually, prefer [`send`](#send) and
[`sendImmediate`](#sendimmediate) instead.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit createZswapInput(coin: QualifiedCoinInfo): [];
```

### `createZswapOutput`

Notifies the context to create a new Zswap output originating from this call.
Should typically not be called manually, prefer [`send`](#send) and
[`sendImmediate`](#sendimmediate), and [`receive`](#receive)instead.

The note about disclosing under `transientHash` also applies to this function.

```compact
circuit createZswapOutput(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): [];
```

### `blockTimeLt`

Returns true if the current block time is less than the given value.

```compact
circuit blockTimeLt(time: Uint<64>): Boolean;
```

### `blockTimeGte`

Returns true if the current block time is greater than or equal to the given value.

```compact
circuit blockTimeGte(time: Uint<64>): Boolean;
```

### `blockTimeGt`

Returns true if the current block time is greater than the given value.

```compact
circuit blockTimeGt(time: Uint<64>): Boolean;
```

### `blockTimeLte`

Returns true if the current block time is less than or equal to the given value.

```compact
circuit blockTimeLte(time: Uint<64>): Boolean;
```
</file>

<file path="docs/develop/reference/compact/compact-std-library/README.md">
# Compact standard library

**CompactStandardLibrary** ∙ [Detailed API reference](exports.md)

This API provides standard types and circuits for use in Compact programs.
Key parts of the API are:

- Common data types:
  - [`Maybe`](exports.md#maybe)
  - [`Either`](exports.md#either)
  - [`CurvePoint`](exports.md#curvepoint)
  - [`MerkleTreeDigest`](exports.md#merkletreedigest)
  - [`MerkleTreePathEntry`](exports.md#merkletreepathentry)
  - [`MerkleTreePath`](exports.md#merkletreepath)
  - [`ContractAddress`](exports.md#contractaddress)
  - [`ZswapCoinPublicKey`](exports.md#zswapcoinpublickey)
- Coin management data types:
  - [`CoinInfo`](exports.md#coininfo)
  - [`QualifiedCoinInfo`](exports.md#qualifiedcoininfo)
  - [`SendResult`](exports.md#sendresult)
- Common functions:
  - [`some`](exports.md#some)
  - [`none`](exports.md#none)
  - [`left`](exports.md#left)
  - [`right`](exports.md#right)
- Hashing functions:
  - [`transientHash`](exports.md#transienthash)
  - [`transientCommit`](exports.md#transientcommit)
  - [`persistentHash`](exports.md#persistenthash)
  - [`persistentCommit`](exports.md#persistentcommit)
  - [`degradeToTransient`](exports.md#degradetotransient)
- Elliptic curve functions:
  - [`ecAdd`](exports.md#ecadd)
  - [`ecMul`](exports.md#ecmul)
  - [`ecMulGenerator`](exports.md#ecmulgenerator)
  - [`hashToCurve`](exports.md#hashtocurve)
  - [`upgradeFromTransient`](exports.md#upgradefromtransient)
- Merkle tree functions:
  - [`merkleTreePathRoot`](exports.md#merkletreepathroot)
  - [`merkleTreePathRootNoLeafHash`](exports.md#merkletreepathrootnoleafhash)
- Coin management functions
  - [`tokenType`](exports.md#tokentype)
  - [`nativeToken`](exports.md#nativetoken)
  - [`ownPublicKey`](exports.md#ownpublickey)
  - [`createZswapInput`](exports.md#createzswapinput)
  - [`createZswapOutput`](exports.md#createzswapoutput)
  - [`mintToken`](exports.md#minttoken)
  - [`evolveNonce`](exports.md#evolvenonce)
  - [`receive`](exports.md#receive)
  - [`send`](exports.md#send)
  - [`sendImmediate`](exports.md#sendimmediate)
  - [`mergeCoin`](exports.md#mergecoin)
  - [`mergeCoinImmediate`](exports.md#mergecoinimmediate)
  - [`burnAddress`](exports.md#burnaddress)
- Block time functions:
  - [`blockTimeLt`](exports.md#blocktimelt)
  - [`blockTimeGte`](exports.md#blocktimegte)
  - [`blockTimeGt`](exports.md#blocktimegt)
  - [`blockTimeLte`](exports.md#blocktimelte)
</file>

<file path="docs/develop/reference/compact/compact-grammar.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Formal grammar

import Iframe from "@site/src/components/IFrame/Iframe";

<Iframe src="/language/compact.html" />
</file>

<file path="docs/develop/reference/compact/explicit_disclosure.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
title: Explicit disclosure
---

# Explicit disclosure in Compact: The Midnight "Witness Protection Program"

## Introduction

Midnight supports the development of applications that preserve privacy whenever possible while allowing selective disclosure of private information as necessary. Selective disclosure differs from traditional blockchains, in which everything is public, or strict privacy-preserving blockchains, in which everything is private. Midnight's selective disclosure allows banks, for example, to disclose data required for regulatory purposes while keeping other account information private.

The decision to disclose private information, including information derived from private information, must rest with each Midnight DApp because disclosure requirements are inherently situation-specific. However, because private information should be disclosed only as necessary, Midnight's Compact language requires disclosure to be explicitly declared. That is, a Compact program must explicitly declare its intention to disclose data that might be private before storing it in the public ledger, returning it from an exported circuit, or passing it to another contract. This makes privacy the default and disclosure an explicit exception, reducing the risk of accidental disclosure.

The contract produced from a Compact program is a zero-knowledge (zk) proof coupled with updates to be made to the public ledger. A zk-proof proves some property about one or more pieces of data, referred to as _witnesses_ or _witness data_, without disclosing anything about the witness data except that the property holds for them. In Compact, witness data comes primarily from external callback functions declared as witnesses in a Compact contract and provided to the contract by a DApp.  Witness data can also come into a contract via exported circuit arguments and via the arguments to the contract constructor, if any.  Also, any value derived from witness data is also considered to be witness data. Because witness data may contain private information, it should ordinarily be used only for constructing the zk-proof and not disclosed in any way, but exceptions sometimes need to be made.  When exceptions are made, the disclosure must be explicitly declared.

## Explicitly declaring disclosure

Explicitly declaring intent to disclose witness data in Compact is straightforward, requiring only the addition of a `disclose()` wrapper around any expression whose value may contain witness data to be disclosed, as illustrated by the following trivial program:

```compact
import CompactStandardLibrary;
witness getBalance(): Bytes<32>;
export ledger balance: Bytes<32>;

export circuit recordRalance(): [] {
  balance = disclose(getBalance());
}
```

Without the `disclose()` wrapper, the compiler rejects the program with an informative error message. For example, attempting to compile this Compact program:

```compact
import CompactStandardLibrary;
witness getBalance(): Bytes<32>;
export ledger balance: Bytes<32>;

export circuit recordBalance(): [] {
  balance = getBalance();    	// missing disclose() wrapper
}
```

causes the compiler to abort with the following error message:

```
Exception: /tmp/q3.compact line 6 char 11:
  potential witness-value disclosure must be declared but is not:
    witness value potentially disclosed:
      the return value of witness getBalance at line 2 char 1
    nature of the disclosure:
      ledger operation might disclose the witness value
    via this path through the program:
      the right-hand side of = at line 6 char 11
```

The error message lists the sources of all witness data disclosed at this point, so the programmer knows that adding a `disclose()` wrapper will declare all of them disclosed.

Placing a `disclose()` wrapper does not cause disclosure in itself; in fact, it has no effect other than telling the compiler that it is okay to disclose the value of the wrapped expression. Equivalently, it tells the compiler to pretend that the value of the wrapped expression does not contain witness data whether it actually does or not.

## Following indirect witness data assignments

In many cases, disclosure is not so direct, yet the requirement to explicitly declare disclosure always holds. For example, obfuscating the disclosure as follows:

```compact
import CompactStandardLibrary;
struct S { x: Field; }
witness getBalance(): Bytes<32>;
export ledger balance: Bytes<32>;

circuit obfuscate(x: Field): Field { // seriously bad obfuscation
  return x + 73;
}

export circuit recordBalance(): [] {
  const s = S { x: getBalance() as Field };
  const x = obfuscate(s.x);
  balance = x as Bytes<32>;
}
```

still causes the compiler to abort, with a similar error message:

```
Exception: /tmp/q3.compact line 13 char 11:
  potential witness-value disclosure must be declared but is not:
    witness value potentially disclosed:
      the return value of witness getBalance at line 3 char 1
    nature of the disclosure:
      ledger operation might disclose the result of an addition involving the witness value
    via this path through the program:
      the binding of s at line 11 char 3
      the argument to obfuscate at line 12 char 13
      the computation at line 7 char 10
      the binding of x at line 12 char 3
      the right-hand side of = at line 13 char 11
```

In this case, the disclosure, if intentional, can be declared by placing a `disclose()` wrapper around the call to `getBalance()`, around the right-hand-side of the `balance` assignment, or anywhere else along the path from the point of call to the point of disclosure. For example, it could be added to the body of the `obfuscate` circuit around the reference to its argument.

```compact
import CompactStandardLibrary;
struct S { x: Field; }
witness getBalance(): Bytes<32>;
export ledger balance: Bytes<32>;

circuit obfuscate(x: Field): Field { // seriously bad obfuscation
  return disclose(x) + 73;
}

export circuit recordBalance(): [] {
  const s = S { x: getBalance() as Field };
  const x = obfuscate(s.x);
  balance = x as Bytes<32>;
}
```

The best practice is most often to put the `disclose()` wrapper as close to the disclosure point as possible to avoid accidental disclosure if the data travels along multiple paths. For a structured value (such as a tuple, vector, or struct), however, the `disclose()` wrapper should be placed only around the portions of the value that are expected to contain witness data to avoid accidental disclosure in the other portions of the value. Also, in the case of a witness that always returns non-private data or private data that has been sufficiently obfuscated via some cryptographically sound mechanism, it makes sense to place the `disclose()` wrapper directly on the call to the witness.

## Indirect disclosure via conditional expression

The preceding example illustrates that subjecting witness data to arithmetic, converting it from one representation to another, and passing it into and out of other circuits does not hide potential disclosure from the compiler. The compiler also detects indirect disclosure via conditional expressions. For example:

```compact
import CompactStandardLibrary;
witness getBalance(): Uint<64>;

export circuit balanceExceeds(n: Uint<64>): Boolean {
  return getBalance() > n;
}
```

causes the compiler to abort with the following message:

```
Exception: /tmp/q3.compact line 5 char 3:
  potential witness-value disclosure must be declared but is not:
    witness value potentially disclosed:
      the return value of witness getBalance at line 2 char 1
    nature of the disclosure:
      the value returned from exported circuit balanceExceeds might disclose the result of a
      comparison involving the witness value
    via this path through the program:
      the comparison at line 5 char 10
```

The message aids the programmer by noting the indirect nature of the disclosure. This example also illustrates that disclosure does not occur just when witness data is stored in the ledger but also when returned from an exported circuit.

## Safe Compact standard library routines

The compiler recognizes that certain Compact standard library routines sufficiently disguise witness data so that explicit declaration of disclosure is not required. For an expression `e` whose value contains witness data, the compiler will treat `transientCommit(e)` as if it does not contain witness data, while it will treat `transientHash(e)` as if it does.

## How explicit disclosure is implemented

We refer to the portion of the compiler that detects and reports undeclared disclosure of witness data as the "witness protection program". The witness-protection program is implemented as an _abstract interpreter_, where the abstract values are not actual run-time values but information about witness data that will be contained within the actual run-time values.

The abstract interpreter evaluates the program as if the abstract values were actual values. The operations performed by the interpreter are modified, however, to propagate (or not) information about witness data from the operation inputs to the operation outputs. If at some point the interpreter encounters an undeclared disclosure, e.g., a ledger store, of an abstract value containing witness data, the compiler halts and produces an appropriate error message.

## Conclusion

The `disclose()` wrapper in Compact enforces deliberate programming decisions when dealing with potentially sensitive private witness data and data derived from private information. Explicit disclosure requires Compact program assignments to declare an intention to use data that might be private before storing it in the public ledger, returning it from an exported circuit, or passing it to another contract. This makes privacy the default and disclosure an explicit exception, reducing the risk of accidental disclosure.
</file>

<file path="docs/develop/reference/compact/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# The Compact language

At this point, you should have already seen Compact, our smart contract
programming language, in action in [the tutorial](/docs/develop/tutorial/index.mdx) and some
usage hints in [the 'how Midnight works'](/docs/develop/how-midnight-works/index.mdx) sections.

This section will provide a more in-depth breakdown of what makes up a Compact
smart contract, starting with
[a walkthrough of the main parts of a Compact program](/docs/develop/reference/compact/writing.mdx),
followed by [a reference for the Compact language](/docs/develop/reference/compact/lang-ref.mdx) and 
[the Compact standard library API reference](/docs/develop/reference/compact/compact-std-library/README.md).

The formal grammar for Compact and a specification of the API for
`ledger` datatypes are available, as well (both externally generated):
- [Compact formal grammar](https://docs.midnight.network/develop/reference/compact/lang-ref)
- [Ledger data types](https://docs.midnight.network/develop/reference/midnight-api/compact-runtime/)
</file>

<file path="docs/develop/reference/compact/lang-ref.mdx">
# Compact reference

Compact is a strongly statically typed, bounded smart contract language, designed to be
used in combination with TypeScript for writing smart contracts for the
three-part structure of Midnight, where contracts have the following
components:
- a replicated component on a public ledger
- a zero-knowledge circuit component, confidentially proving the correctness of
  the former
- a local, off-chain component that can perform arbitrary code

Each contract in Compact can have four kinds of code:
- type declarations, to support all of the following
- declarations of the data that the contract stores in the public ledger
- declarations of `witness` functions, to be supplied in TypeScript
- `circuit` definitions, that serve as the operational core of a smart contract

A contract can also include code from external files, and it can declare and
import modules.

Like TypeScript, Compact is an eager call-by-value language.

## Compact Types

Compact is **statically typed**: every expression in a Compact program has a
static type.  Named circuits and witnesses require a type annotation on each of
their parameters, and they require a return type annotation.  Anonymous circuit
expressions can have optional parameter and return type annotations.  Constant
binding statements can have an optional type annotation.

The language is **strongly typed**: the compiler will reject programs that do
not type check.  It will reject programs where a circuit or witness with a
parameter type annotation is called with an incorrectly typed argument for that
parameter.  It will reject programs where a circuit with a return type
annotation returns an incorrectly typed value.  If an optional type annotation
is omitted, the compiler will infer a type and it will reject programs where no
such type can be inferred.

Types consist of built-in primitive types, user-defined types defined in the
program, and generic type parameters in scope.  When the term "type" occurs in
this document without any other qualifier, it means either a primitive type, a
user-defined type, or a generic type parameter in scope.

### Primitive types

The following are the primitive types of Compact:

- `Boolean` is the type of *boolean* values.  There are only two values of
  `Boolean` type.  They are the values of the expressions `true` and `false`.

- `Uint<m..n>`, where `m` is the literal `0` or a generic size parameter in
  scope and bound to `0`, and where `n` is a natural number literal or a generic
  size parameter in scope, is the type of *bounded unsigned integer* values
  between `0` and `n`, both inclusive.  (The lower bound is currently required
  to be `0`.)  `Uint` types with different bounds `0..n` are different types,
  although [one may be a subtype of the other](#subtyping-and-least-upper-bounds).  In practice, there
  is a (large) maximum unsigned integer value determined by the zero-knowledge
  proving system.  The Compact implementation will signal an error if a `Uint`
  type exceeds this maximum value.

- `Uint<n>`, where `n` is a non-zero natural number literal or a generic size
  parameter in scope and bound to a non-zero natural number, is the type of
  *sized unsigned integer* values with binary representations using up to `n`
  bits.  This is the same type as `Uint<0..m>` where `m` is equal to `(2^n)-1`.
  Sized integer types can be seen as a convenience for programmers.  `Uint<32>`,
  for example, can be more obvious and less error-prone than the equivalent
  `Uint<0..4294967295>`.  Any Compact program that uses sized integer types can
  be rewritten to one that uses only bounded integer types.

- `Field` is the type of elements in the scalar prime field of the
  zero-knowledge proving system.

- `[T, ...]`, where `T, ...` are zero or more comma-separated types is the type
  of *tuple* values with element types `T, ...`.  Note that tuples are
  heterogeneous: the element types can all be distinct.  The *length* of a tuple
  type is the number of element types.  Tuple types with different lengths are
  different types.  Tuple types with the same lengths but where at least one
  element has different types are different types although [one may be a subtype
  of the other](#subtyping-and-least-upper-bounds).

- `Vector<n, T>`, where `n` is a natural number literal or else a generic size
  parameter in scope and `T` is a type, is a shorthand notation for the tuple
  type `[T, ...]` with `n` occurrences of the type `T`.  Note that a vector type
  and the corresponding tuple type are two different ways of writing exactly the
  same type.  Unless otherwise specified, type rules for vector types are
  derived from the rules for the corresponding tuple type.

- `Bytes<n>`, where `n` is a natural number literal or else a generic size
  parameter in scope, is the type of _byte array_ values of length `n`.  `Bytes`
  types with different lengths are different types.  `Bytes` types are used in
  the Compact standard library for hashing.  String literals in Compact also
  have a `Bytes` type, where `n` is the number of bytes in the UTF-8 encoding of
  the string.

- `Opaque<s>`, where `s` is a string literal, is the type of _opaque_ values
  with tag `s`.  The syntax of string literals in Compact is the same as in
  TypeScript.  `Opaque` types with different tags are different types.  Opaque
  values can be manipulated in witnesses but they are opaque to circuits.  They
  are represented in circuits as their hash.  The allowed tags are currently
  only `"string"` and `"Uint8Array"`.

### User-defined types

Users can define three kinds of types themselves: structures, enumerations, and contracts.

#### Structure types

Structure types are defined by a declaration beginning with the keyword
`struct`.  Here are some examples:

```compact
struct Thing {
  triple: Vector<3, Field>,
  flag: Boolean,
}

struct NumberAnd<T> {
  num: Uint<32>;
  item: T
}
```

A _non-generic structure_ declaration introduces a named structure type, such as
`Thing` in the first example above.  Each non-generic structure declaration
introduces a distinct type, even when the content of the structure is identical
to another.

Structure declarations can also be _generic structure_ declarations, such as
`NumberAnd` in the second example above.  They have a non-empty list of
comma-separated _generic parameter_ names enclosed in angle brackets.  The generic
parameters of a generic structure declaration are in scope in its body.

Generic structure declarations do not introduce a type.  To be used as a type,
they must be _specialized_ by providing a comma-separated list of _generic
arguments_, e.g., `NumberAnd<Uint<8>>`.  Generic arguments must be types,
natural number literals, or a generic size parameter in scope.  Generic
structures must be fully specialized: the number of generic arguments must match
the number of generic parameters.

- Specializations of the same generic structure to the same types are the same
  type.
- Specializations of the same generic structure to different types are different
  types.
- Specializations of different generic structures are always different types,
  even if the specializations are structurally equivalent.
- Specializations of generic structures are always different from non-generic
  structure types, even if the specialization is structurally equivalent to the
  non-generic type.

A structure declaration has a sequence of named fields which must be separated
either by commas or by semicolons.  Comma and semicolon separators cannot be
mixed within a single structure declaration.  A trailing separator is allowed,
but not required.

Each structure field must have a type annotation.

Values of structure types are created with _structure creation_ expressions.
These consist of the structure type (so generic structures must be specialized),
followed by a sequence of field values enclosed in curly braces (`{ }`).  Field
values can be given positionally, in the same order as they are declared in the
`struct` declaration; or they can be named using the field names from the
declaration.  Named field values can appear in any order.  Positional and named
field values can be mixed in the same structure creation expression, but all the
positional ones must come before any of the named ones.  See [Structure
creation](#structure-creation) for the details.

Using the example declarations above, structure values could be created with
`Thing {[0, 1, 2], true}` or `NumberAnd<Uint<8>> { item: 255, num: 0 }`.

Structures may not contain fields containing the same type as the structure,
either directly or indirectly. For example, it is an error to use the following
pair of declarations:

```compact
struct Even {
  predecessor: Odd
}

struct Odd {
  predecessor: Even
}

export circuit doesntWork(s: Even): Odd {
  return s.predecessor;
}
```

#### Enumeration types

Enumeration types are defined by a declaration beginning with the keyword
`enum`.  Here is an example:

```compact
enum Fruit { apple, pear, plum }
```

An enumeration declaration introduces a named enumeration type, such as `Fruit`
in the example above.  Each enumeration declaration introduces a distinct type.

An enumeration declaration has a sequence of named values separated by commas.
A trailing separator is allowed but not required.

In the example above, the type `Fruit` has three values: `Fruit.apple`,
`Fruit.pear`, and `Fruit.plum`.

#### Contract types

As of this writing, declarations of contracts and the cross-contract calls they support are
not yet fully implemented, but the keyword `contract` used to declare contracts is reserved
for this use.

### Generic parameter references

Generic parameters are declared in generic module declarations, generic structure
type declarations, generic circuit definitions, and generic witness declarations.  
For generic modules, they are in scope within the module.
For generic structures, they are in scope for the structure's fields.
For generic circuits, they are in scope in the circuit's
parameters, its return type annotation, and its body.  In
these scopes, a reference to a generic parameter (that is not otherwise shadowed by
some other identifier binding) is either a type or a natural-number size.

### Subtyping and least upper bounds

There is a *subtyping* relation on Compact types.  Informally, if a type `T` is
a subtype of a type `S` then every value of type `T` is also a value of type `S`
(equivalently, `S` is a supertype of `T`).  In that case, Compact allows
implicitly using a value of type `T` where a value of type `S` is expected,
without any programmer-supplied conversion.

Subtyping is defined by the following rules:

- Any type `T` is a subtype of itself (subtyping is reflexive)
- `Uint<0..n>` is a subtype of `Uint<0..m>` if `n` is less than `m`
- `Uint<0..n>` is a subtype of `Field` for all `n`
- `[T, ...]` is a subtype of `[S, ...]` if the two tuple types have the length
  and each type `T` is a subtype of the corresponding type `S`

A circuit or witness can be called with argument expressions whose types are
subtypes of the corresponding parameter type annotations.  A constant binding
statement with a type annotation can be initialized with an expression whose
type is a subtype of the type annotation.

The *least upper bound* (with respect to subtyping) of a non-empty set of types
\{`T0`, ..., `Tn`} is a type `S` such that:

- **`S` is an upper bound:** `Ti` is a subtype of `S` for all `i` in
    the range 0..`n`, and
- **`S` is the least upper bound:** for all upper bounds `R` of the set of types
    \{`T0`, ..., `Tn`}, `S` is a subtype of `R`.

Note that least upper bounds do not necessarily exist for all sets of types.

**Tuple and vector types:** We say that a tuple type `[T, ...]` with possibly
distinct types `T, ...` "*has a vector type*" if the least upper bound `S` of
the set of types \{`T`, ...} exists.  In that case, the tuple type has the
vector type `Vector<n, S>` where `n` is the length of the tuple.  Some
operations over tuples (such as mapping and folding) require the tuple type to
have a vector type.

Note that when a tuple type has a vector type, the tuple type is a subtype of
the vector type.  Perhaps surprisingly, vector types can be subtypes of tuple
types as well.  A vector type `Vector<n, T>` is a subtype of a tuple type
`[S, ...]` if the tuple has length `n` and `T` is a subtype of each of the types
`S, ...`.  The means, for instance, that a vector could be passed to a circuit
where a tuple is expected.

### Default values

Every type in Compact has a *default value* of that type.  The default values
are as follows:

- `Boolean`: the value of the literal `false`
- `Uint<0..n>` and `Uint<n>`: `0`
- `Field`: `0`
- `[T, ...]` where `T, ...` is a sequence of zero or more types: the tuple with
  the corresponding length, each of the default value of the corresponding type
- `Bytes<n>`: the byte array of length `n` with all zero bytes
- `Opaque<"string">`: an empty string, i.e., `""`
- `Opaque<"Uint8Array">`: a zero-length `Uint8Array`, i.e., `new Uint8Array(0)`
- structure types: the struct with all fields set to the default value of their
  type
- enumeration types: the first value listed in the declaration

### Representations in TypeScript

Compact's primitive types are represented in TypeScript as follows:

- `Boolean` - `boolean`
- `Field` - `bigint` with runtime bounds checks
- `Uint<n>` / `Uint<0..n>` - `bigint` with runtime bounds checks
- `[T, ...]` - the TypeScript tuple type `[S, ...]` or else the TypeScript array
  type `S[]` with runtime length checks, where `S` is the TypeScript
  representation of the corresponding type `T`
- `Bytes<n>` - `Uint8Array` with runtime length checks
- `Opaque<"string">` - `string`
- `Opaque<"Uint8Array">` - `Uint8Array`

User-defined types are represented in TypeScript as follows:
- `enum` instances - a `number` with runtime membership checks
- `struct` instances with fields `a: A, b: B, ...` - an object `{ a: A, b: B, ... }`
  where `A`, `B`, ... are the TypeScript representations of the Compact types.

Note that other `Opaque` types are currently not supported.

## Include files

Compact supports code separation and namespaces through separate files
and modules.  The most basic
of these is the statement

```compact
include "path/to/file";
```

which may appear at the top level of a source file or module. When encountered,
the Compact compiler will search for a Compact source file at
`path/to/file.compact` in the current directory and then 
relative to any of the directories in the
`:`-separated environment variable `COMPACT_PATH`.
This file *must* be found and will be included
verbatim in place of the `include` statement.

## Modules, exports, and imports

A module is a collection of definitions whose namespace is hidden from
surrounding code. A module is defined with

```compact
module Mod1 {
  ...
}

module Mod2<T> {
  ...
}
```

By default, identifiers defined within the body of a module are
visible only within the module, i.e., they are not exported from
the module.  Any identifier defined at or imported into the top
level of a module can be exported from the module in one of two
ways: (1) by prefixing the definition with the `export` keyword,
or by listing the identifier in a separate `export` declaration.
For example, the following module exports `G` and `S` but not `F`.

```compact
module M {
  export { G };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(s: S): Boolean {
    return s.y;
  }
  circuit G(s: S): Uint<16> {
    return F(s) ? s.x : 0;
  }
}
```

A module can be imported into another definition scope, bringing
all its exported entries into that scope, potentially with a prefix. For
instance:

```compact
module Runner {
  export circuit run(): [] {}
}
import Runner;
// run is now in scope
import Runner prefix SomePrefix_;
// SomePrefix_run is now in scope

module Identity<T> {
  export { id }
  circuit id(x: T): T {
    return x;
  }
}
import Identity<Field>;
// id is now in scope, with Field as type T
```

Compact's standard library can be imported by `import CompactStandardLibrary`.
The standard library defines a number of useful types and circuits along with
ledger ADTs such as `Counter`, `Map`, and `MerkleTree`.

When importing module `M`, if the program does not contain a visible module definition
the compiler looks in the file system in the relative path of the current directory for `M.compact`.
In the case where a module is defined in a different program (file), the program must only contain
a top-level module definition. Otherwise, the compiler throws a static error stating that the program
does not contain a single module definition. For example, the program `M.compact` below defines
a module:

```compact title=M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
// circuit cant_exists() : [] {}
// If cant_exists is uncommented, the compiler will throw an error when compiling
// test.compact
```

Then, `test.compact` imports `M`:

```compact title=test.compact
//module M {
//  export { G };
//  export struct S { x: Uint<16>, y: Boolean }
//  circuit G(x: S): Boolean {
//    return S.y;
//  }
//}
// If M is uncommented, the compiler will import this module and not the one
// defined in M.compact. In this case, the compiler will throw an error for
// exporting F.

import M;
export { F };
```

The import syntax allows the module to be identified by a string pathname. In this case, the compiler
first looks for the imported module relative to the current directory (the path of the importing
program) and then in the directories identified by `COMPACT_PATH`. Importing by a pathname allows
importing multiple modules with the same name. For example, consider the program `M.compact`:

```compact title=M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
```

And the program `A/M.compact`:

```compact title=A/M.compact
module M {
  export { F };
  export struct S { x: Uint<16>, y: Boolean }
  circuit F(x: S): Boolean {
    return S.y;
  }
}
```

And finally the program `test.compact` can export both `$F` and `A_F` but not `$G`:

```compact title=test.compact
module M {
  export { G };
  export struct S { x: Uint<16>, y: Boolean }
  circuit G(x: S): Boolean {
    return S.y;
  }
}

import "M" prefix $;
// this imports M.compact and not the module M defined above

import "A/M" prefix A_;

export { $F
  ,A_F
//  ,$G
// uncommenting this will result in an error
  };
```


## Top-level exports

The circuits exported at the top level of a contract (i.e., not merely exported
from a module) are the entry points of the contract and may not take generic arguments.
Although multiple circuits with the same name are allowed generally to support
[function overloading](#circuit-and-witness-calls), it is a static error if more
than one circuit with the same name is exported from the top level.

User-defined types exported from the top level of the main file can be used
to describe the argument and return types of witnesses and exported circuits;
these may accept generic arguments, but generic arguments not actually used as types
are dropped in the exported type.  For example:

```compact
export struct S<#n, T> { v: Vector<n, T>; curidx: Uint<0..n> }
```

is exported for use as a TypeScript type with the `T` parameter but not the `n`
parameter, i.e.,:

```typescript
export type S<T> = { v: T[]; curidx: bigint }
```

Ledger field names exported from the top level are visible for direct inspection
by code outside of the contract via the generated TypeScript `ledger()` function.

## Circuits

The basic operational element in Compact is the `circuit`. This corresponds
closely to a function in most languages but is compiled directly into a
zero-knowledge circuit. Circuits are declared as:

```compact
circuit c(a: A, b: B, ...): R {
  ...
}

circuit id<T>(value: T): T {
  return value;
}
```

where `A`, `B`, ..., and `R` are types, and `a`, `b` are parameters. The circuit
body itself is a sequence of statements, and each path through the body must end
with a `return` statement, unless the return type is `[]`.

### Pure and impure circuits

A Compact circuit is considered *pure* if it computes its outputs from its
inputs without reference to or modification of public state (via the ledger)
or private state (via witnesses).
In practice, the compiler considers a circuit to be impure if
the body of the circuit contains a ledger operation, a call to any impure
circuit, or a call to a witness.

Some external circuits defined in `CompactStandardLibrary` are witnesses;
calls to these make the caller impure.
The remainder are considered pure, so calls to those do not make the caller impure.

A Compact program can declare a circuit to be pure by prefixing the circuit
definition with the `pure` modifier, which must follow the `export` modifier,
if present, e.g.:

```compact
pure circuit c(a: Field): Field {
  ...
}

export pure circuit c(a: Field): Field {
  ...
}
```

The only effect of the `pure` modifier is that the compiler will
flag the declaration as an error if its own analysis determines
that the circuit is actually impure.
The pure modifier allows an application to ensure that the circuit
will be present in the `PureCircuits` type declaration and via the
`pureCircuits` constant in the TypeScript module produced for a
(correct) Compact program by the Compact compiler.

### Statements

A statement may be
- a `for` loop
- an `if` statement
- a `return` statement
- an `assert`
- a block - a sequence of statements in a nested scope, enclosed by curly braces
- a `const` binding statement
- an expression

#### `for` loop

A `for` loop repeats for a fixed number of iterations, using one of the two
syntaxes below:

```compact
for (const i of <vector>) <statement>

for (const i of <lower>..<upper>) <statement>
```

#### `if` statement

An `if` statement is of one of the following forms:

```compact
if (testexpr)
  <statement>

if (testexpr)
  <statement>
else
  <statement>
```

#### `return` statement

If a circuit's return type is `[]`, 
```compact
return;
``` 

is a valid statement.  Otherwise, 

```compact
return <expr>;
```
for an expression `<expr>` of the declared return type is a
valid return statement.

#### `assert` statement

An assertion can be made with

```compact
assert(<expr>, "what constraint was violated");
```

where `<expr>` should evaluate to a `Boolean`. If `<expr>` evaluates to
true, the assertion succeeds; if `<expr>` evaluates to false, it fails
with the given message.  Each assertion is
checked at runtime and constrained in-circuit.

#### `const` binding statement

A new constant can be brought into scope with 

```compact
const x = <expr>;
```

A `const` binding statement can bind multiple constants. The constant bindings are
performed from left-to-right.

```compact
const x = <expr>, y = <expr>;
```

A variable bound by a constant binding cannot be referenced before it is initialized.

```compact
circuit c(): Field {
  // const y = x; // rejected by Compactc
  const x = 1, y = x;
  // const y = x, x = 1; // rejected by Compactc
  return y;
}
```

Each of the constant bindings may optionally be annotated with a type, in which case the type is
checked with the expression.

```compact
const x: T = <expr>;
```

```compact
const x: T = <expr>, y = <expr>;
```

The name of a constant may not be
reused within a block, and constants cannot be reassigned, although they can be
shadowed in a nested block:

```compact
circuit c(): Field {
  const answer = 42;
  // const answer = 12, answer = 1; // rejected by Compactc
  {
    const answer = 12;
    assert answer != 42 "shadowing didn't work!";
  }
  return answer; // returns 42
}
```

Constant initializer expressions are evaluated when the binding statement is executed.

### Expressions

This section describes the syntax of Compact expressions and provides their
static typing rules and their evaluation rules.

The syntax of expressions is given by an EBNF grammar.  We use the following
notational conventions in the grammar:

- Terminals are in <b><tt>bold monospaced</tt></b> font
- Non-terminals are in <em>emphasized</em> font
- Alternation is indicated by a vertical bar (`|`)
- Repetition of zero or more items is indicated by enclosing them in curly
  braces (`{` and `}`)
- Optional items are indicated by enclosing them in square brackets (`[` and
  `]`)

A Compact expression either has a static type, or else it contains a type error.
The static type of an expression, if it has one, is either a Compact type or
else a ledger state type.  If an expression in a program contains a type error,
it means that the Compact compiler will not compile that program.
Subexpressions of Compact expressions are always required to be well-typed
(free from type errors).

Every Compact expression either evaluates to a value, or else it raises an
exception.  The evaluation of an expression is defined in terms of the
evaluation of its subexpressions.  If the evaluation of a subexpression raises
an exception, then the evaluation of the containing expression will stop and
raise the same exception.

#### Literals

Compact has syntax for boolean, numeric, and string literal expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>true</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>false</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>nat</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>str</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>pad</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>str</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

__Boolean literals__ are the reserved words `true` and `false`.
The static type of a boolean literal is `Boolean`.
It evaluates to one of the two boolean values.

__Numeric literals__ are non-negative decimal integers.  They are either the
number `0` or a sequence of digits starting with a non-zero digit.  The static
type of a natural number literal `n` is `Uint<0..n>`.

There is an implementation-defined maximum unsigned integer value.  A numeric
literal larger than this value will have an invalid static type `Uint<0..n>` for
some `n` larger than the maximum unsigned integer.  This expression will be a
static type error unless the literal is smaller than the maximum `Field` value
and is used in a type cast expression of the form `e as Field`.

A natural number literal evaluates to the unsigned integer value that it
denotes.

__String literals__ use TypeScript string literal syntax.  Note that they can
therefore be enclosed in either single (`'`) or double (`"`) quotes, and they
can contain escaped characters.  Strings are represented by their UTF-8
encoding.  The **length** of a string is the length of its UTF-8 encoding.
The static type of a string literal is `Bytes<n>` where `n` is the length of
the string.
It evaluates to a byte array containing its UTF-8 encoding.

In addition, the expression `pad(n, s)` is a string literal, where
`pad` is a reserved word, `n` is a natural number literal and `s` is a string
literal whose length must be less than or equal to `n`.
The static type of a padded string literal `pad(n, s)` is `Bytes<n>`.
It evaluates to a byte array containing the UTF-8 encoding of `s`, followed by
`0` bytes up to the padded length `n`.

#### Variable references

The syntax of Compact identifiers is the same as the syntax of TypeScript
identifiers.  A variable is an identifier that is bound as a parameter in a
circuit declaration or else as a constant in a `const` binding statement.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

__Circuit parameters__ are bound by circuit declarations.
The static type of a circuit parameter reference is the declared static type
given by the parameter declaration's type annotation.
It evaluates to the value of the corresponding argument expression that was
passed to the circuit call.

__Constants__ are bound by `const` binding statements.  If the binding statement
has a type annotation, then the constant reference's static type is the declared
static type given by the type annotation, and the type of the right-hand side
initializer expression must be a subtype of the declared type.  If the binding
statement does not have a type annotation, then the constant reference's static
type is the inferred static type (that is, the type of the binding statement's
initializer expression).  A constant reference evaluates to the value of the
binding statement's initializer expression.

Note that constant references can have ledger state types because they can be
initialized with a ledger state type's default value.

#### Default values of a type

Every Compact type and ledger state type has a default value.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>type</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>default</tt></b>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;<em>ledger-adt</em>&nbsp;&nbsp;<b><tt>></tt></b></td></tr></tbody></table>

The expression `default<T>`, where `T` is a Compact type or a ledger state type,
has static type `T`.
It evaluates to the default value of that type.

Note that default value expressions can have ledger state types.

#### Circuit and witness calls

Circuits and witnesses, collectively referred to as functions, are called via an
expression of the form `f(e, ...)`, where `f` is a function and `e, ...` is a
sequence of zero or more comma-separated argument expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>fun</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>var-or-arg</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>var-or-arg</em>}]&nbsp;&nbsp;<b><tt>)</tt></b>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;[<em>type</em>]&nbsp;&nbsp;<b><tt>=></tt></b>&nbsp;&nbsp;<em>body</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td><em>targs</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>\<</tt></b>&nbsp;&nbsp;[<em>targ</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>targ</em>}]&nbsp;&nbsp;<b><tt>></tt></b></td></tr><tr><td><em>targ</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>nat</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>type</em></td></tr><tr><td><em>var-or-arg</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>arg</em></td></tr><tr><td><em>arg</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>type</em></td></tr><tr><td><em>body</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>block</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

The function expression can take several different forms:

A **function name** is the name of a circuit or witness from a circuit or
witness declaration in scope.

An **anonymous circuit** is an inline circuit definition having the form `(P,
...) => body` or `(P, ...): R => body`, where `P, ...` are zero or more
comma-separated parameter declarations, `R` is an optional return type
annotation, and `body` is the circuit's body.  Each parameter consists of an
identifier `x` (the parameter's name) and an optional type annotation `: T`
where `T` is a Compact type.  The optional return type `R` is a Compact type.
The body is either a block (a sequence of zero or more semicolon-delimited
statements enclosed in curly braces (`{ }`)), or an expression.

There is no syntax for generic anonymous circuits.  This is because circuits are
not first-class values: they cannot be passed around or stored in data
structures, they *must* be called.  And generic circuits must be specialized to
call them, so anonymous generic circuits would have to be immediately
specialized.  In that case, the programmer can just write the non-generic
version themselves.

A **parenthesized function** has the form `(f)` where `f` is a function
expression, that is either a function name, an anonymous circuit, or a
parenthesized function.

Because functions are not first class, parameter names and constant names are
not allowed as the function part of a call.  Nor are arbitrary expressions
allowed, for the same reason.

Because circuits and witnesses are not first class, parameter names and constant
names are not allowed as the circuit or witness part of a call.  Nor are
arbitrary expressions allowed, for the same reason.

Generic functions cannot be called without explicitly specializing them with
generic arguments enclosed in angle brackets.  Calls to generic functions must
be fully specialized: the number of generic arguments must match the number of
generic parameters.

The *underlying function* of a function expression is a non-parenthesized
function expression.  For a function name it is the function name, for an
anonymous circuit it is the anonymous circuit, and for a parenthesized function
it is the underlying function of the parenthesized function expression.

Type checking a function call depends on the form of the underlying function.

* **For a named function:** Function names may be *overloaded*: more than one
  function of the same name may be present in the scope of a call to that
  function.  A call whose underlying function is a name can thus have zero or
  more candidate functions, i.e., all of those that have the given name and are
  present in the scope of the call.

  A candidate function is not necessarily compatible with the number and kinds
  of the generic parameter values, nor with the number and types of the argument
  expressions provided at the call site.  It is compatible if and only if the
  number of generic parameters is the same as the number of generic arguments,
  each generic argument is of the required kind (a size or a type), the number
  of declared parameters is the same as the number of argument expressions, and
  if the declared type of each parameter is a supertype of the corresponding
  argument expression.  If exactly one candidate is compatible, the call is made
  to that candidate.  It is a static type error otherwise (if there is not
  exactly one compatible candidate).

  The static type of a call to a named function is the return type of the called
  function.

* **For an anonymous circuit:** Parameters that have type annotations will be
  type checked, and parameters that do not have type annotations will have types
  inferred.  The argument subexpressions are type checked and then:

  - If there is a type annotation for a parameter, it is a static type error if
    the type of the corresponding argument expression is not a subtype of the
    type annotation.

  - If there is no type annotation for a parameter, the parameter's type is
    inferred as the type of the corresponding argument expression.

  If there is a return type annotation, then the circuit's body is type checked
  under the assumption that the parameters have their declared or inferred
  types.  It is a static type error if there is a returned subexpression whose
  static type is not a subtype of the return type annotation.  A return
  statement of the form `return;` is type checked as if it returned a value of
  type `[]`.  Every control flow path through a body that does not explicitly
  end with a return statement implicitly ends with one of the form `return;`.

  If there is no return type annotation, then a return type is inferred from the
  body.  The body is type checked under the assumption that the parameters have
  their declared or inferred types.  The inferred return type is the least upper
  bound of the types of all the returned subexpressions, with the same treatment
  of `return;` and control-flow paths that do not end in an explicit return as
  described above.

  The static type of a call to an anonymous circuit is the declared or inferred
  return type.

Calls are evaluated by evaluating the argument expressions in order from left to
right.  Then, if a circuit is being called, the statements in the body of the
circuit are executed with the parameter names bound to the corresponding
argument values.  The value of a circuit call is the value returned from the
execution of the body.  If a witness is being called, the contract will invoke
the TypeScript or JavaScript witness function with the argument values.  The
value of a witness call is the value returned by the witness function.

#### Structure creation

Structure values are created with structure creation expressions.  The
expression `S {f, ...}` is a structure creation expression, where `S` is a
structure type and `f` is a sequence of zero or more comma-separated field
value specifiers.

A field value specifier can be one of three things:

* A **positional** field value is an expression.  Evaluating the expression
  gives the value for the field.  Positional field values must be given in the
  order that fields are declared in the corresponding structure declaration.
* A **named** field value is of the form `id: e` where `id` is a field name and
  `e` is an expression.  Evaluating the expression gives the value for the
  corresponding named field.  Named fields can appear in any order.  If named
  and positional fields are mixed, all the named fields must appear after all
  the positional fields.
* A **spread** expression is of the form `...e` where `...` is the literal three
  dots (ellipsis) token and `e` is an expression.  Evaluating the expression
  must give a value of the same structure type as the one being created.  The
  fields of the created structure are given values from the spread structure as
  described below.  If there is a spread expression, it must occur as the first
  field value specifier and all other specifiers must be named field values.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>tref</em>&nbsp;&nbsp;<b><tt>\{</tt></b>&nbsp;&nbsp;[<em>new-field</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>new-field</em>}]&nbsp;&nbsp;<b><tt>}</tt></b></td></tr><tr><td><em>new-field</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>...</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td><em>tref</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;[<em>targs</em>]</td></tr></tbody></table>

The examples below demonstrate the use of positional and spread field values:

```compact
struct S { a: Uint<32>, b: Boolean, c: Bytes<8> }
circuit f(x: Uint<32>, y: Boolean, z: Bytes<8>): S {
  const s1 = S { c: z, a: x, b: y };
  // Alternatively, s1 can be created with the positional syntax S { x, y, z }
  // or a mix of positional and named field values S { x, c: z, b: y }.

  const s2 = S { ...s1, b: true };
  // s2 is created using the spread syntax.  So, s2 has the same field values
  // as s1 except that b is true.

  const s3 = S { ...s2, c: 'abcdefgh' };
  // s3 is also created using the spread syntax.  s3 has the same field values
  // as s2 except that c is 'abcdefgh'.

  return s3;
}
```

The structure type must come from a structure declaration in scope.  If the
structure is generic, then it must be explicitly specialized with generic
arguments enclosed in angle brackets.  Generic structures must be fully
specialized: the number of generic arguments must match the number of generic
parameters.

The static type of a non-generic structure creation expression is the named
structure type.

The generic arguments to a generic structure can be types, natural number
literals, or the names of generic parameters in scope.  A generic structure
creation expression is type checked by substituting the generic arguments for
the generic parameters in the structure's definition.  The static type of a
generic structure creation expression is a structure with the same name as the
generic type and field types obtained by substituting the generic arguments for
the generic parameters in the structure's declaration.

**If there is no spread field specifier:** It is a static error if the number of
field specifiers does not match the number of fields in the corresponding
structure declaration (a value must be given for every field).  It is a static
error if a named field specifier occurs before a positional field specifier.  It
is a static error if a field name occurs more than once, and it is a static
error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
positional field subexpression is not a subtype of the declared type of the
(positionally) corresponding field in the structure declaration.  It is a static
type error if the type of a named field subexpression is not a subtype of the
declared type of the corresponding (named) field in the structure declaration.

**If there is a spread field specifier:** It is a static error if the spread
field specifier does not come first in the sequence.  It is a static type error
if the type of the spread subexpression is not the same type as structure to be
created.  It is a static error if there are any positional field specifiers.  It
is a static error if a field name occurs that is not the name of a field in the
corresponding structure declaration.  It is a static type error if the type of a
named field subexpression is not a subtype of the declared type of the
corresponding (named) field in the structure declaration.

A structure creation expression is evaluated by evaluating the field specifier
subexpressions in order from left to right.  The result is a structure value
whose fields have values based on the corresponding field specifier: if there is
a positional or named field specifier for the field, the field value is the
value of the subexpression, otherwise there must be a spread expression and the
field value is the value of the corresponding field in the (structure) value of
the spread subexpression.

#### Tuple creation

Tuple values are created with expressions of the form `[e, ...]` where `e, ...`
is a sequence of zero or more comma-separated argument expressions.  A non-empty
sequence can have an optional trailing comma.  The *length* of a tuple is the
number of subexpressions in the tuple creation expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;[<b><tt>,</tt></b>]&nbsp;&nbsp;<b><tt>]</tt></b></td></tr></tbody></table>

The static type of a tuple creation expression is `[T, ...]` with the number of
types matches length of the tuple and each type `T` is the type of the
corresponding expression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is a tuple whose length is the number of subexpressions and whose elements are
the subexpression values.

#### Parenthesized expressions

Compact allows parenthesized expressions of the form `(e)`, where `e` is an
expression.  They can be used to control the order of evaluation.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The type of the parenthesized expression is the type of the subexpression.

Its value is the value of the subexpression.

#### Sequence expressions

Expressions can be sequenced for their side effects.  An expression of the form
`(e0, e1, e2, ...)` or `e0, e1, e2, ...` where `e0, e1, e2, ...` is a sequence of two or more 
comma-separated expressions is a sequence expression. The latter form where parentheses can
be omitted is only allowed in some context which can be viewed in
[the formal grammar of Compact](./compact-grammar).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;</td></tr></tbody></table>

The static type of a sequence expression is the static type of the last 
subexpression.

It is evaluated by evaluating the subexpressions from left to right.  Its value
is the value of the last subexpression.

#### Ledger expressions

A Compact program interacts with its public state by invoking operations upon
the ledger or ledger state types.  There are two different forms of ledger
calls.

__Kernel operations__ are operations that do not depend on specific ledger 
state.  They can be invoked by expressions of the form `k.op(e, ...)`, where
`k` is the name of a ledger field declared to have the special ADT type `Kernel`,
`op` is the name of a builtin kernel operation and
`e, ...` is a comma separated sequence of zero or more argument expressions.
The `CompactStandardLibrary` predefines the ledger field name `kernel` to have
ledger type `Kernel`, so for example, the built-in `self` operation can be called
from a circuit as follows:

```compact
import CompactStandardLibrary;
circuit f(): ContractAddress {
  return kernel.self();
}
```

__Ledger ADT operations__ are operations on the program's public ledger state.
They are invoked by expressions of the form `member.op(e, ...)....`,
where `member` is a ledger field name ([declared via a `ledger` field declaration](#declaring-and-maintaining-public-state))
and `.op(e, ...)....` are a sequence of zero or more ledger
ADT operation invocations, where each `op` is the name of a ledger ADT
operation and each `e, ...` is a sequence of zero or more comma-separated
argument expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<em>ledger-accessor</em></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;\{<em>ledger-accessor</em>}</td></tr><tr><td><em>ledger-accessor</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;[<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}]&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

Note that ledger ADT operations can be chained, because the result of a ledger 
ADT operation might itself have a ledger state type.  Kernel operations cannot
be chained, because the kernel is not a ledger state type and is not returned
by any operation.

The static type of a kernel operation expression is the return type of the
corresponding kernel operation according to the ledger data types reference.

The static type of a ledger ADT operation expression is the return type of the
corresponding ADT operation according to the ledger data types reference.  Note
that this might be a Compact type or it might be a ledger ADT type.  Values of
ledger ADT types can have ADT operations invoked (immediately) on them, but
any other use would be a static type error.

Kernel operations are evaluated by evaluating the argument subexpressions in 
order from left to right and then invoking the corresponding kernel operation
with the argument values.

A ledger ADT operation `member` (that is not followed by a ledger
accessor) is implicitly an invocation of the `read` operation.  It is evaluated
as if it were `member.read()`.

A ledger ADT operation `member.op(e, ...)` is evaluated by evaluating the
argument subexpressions from left to right, and then invoking the operation
`op` on the public ledger member `member` with the argument values.

A ledger ADT operation `adt.op(e, ...)` where `adt` is itself a ledger ADT 
operation is evaluated by first evaluating `adt`, then evaluating the argument
subexpressions from left to right, and then invoking the operation `op` on the
ledger ADT value of `adt` with the argument values.

#### Element and member access expressions

Compact has expressions for accessing the elements of tuple values and the
members of structure values.  An expression of the form `e[n]` where `e` is an
expression and `n` is a numeric literal is a tuple element access.  An
expression of the form `e.id` where `e` is an expression and `id` is the name of
a structure member is a structure member access.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>[</tt></b>&nbsp;&nbsp;<em>nat</em>&nbsp;&nbsp;<b><tt>]</tt></b></td></tr><tr><td>&nbsp;</td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em></td></tr></tbody></table>

Tuple element accesses are type checked by checking the type of the
subexpression.  It is a type error if this type is not a tuple type `[T, ...]`.
It is a type error if the length of the tuple is less than or equal to the
numeric literal in the expression.  The type of the expression is the
corresponding element type `T` at position `n` in the tuple type.

Tuple element accesses are evaluated by evaluating the subexpression.  The
value of the expression will be the element value at the given zero-based
index.  The subexpression will have a tuple value and the element access will
not be out of bounds, because the expression is well-typed.

Member access expressions are type checked by checking the type of the 
subexpression.  It is a type error if this type is not a structure type.  It is
a type error if the structure type does not contain a member with the same name
as the name in the expression.  The type of the expression is the type of the
corresponding named member of the subexpression's structure type.

Member access expressions are evaluated by evaluating the subexpression.  The
value of the expression will be the member value with the given name.  The
subexpression will have a structure value and the name will exist, because the
expression is well-typed.

#### Boolean negation expressions

Compact has unary boolean negation expressions of the form `!e` where `e` is an 
expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>!</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

A boolean negation expression is type checked by checking the type of the 
subexpression.  It is a type error if this type is not `Boolean`.  The type of
the expression will be `Boolean`.

Negation expressions are evaluated by evaluating the subexpression.  The value
of the expression will be `true` if the value of the subexpression is `false`
and vice versa.  The subexpression will have a boolean value because the
expression is well-typed.

#### Binary arithmetic expressions

Binary arithmetic expressions are of the form `e0 op e1` where `e0` and `e1`
are expressions and `op` is one of Compact's binary arithmetic operators.  The
binary arithmetic operators are **add** (`+`), **subtract** (`-`) and
**multiply** (`*`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>+</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>-</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>*</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Arithmetic expressions require the type of both subexpressions to be numeric
types, that is, either a `Field` or a `Uint`.  The type of the result will
depend on the types of the subexpressions as follows:

- If either subexpression has type `Field`, the result will have type `Field`
- Otherwise the left subexpression will have type `Uint<0..m>` and the right
  subexpression will have type `Uint<0..n>` for some bounds `m` and `n`. The
  type of the result depends on the operation as follows:
  - For add, the result will have type `Uint<0..m+n>`
  - For subtract, the result will have type `Uint<0..m>`
  - For multiply, the result will have type `Uint<0..m*n>`

For arithmetic operations with `Uint` result types, it is a static type error if
the result's bound would be greater than the maximum unsigned integer.

Arithmetic expressions are evaluated by first evaluating the subexpressions in
order from left to right.  Integer addition, subtraction, or multiplication is
then used on the subexpression values.  The overflow and underflow behavior
differs for `Field` and `Uint` operations:

- `Field` arithmetic overflow and underflow wraps around 0; that is, the result
  of an arithmetic operation whose result is a `Field` is the actual arithmetic
  value modulo `k`, where `k` is one more than the maximum field value.
- `Uint` addition and multiplication cannot overflow: the static type of the
  result will always be large enough to hold the result value
- `Uint` subtraction checks if the value of the right subexpression is greater
  than the value of the left subexpression.  If so, it is a runtime error (the
  result would be negative).  Otherwise the unsigned subtraction is performed.

The static typing rules imply that if `Field` arithmetic semantics is desired,
then at least one of the operands must have static type `Field`.

#### Type cast expressions

Type cast expressions in Compact are of the form `e as T` where `e` is an
expression, `as` is a reserved words, and `T` is a Compact type.

TypeScript-style casts of the form `<T>e` are not supported in Compact.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>as</tt></b>&nbsp;&nbsp;<em>type</em></td></tr></tbody></table>

Type cast expressions are type checked by checking the type of the
subexpression.  If the cast from the subexpression's type to the
type `T` named in the type cast is allowed, then the static type
of the expression will be `T`.  Otherwise, it is a static type
error.

Upcasts, i.e., casts from a type to a supertype, are allowed but
never required and never result in a static or run-time error.

The table below describes the allowed type casts.  Casting between
types not shown in the table is not allowed.  The entries in the
table can be one of:

- **static:** the type cast only changes the static type and does
  not have any effect at runtime
- **conversion:** the type cast always succeeds but has the runtime
  effect of converting between different source and target
  representations, which normally has a low cost
- **checked:** the type cast is checked at runtime and can fail
- **no:** the type cast is not allowed
- a number: see the corresponding note below the table

<table>
  <thead>
    <tr>
      <th colspan="2"></th>
      <th colspan="4">TO</th>
    </tr>
    <tr>
      <th colspan="2"></th>
      <th><tt>Field</tt></th>
      <th><tt>Uint\<0..n></tt></th>
      <th><tt>Boolean</tt></th>
      <th><tt>Bytes\<n></tt></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5">FROM</th>
      <th><tt>Field</tt></th>
      <td>static</td>
      <td>checked</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th><tt>Uint\<0..m></tt></th>
      <td>static</td>
      <td>3</td>
      <td>conversion</td>
      <td>no</td>
    </tr>
    <tr>
      <th>enum type</th>
      <td>conversion</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Boolean</tt></th>
      <td>conversion</td>
      <td>4</td>
      <td>no</td>
      <td>no</td>
    </tr>
    <tr>
      <th><tt>Bytes\<m></tt></th>
      <td>5</td>
      <td>no</td>
      <td>no</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

1. `Field` to `Boolean`: the value `0` is converted to `false` and all other
   values are converted to `true`.
2. `Field` to `Bytes<n>`: the value of the field is converted into `Bytes` of
   the given length, with the least-significant byte of the field occurring
   first in the `Bytes`. The `Bytes` will be padded to the length with trailing
   zeros.  It is a runtime error if the field value does not fit in the length.
3. `Uint<0..m>` to `Uint<0..n>`: if `m` is less than or equal to `n` this is a
   static cast.  Otherwise it is checked and will fail at runtime if the value
   is greater than `n`.
4. `Boolean` to `Uint<0..n>`: If `n` is not 0 then this is a conversion of
   `false` to 0 and `true` to 1. Otherwise, it is checked and will fail at
   runtime if the value is `true` (and convert `false` to 0).
5. `Bytes<m>` to `Field`: the bytes are converted into a field with the
   least-significant byte of the field occurring first in the `Bytes`.  It is a
   runtime error if the result would exceed the maximum `Field` value.
6. `Bytes<m>` to `Bytes<n>`: the cast is a static cast if `m` equals `n`, and is
   not allowed otherwise.

Allowed type casts are evaluated by first evaluating the subexpression.
Then, if the cast is static, the result is the subexpression's value
interpreted as the type `T` mentioned in the cast expression.  If the
cast is a conversion, the JavaScript representation of the subexpression's
value is converted into the representation of a value of type `T`. If the
cast is checked, the check is performed before conversion and the cast
fails (at runtime) if the check fails.  The exceptions noted in the table
are evaluated as described above after evaluating the subexpression.

#### Relational comparison expressions

Relational comparison expressions are of the form `e0 op e1` where `e0`
and `e1` are expressions and `op` is one of Compact's relational operators.
The relational operators are **equals** (`==`), **not equals** (`!=`), **less
than** (`<`), **greater than** (`>`), **less than or equals** (`<=`), and
**greater than or equals** (`>=`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>==</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>!=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&lt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&gt;=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Equals and not equals require the types of the subexpressions to be in the
subtype relation.  That is, the type of the first subexpression must be a
subtype of the type of the second subexpression, or else the type of the second
subexpression must be a subtype of the type of the first subexpression.

Less than, greater than, less than or equals, and greater than or equals require
the type of both subexpressions to be unsigned integer types (note that `Field`
cannot be compared with these operators).

The type of the result is `Boolean`.

Relational comparison expressions are evaluated by evaluating the subexpressions
in order from left to right.  Then the comparison is performed as described
below.

**Equals**

The comparison that is performed depends on the type of the operands:

- **`Boolean`:** if the operands have type `Boolean`, then the values must be
  the same boolean value.  Both operands will have type `Boolean` due to the static typing rules.
- **`Uint`:** if the operands have unsigned integer types, then the integer
  values must be equal.  Both operands will have unsigned integer types due to
  the static typing rules.
- **`Field`:** if either operand has type `Field`, then the integer values of
  the operands must be equal.  Both operands will have numeric (`Field` or
  unsigned integer) types due to the static typing rules.
- **`Bytes:`** if the operands have bytes types, then the corresponding bytes
  at each index must be equal.  Both operands will have bytes types and their
  lengths will be equal due to the static typing rules.
- **`Tuple:`** if the operands have tuple types, then the corresponding
  element values at each index must be equal according to these rules, based on
  the static element types.  Both operands will have tuple types, they will
  have the the same length, and their element types will be in the subtype
  relation due to the static typing rules.
- **`Opaque:`** if the operands have opaque types, then the runtime values
  must be equal according to JavaScript's strict equality (`===`) operator.
  Both operands will have the same opaque type due to the static typing rules.
- **structure type:** if the operands have structure types, then the 
  corresponding values of each field must be equal according to these rules, 
  based on the field types.  Both operands will have the same structure type due 
  to the static typing rules.
- **enum type:** if the operands have enum types, then they must be the same
  enum value.  Both operands will have the same enum type due to the static
  typing rules.

**Not equals**

The operands are compared according to the rules for equals above, and then the 
boolean result is negated.

**Less than, greater than, less than or equals, and greater than or equals**

The integer values of the operands are compared according to the relational 
operation.  Both operands will have unsigned integer types due to the static 
typing rules.

#### Short-circuit logical expressions

Compact supports short-circuit logical expressions of the form `e0 op e1`
where `e0` and `e1` are expressions and `op` is one of the logical operators
**or** (`||`) or **and** (`&&`).

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>||</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>&amp;&amp;</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Logical expressions require the type of the left subexpression to be `Boolean`.
The type of the right subexpression must be a supertype of `Boolean`.  The only
supertype of `Boolean` is `Boolean` itself.  The entire expression will have the
same type as the type of the right subexpression.

Logical expressions are evaluated by first evaluating the left subexpression.
Then, the value of that expression determines the value of the entire
expression as follows:

- For or, if the value of the left subexpression is `false` then the right
  subexpression is evaluated and its value is the value of the entire
  expression.  Otherwise, the right subexpression is **not** evaluated and the
  value of the left subexpression, implicitly cast to the type of the entire
  expression, is the value of the entire expression.
- For and, if the left subexpression is `true` then the right subexpression is
  evaluated and its value is the value of the entire expression.  Otherwise,
  the right subexpression is **not** evaluated and the value of the left
  subexpression, implicitly cast to the type of the entire expression, is the
  value of the entire expression.

#### Conditional expressions

Compact supports conditional expressions of the form `e0 ? e1 : e2` where `e0`,
`e1`, and `e2` are expressions.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>?</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>:</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

Conditional expressions require the type of `e0` to be `Boolean`.  The types of
`e1` and `e2` must be in the subtype relation.  That is, either the type of
`e1` is a subtype of the type of `e2` or else the type of `e2` is a subtype of
the type of `e1`.

The type of the entire expression is the type of `e2` if `e1` is a subtype of
`e2` and the type of `e1` if `e2` is a subtype of `e1`.

Conditional expressions are evaluated by first evaluating `e0`.  Then, the
value of that expression determines which of the other subexpressions is
evaluated:

- if the value of `e0` is `true`, then `e1` is evaluated and its value is the
  value of the entire expression
- if the value of `e0` is `false`, then `e2` is evaluated and its value is the
  value of the entire expression

The evaluation rules ensure that only one of `e1` and `e2` is evaluated.

#### Map and fold expressions

Compact supports expressions that perform the higher-order operations _map_ and
(left) _fold_ over tuples that have a vector type (not arbitrary tuples).

Map expressions have the form `map(f, e, e, ...)` where `map` is a keyword, `f`
is a circuit or witness taking at least one argument, and the `e`s are
expressions.  A circuit or witness taking _n_ arguments can be mapped over _n_
argument vectors by providing _n_ vector subexpressions to the `map`.

Fold expressions have the form `fold(f, init, e, e, ...)` where `fold` is a
keyword, `f` is a circuit or witness, and `init` and the `e`s are expressions.
A circuit or witness taking _n_+1 arguments can be folded over an initial value
`init` and _n_ vectors by providing _n_ vector subexpressions to the `fold`.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>map</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr><tr><td></td><td>|</td><td>&nbsp;&nbsp;<b><tt>fold</tt></b>&nbsp;&nbsp;<b><tt>(</tt></b>&nbsp;&nbsp;<em>fun</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>&nbsp;&nbsp;\{<b><tt>,</tt></b>&nbsp;&nbsp;<em>expr</em>}&nbsp;&nbsp;<b><tt>)</tt></b></td></tr></tbody></table>

The syntax of the circuit or witness is given by the grammar production for
_fun_ in the section **Circuit and witness calls** above.

A map expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
one parameter.  The map expression must have the same number of vector subexpressions
as the number of parameters of `f`.  Each of the vector subexpressions
must have a vector type and all these vector types must have the same length
`n`.  If the type of the *i*th parameter to `f` is `T`, then the type of the
*i*th vector subexpression must be `Vector<n, S>` where `S` is a subtype of
`T`.  The type of entire expression is `Vector<n, R>`.

A fold expression is type checked by checking the type of the witness or circuit
`f` to find its parameter types and its return type `R`.  `f` must have at least
two parameters, and the type of the first parameter must be the same type as the
return type `R`.  The fold expression must have one fewer vector subexpression
than the number of parameters of `f`.  The subexpression `e` gives the initial
value for the fold.  It must have a type which is a subtype `R`.  Each of the
vector subexpressions must have a vector type and all these vector types must
have the same length `n`.  If the type of the *i*+1th parameter of `f` is `T`
then the type of the *i*th vector subexpression must be `Vector<n, S>` where `S`
is a subtype of `T`.  The type of the entire expression is `R`.

Map expressions are evaluated by evaluating the vector subexpressions from left
to right.  These values are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to arguments taken from
the input vector values.  The result is a vector of length `n` where each *i*th
element is the result of applying `f` to the *i*th element of the corresponding
input vector values.

Fold expressions are evaluated by evaluating the initial value expression `e`
and then evaluating the vector subexpressions from left to right.  The values of
the vector expressions are the input vector values.  The witness or circuit `f`
is then applied in turn, from index 0 up to index `n`-1, to an accumulator value
argument and arguments taken from the input vector values.  The 0th (initial)
accumulator value is the value of the expression `e`, and each subsequent
*i*+1th accumulator value is the result of applying `f` to the *i*th accumulator
value and to the *i*th element of the corresponding input vector values.  The
result is the `n`th (final) accumulator value where `n` is the length of the
input vectors.

#### Ledger assignment expressions

Compact has ledger assignment statements.  They have the form `lhs op e` where
`lhs` is a ledger expression as defined in the section **Ledger expressions**
above, `op` is one of the assignment operators `=` (assignment), `+=` (addition
assignment), or `-=` (subtraction assignment), and `e` is an expression.

<table className="lang-ref-table"><tbody><tr><td><em>expr</em>&nbsp;&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>+=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr><tr><td>&nbsp;</td><td>→</td><td>&nbsp;&nbsp;<b><tt>ledger</tt></b>&nbsp;&nbsp;<b><tt>.</tt></b>&nbsp;&nbsp;<em>id</em>&nbsp;&nbsp;{<em>ledger-accessor</em>}&nbsp;&nbsp;<b><tt>-=</tt></b>&nbsp;&nbsp;<em>expr</em></td></tr></tbody></table>

`lhs = e` is shorthand for `lhs.write(e)`.  `lhs += e` is shorthand for
`lhs.increment(e)`.  `lhs -= e` is shorthand for `lhs.decrement(e)`.

Ledger assignment statements are type checked exactly as if they were their
longer equivalent invoking a ledger ADT operation.

They are evaluated exactly as if their longer equivalent were evaluated as a
ledger expression.

## Declaring witnesses for private state

Compact code can call code external to the zero-knowledge circuits to read
and update private state via `witness` functions.

A `witness` function declaration can appear anywhere a `circuit`
definition can appear, including within modules.  A witness function does not
have a body, and its implementation is instead an input to
the contract in the TypeScript target. For instance:

```compact
witness something(x: Boolean): Field;
```

A `witness` function can be called in the same way as a `circuit`.

:::danger

Do not assume in your contract that the code of any `witness` function
is the code that you wrote in your own implementation.  Any DApp may
provide any implementation that it wants for your `witness` functions.
Results from them should be treated as untrusted input.

:::

## Declaring and maintaining public state

Compact code can declare public state through `ledger` declarations.

A ledger declaration defines one piece of information the contract
stores in Midnight's public ledger.
Multiple ledger declarations can appear in a program, or none.
They can appear anywhere circuit definitions can appear,
including within modules.

A ledger declaration associates a ledger field name with one of a
set of predefined [ledger ADT types](#ledger-state-types)
For instance:

```compact
ledger val: Field;
export ledger cnt: Counter;
sealed ledger u8list: List<Uint<8>>;
export sealed ledger mapping: Map<Boolean, Field>;
```

### Ledger state types

In a `ledger` declaration, the following types are valid:

- `T`, for any Compact type `T`
- `Counter`
- `Set<T>`, for any Compact type `T`
- `Map<K, T>`, for any Compact types `K` and `T`
- `Map<K, V>`, for any Compact type `K` and ledger state type `V` (see the following section)
- `List<T>`, for any Compact type `T`
- `MerkleTree<n, T>`, for a compile time integer `1 < n <= 32`, and any Compact
  type `T`
- `HistoricMerkleTree<n, T>`, for a compile time integer `1 < n <= 32`, and any
  Compact type `T`

Each ledger type supports a set of operations, which can be invoked with

```compact
<field name>.<operation>(<arguments ...>)
```

A ledger field that is declared with a Compact type `T` implicitly has the type
`Cell<T>`. `Cell` has operations such as `read`, `write`, and `reset_to_default`.

The `read` and `write` operations for the `Cell` type of any Compact type `T` have syntactic
sugar. If `x` is a field in the ledger of any Compact type, then you may write

```compact
x       // expression equivalent to x.read()
x = val // statement equivalent to x.write(val)
```

The `read`, `increment`, and `decrement` operations of type `Counter` type also
have syntactic sugar.  If `c` is a `Counter` field in the ledger, then you may write

```compact
c        // expression equivalent to c.read()
c += val // statement equivalent to c.increment(val)
c -= val // statement equivalent to c.decrement(val)
```

A comprehensive list of operations can be found in
the Compact [ledger data type documentation](./ledger-adt).


### Nested state types in the `Map` type

The only ledger state type in which values of other state types may be
held is `Map`.  The key values in a `Map` must be non-state types
(simple Compact types), but the mapped values may be counters, sets,
lists, other maps, and so on.

Here is a small example:

```compact
import CompactStandardLibrary;

ledger fld: Map<Boolean, Map<Field, Counter>>;

export circuit initNestedMap(b: Boolean): [] {
  fld.insert(b, default<Map<Field, Counter>>);
}

export circuit initNestedCounter(b: Boolean, n: Field): [] {
  fld.lookup(b).insert(n, default<Counter>);
}

export circuit incrementNestedCounter(b: Boolean, n: Field, k: Uint<16>): [] {
  fld.lookup(b).lookup(n).increment(k);
}

export circuit readNestedCounter1(b: Boolean, n: Field): Uint<64> {
  return fld.lookup(b).lookup(n).read();
}

export circuit readNestedCounter2(b: Boolean, n: Field): Uint<64> {
  return fld.lookup(b).lookup(n);
}
```

In this example,
- `fld` is bound to a `Map` from `Boolean` values to `Map`s from `Field` values to `Counter`s
- `initNestedMap` can be used to create the inner `Map` for a particular outer-`Map` key
- `initNestedCounter` can be used to create a `Counter` for a given outer-`Map` key and a given inner-`Map` key
- `incrementNestedCounter` can be used to increment an existing `Counter` for a given outer-`Map` key and a given inner-`Map` key
- either `readNestedCounter1` or `readNestedCounter2` can be used to read the value of an existing `Counter`
  for a given outer-`Map` key and a given inner-`Map` key.

Notes:

1. Nesting is permitted only within `Map` values.  That is, nesting is not permitted in
   `Map` keys or within any ledger state type other than `Map`.
2. Nested values must be initialized before first use.  The syntax `default<T>`
   is used to create default ledger state type values, just as it can be used to
   create default Compact type values.
3. Ledger state type values are not first-class objects, so when
   accessing a nested value, the entire indirection chain must be
   used.  For example, the following will result in a compiler error:
   ```compact
   export circuit incrementNestedCounter(b: Boolean, n: Field, k: Uint<16>): [] {
     fld.lookup(b); // ERROR: incomplete chain of indirects 
   }
   ```
4. When the last lookup is a read of a base type one can omit the
   explicit `read()` indirect, as illustrated by the definitions of
   `readNestedCounter1` and `readNestedCounter2` above, which have the
   same behavior.
5. For convenience, local variables can hold default ledger state type values,
   so the following definition of `initNestedMap` is equivalent to the one
   above.
   ```compact
   export circuit initNestedMap(b: Boolean): [] {
     const t = default<Map<Field, Counter>>; 
     fld.insert(b, t); 
   }
   ```

### Sealed and unsealed ledger fields

Any ledger field can be optionally marked *sealed* by prefixing the
ledger field declaration with the keyword `sealed`.  A sealed field
cannot be set except during contract initialization.  That is, its
value can be modified only by the contract constructor (if any),
either directly within the body of the constructor or via helper
circuits called by the constructor. The `sealed` keyword must come after
the `export` keyword (if present) and before the `ledger` keyword, as
in the following example:

```compact
sealed ledger field1: Uint<32>;
export sealed ledger field2: Uint<32>;

circuit init(x: Uint<32>): [] {
  field2 = x;
}

constructor(x: Uint<16>) {
  field1 = 2 * x;
  init(x);
}
```

It is a static error if a sealed ledger field can be set by any
code that is reachable from an exported circuit.

## Contract constructor

A contract can be initialized via a contract constructor defined at the
program's top level.
The constructor, if any, is typically used to initialize public state
and can also be used to initialize private state through witness
calls.
A constructor can take zero or more arguments.
For example:

```compact
enum STATE { unset, set }
ledger state: STATE;
ledger value: Field;

constructor(v: Field) {
  value = v;
  state = STATE.set;
}
```

At most one contract constructor can be defined for a contract, and it
must appear only at the program top level, i.e., it cannot be defined in
a module.
To initialize ledger fields that are visible only within a module, the
constructor can call a circuit that is exported from the module.
For example:

```compact
module PublicState {
  enum STATE { unset, set }
  ledger state: STATE;
  ledger value: Field;
  export circuit init(v: Field): [] {
    value = v;
    state = STATE.set;
  }
}

import PublicState;

constructor(v: Field) {
  init(v);
}
```

### Runtime representations and type/bounds checks

The TypeScript type representing a Compact type is defined in [Representations
in TypeScript](#representations-in-typescript).

Compact represents values exactly as TypeScript represents values, i.e., as
ordinary JavaScript values.  So a Compact boolean is represented at run time
as a JavaScript boolean, a Compact tuple is represented as a JavaScript
array, and enum values are represented by numbers.

To maintain type safety, Compact verifies at run time that values
passed by an outside caller to an exported circuit or returned from an
outside witness have the expected types.
This is necessary even when the caller or witness is written in properly
typed TypeScript because some Compact types have size and range limits
that are not expressible via the TypeScript type system:

- `Field` values are limited by a maximum field value
- `Uint` values are limited by the declared bounds
- `Bytes` and tuple values are limited by their lengths
- enum values are limited by the maximum index for the enum elements 

It is also necessary because compile-time type checks are easily
defeated in TypeScript and are nonexistent when a caller or witness
is coded in JavaScript.

Certain values to be stored in public state require size, length, and other
properties to be maintained explicitly, because these properties cannot
be determined solely from the JavaScript representation of the value.
For this purpose, the `@midnight/compact-runtime` package provides explicit
runtime types satisfying the `CompactType<T>` interface, where `T` is the
corresponding TypeScript type.
This representation is *not* user-facing most of the time, except
when replicating the behavior of the operations implemented
in `@midnight/compact-runtime`.

The following constructors can be used to create a `CompactType` instance
for a primitive type:

- `Boolean` - `new CompactTypeBoolean()`
- `Field` - `new CompactTypeField()`
- `Uint<0..n>` - `new CompactTypeUnsignedInteger(n, length)`, where
  `length` is the number of bytes required to store `n`
- `Uint<n>` - as `Uint<0..(2 ** n) - 1>`
- `Bytes<n>` - `new CompactTypeBytes(n)`
- `Vector<n, T>` - `new CompactTypeVector(n, rt_T)`, where `rt_T` is the runtime
  type of `T`
- `Opaque<"String">` - `new CompactTypeString()`
- `Opaque<"Uint8Array">` - `new CompactTypeUint8Array()`.

For user-defined types, structures are not currently easily
constructed at runtime and require implementing `CompactType<T>`
manually or using compiler internals.  Enumerations are exposed
through `new CompactTypeEnum(maxValue, length)`, where `maxValue` is
the maximum permissible integer assignable, and `length` its
representation length in bytes (almost always 1).

## TypeScript target

When compiled, a contract generates several artifacts. Key to these
are the exported circuits from the contract's top level. These are
divided into two categories: [pure circuits and impure circuits](#pure-and-impure-circuits).

In the `contract` directory, the semantics of the contract is encoded in
TypeScript, in the form of a `index.cjs` JavaScript implementation file and a
`index.d.cts` type declaration file. For most uses, it is recommended to rely on the
information and interface provided in `index.d.cts`.

For each of the impure circuits, a zero-knowledge prover/verifier key pair is also
generated, as well as instructions for proof generation. These can be found
in the output directory's `keys` and `zkir` subdirectories respectively.

### Structure of the exported TypeScript

The exported TypeScript exposes a number of declarations that can be used
to interact with the contract from any TypeScript application. Some of these
also require use of the `@midnight/compact-runtime` library, which all
contracts depend upon and which implements key built-in behaviors.

A contract exports the following in the TypeScript module:

- The TypeScript type corresponding to each user-defined type exported from the
  contract's top level
- A `Witnesses<T>` type, which describes the format external witnesses must
  satisfy to instantiate the contract
- A `ImpureCircuits<T>` type, which describes the set of impure circuits exported
  from the contract's top level
- A `PureCircuits` type, which describes the set of pure circuits exported from
  the contract's top level
- A `Circuits<T>` type, which describes the set of all exported circuits
- A `Contract<T, W extends Witnesses<T> = Witnesses<T>>` class, which:
  - can be constructed by passing in an instance of `W`
  - exposes members `circuits: Circuits<T>` and `impureCircuits: ImpureCircuits<T>`
  - provides initial contract states via 
    `initialState(privateState: T): [T, runtime.ContractState]`
- A constant `pureCircuits: PureCircuits` object, providing all pure circuits
  as pure functions
- A `Ledger` type, providing views into a current ledger state, by permitting
  direct calls of all read functions of `ledger` objects, as well of some
  TypeScript specific ones that cannot be called from Compact, such as iterators
- A `ledger(state: runtime.StateValue): Ledger` constructor of the `Ledger` type,
  giving access to the values of exported ledger fields.

The argument `T` for a number of these should be interpreted as the type of the
local/private state. For the most part, `circuit` and `witness` functions are
translated simply by translating their Compact types into corresponding
TypeScript types for parameters and return values. For `PureCircuits`, this is
all that happens, for the other `_Circuits` instances, they receive an
additional first parameter of type `runtime.CircuitContext<T>`, and their
result type `R` is wrapped in `runtime.CircuitResults<T, R>`. For `Witnesses`,
they receive an additional first parameter of type
`runtime.WitnessContext<Ledger, T>`, and their result type `R` is wrapped in
`[T, R]`. See the [runtime API docs](/docs/develop/reference/midnight-api/compact-runtime/README.md) for the details of
these types. This wrapping makes the entirety of the contract code
*functional*, ensuring calls have no hidden side effects.
</file>

<file path="docs/develop/reference/compact/ledger-adt.mdx">
# Ledger data types

Compact language version 0.18.0, compiler version 0.26.0.

## Kernel

This ADT is a special ADT defining various built-in operations and valid only as a top-level ADT type.

### blockTimeGreaterThan

```compact
blockTimeGreaterThan(time: Uint<64>): Boolean
```

Checks whether the current block time (measured in seconds since the Unix epoch) is greater than the given amount.

### blockTimeLessThan

```compact
blockTimeLessThan(time: Uint<64>): Boolean
```

Checks whether the current block time (measured in seconds since the Unix epoch) is less than the given amount.

### checkpoint

```compact
checkpoint(): []
```

Marks all execution up to this point as being a single atomic unit, allowing partial transaction failures to be split across it.

### claimContractCall

```compact
claimContractCall(addr: Bytes<32>, entry_point: Bytes<32>, comm: Field): []
```

Require the presence of another contract call in the containing transaction, with a match address, entry point hash, and communication commitment, that is not claimed by any other call.

### claimZswapCoinReceive

```compact
claimZswapCoinReceive(note: Bytes<32>): []
```

Requires the presence of a commitment in the containing transaction and that no other call claims it as a receive.

### claimZswapCoinSpend

```compact
claimZswapCoinSpend(note: Bytes<32>): []
```

Requires the presence of a commitment in the containing transaction and that no other call claims it as a spend.

### claimZswapNullifier

```compact
claimZswapNullifier(nul: Bytes<32>): []
```

Requires the presence of a nullifier in the containing transaction and that no other call claims it.

### mint

```compact
mint(domain_sep: Bytes<32>, amount: Uint<64>): []
```

Mints a given amount of shielded coins with a token type derived from the contract's address, and a given domain separator.

### self

```compact
self(): ContractAddress
```

Returns the current contract's address.  ContractAddress is defined in CompactStandardLibrary.

## Cell\<value_type>

This ADT is a single Cell containing a value of type value_type and is used implicitly when the ledger field type is an ordinary Compact type. Programmers cannot write Cell explicitly when declaring a ledger field..

### read

```compact
read(): value_type
```

Returns the current contents of this Cell.

*available from Typescript as a getter on the ledger field*

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Cell to the default value of its type.

### write

```compact
write(value: value_type): []
```

Overwrites the content of this Cell with the given value.

### writeCoin

```compact
writeCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []
```

Writes a CoinInfo to this Cell, which is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this write fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

**available only for QualifiedCoinInfo value_type**

## Counter

This ADT is a simple counter.

### decrement

```compact
decrement(amount: Uint<16>): []
```

Decrements the counter by a given amount. Decrementing below zero results in a run-time error.

### increment

```compact
increment(amount: Uint<16>): []
```

Increments the counter by the given amount.

### lessThan

```compact
lessThan(threshold: Uint<64>): Boolean
```

Returns if the counter is less than the given threshold value.

### read

```compact
read(): Uint<64>
```

Retrieves the current value of the counter.

*available from Typescript as a getter on the ledger field*

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Counter to its default value of 0.

## Set\<value_type>

This ADT is an unbounded set of values of type value_type.

### insert

```compact
insert(elem: value_type): []
```

Updates this Set to include a given element.

### insertCoin

```compact
insertCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []
```

Inserts a CoinInfo into this Set, which is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this insertion fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

**available only for QualifiedCoinInfo value_type**

### isEmpty

```compact
isEmpty(): Boolean
```

Returns whether this Set is the empty set.

*available from Typescript as `isEmpty(): boolean`*

### member

```compact
member(elem: value_type): Boolean
```

Returns if an element is contained within this Set.

*available from Typescript as `member(elem: value_type): boolean`*

### remove

```compact
remove(elem: value_type): []
```

Update this Set to not include a given element.

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Set to the empty set.

### size

```compact
size(): Uint<64>
```

Returns the number of unique entries in this Set.

*available from Typescript as `size(): bigint`*

### [Symbol.iterator]

*callable only from TypeScript*

```typescript
[Symbol.iterator](): Iterator<value_type>
```

Iterates over the entries in this Set.

## Map\<key_type, value_type>

This ADT is an unbounded set of mappings between values of type key_type and values of type value_type.

### insert

```compact
insert(key: key_type, value: value_type): []
```

Updates this Map to include a new value at a given key.

### insertCoin

```compact
insertCoin(key: key_type, coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []
```

Inserts a CoinInfo into this Map at a given key, where the CoinInfo is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this insertion fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

**available only for QualifiedCoinInfo value_type**

### insertDefault

```compact
insertDefault(key: key_type): []
```

Updates this Map to include the value type's default value at a given key.

### isEmpty

```compact
isEmpty(): Boolean
```

Returns if this Map is the empty map.

*available from Typescript as `isEmpty(): boolean`*

### lookup

```compact
lookup(key: key_type): value_type
```

Looks up the value of a key within this Map. The returned value may be another ADT.

*available from Typescript as `lookup(key: key_type): value_type`*

### member

```compact
member(key: key_type): Boolean
```

Returns if a key is contained within this Map.

*available from Typescript as `member(key: key_type): boolean`*

### remove

```compact
remove(key: key_type): []
```

Updates this Map to not include a given key.

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Map to the empty map.

### size

```compact
size(): Uint<64>
```

Returns the number of entries in this Map.

*available from Typescript as `size(): bigint`*

### [Symbol.iterator]

*callable only from TypeScript*

```typescript
[Symbol.iterator](): Iterator<[key_type, value_type]>
```

Iterates over the key-value pairs contained in this Map.

## List\<value_type>

This ADT is an unbounded list of values of type value_type.

### head

```compact
head(): Maybe<value_type>
```

Retrieves the head of this List, returning a Maybe, ensuring this call succeeds on the empty list. Maybe is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

*available from Typescript as `head(): Maybe<value_type>`*

### isEmpty

```compact
isEmpty(): Boolean
```

Returns if this List is the empty list.

*available from Typescript as `isEmpty(): boolean`*

### length

```compact
length(): Uint<64>
```

Returns the number of elements contained in this List.

*available from Typescript as `length(): bigint`*

### popFront

```compact
popFront(): []
```

Removes the first element from the front of this list.

### pushFront

```compact
pushFront(value: value_type): []
```

Pushes a new element onto the front of this list.

### pushFrontCoin

```compact
pushFrontCoin(coin: CoinInfo, recipient: Either<ZswapCoinPublicKey, ContractAddress>): []
```

Pushes a CoinInfo onto the front of this List, where the CoinInfo is transformed into a QualifiedCoinInfo at runtime by looking up the relevant Merkle tree index. This index must have been allocated within the current transaction or this push fails. CoinInfo, ContractAddress, Either, and ZswapCoinPublicKey are defined in CompactStandardLibrary.

**available only for QualifiedCoinInfo value_type**

### resetToDefault

```compact
resetToDefault(): []
```

Resets this List to the empty list.

### [Symbol.iterator]

*callable only from TypeScript*

```typescript
[Symbol.iterator](): Iterator<value_type>
```

Iterates over the entries in this List.

## MerkleTree\<nat, value_type>

This ADT is a bounded Merkle tree of depth nat containing values of type value_type.

### checkRoot

```compact
checkRoot(rt: MerkleTreeDigest): Boolean
```

Tests if the given Merkle tree root is the root for this Merkle tree. MerkleTreeDigest is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

*available from Typescript as `checkRoot(rt: MerkleTreeDigest): boolean`*

### insert

```compact
insert(item: value_type): []
```

Inserts a new leaf at the first free index in this Merkle tree.

### insertHash

```compact
insertHash(hash: Bytes<32>): []
```

Inserts a new leaf with a given hash at the first free index in this Merkle tree.

### insertHashIndex

```compact
insertHashIndex(hash: Bytes<32>, index: Uint<64>): []
```

Inserts a new leaf with a given hash at a specific index in this Merkle tree.

### insertIndex

```compact
insertIndex(item: value_type, index: Uint<64>): []
```

Inserts a new leaf at a specific index in this Merkle tree.

### insertIndexDefault

```compact
insertIndexDefault(index: Uint<64>): []
```

Inserts a default value leaf at a specific index in this Merkle tree. This can be used to emulate a removal from the tree.

### isFull

```compact
isFull(): Boolean
```

Returns if this Merkle tree is full and further items cannot be directly inserted.

*available from Typescript as `isFull(): boolean`*

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Merkle tree to the empty Merkle tree.

### findPathForLeaf

*callable only from TypeScript*

```typescript
findPathForLeaf(leaf: value_type): MerkleTreePath<value_type> | undefined
```

Finds the path for a given leaf in a Merkle tree. Be warned that this is O(n) and should be avoided for large trees. Returns undefined if no such leaf exists. MerkleTreePath is defined in compact-runtime runtime.ts.

### firstFree

*callable only from TypeScript*

```typescript
firstFree(): bigint
```

Retrieves the first (guaranteed) free index in the Merkle tree.

### pathForLeaf

*callable only from TypeScript*

```typescript
pathForLeaf(index: bigint, leaf: value_type): MerkleTreePath<value_type>
```

Returns the Merkle path, given the knowledge that a specified leaf is at the given index. It is an error to call this if this leaf is not contained at the given index. MerkleTreePath is defined in compact-runtime runtime.ts.

### root

*callable only from TypeScript*

```typescript
root(): MerkleTreeDigest
```

Retrieves the root of the Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.

## HistoricMerkleTree\<nat, value_type>

This ADT is a bounded Merkle tree of depth nat containing values of type value_type, with history.

### checkRoot

```compact
checkRoot(rt: MerkleTreeDigest): Boolean
```

Tests if the given Merkle tree root is one of the past roots for this Merkle tree. MerkleTreeDigest is defined in CompactStandardLibrary (compact-runtime runtime.ts from Typescript).

*available from Typescript as `checkRoot(rt: MerkleTreeDigest): boolean`*

### insert

```compact
insert(item: value_type): []
```

Inserts a new leaf at the first free index in this Merkle tree.

### insertHash

```compact
insertHash(hash: Bytes<32>): []
```

Inserts a new leaf with a given hash at the first free index in this Merkle tree.

### insertHashIndex

```compact
insertHashIndex(hash: Bytes<32>, index: Uint<64>): []
```

Inserts a new leaf with a given hash at a specific index in this Merkle tree.

### insertIndex

```compact
insertIndex(item: value_type, index: Uint<64>): []
```

Inserts a new leaf at a specific index in this Merkle tree.

### insertIndexDefault

```compact
insertIndexDefault(index: Uint<64>): []
```

Inserts a default value leaf at a specific index in this Merkle tree. This can be used to emulate a removal from the tree.

### isFull

```compact
isFull(): Boolean
```

Returns if this Merkle tree is full and further items cannot be directly inserted.

*available from Typescript as `isFull(): boolean`*

### resetHistory

```compact
resetHistory(): []
```

Resets the history for this Merkle tree, leaving only the current root valid.

### resetToDefault

```compact
resetToDefault(): []
```

Resets this Merkle tree to the empty Merkle tree.

### findPathForLeaf

*callable only from TypeScript*

```typescript
findPathForLeaf(leaf: value_type): MerkleTreePath<value_type> | undefined
```

Finds the path for a given leaf in a Merkle tree. Be warned that this is O(n) and should be avoided for large trees. Returns undefined if no such leaf exists. 
    MerkleTreePath is defined in compact-runtime runtime.ts.

### firstFree

*callable only from TypeScript*

```typescript
firstFree(): bigint
```

Retrieves the first (guaranteed) free index in the Merkle tree.

### history

*callable only from TypeScript*

```typescript
history(): Iterator<MerkleTreeDigest>
```

An iterator over the roots that are considered valid past roots for this Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.

### pathForLeaf

*callable only from TypeScript*

```typescript
pathForLeaf(index: bigint, leaf: value_type): MerkleTreePath<value_type>
```

Returns the Merkle path, given the knowledge that a specified leaf is at the given index. It is an error to call this if this leaf is not contained at the given index. MerkleTreePath is defined in compact-runtime runtime.ts.

### root

*callable only from TypeScript*

```typescript
root(): MerkleTreeDigest
```

Retrieves the root of the Merkle tree. MerkleTreeDigest is defined in compact-runtime runtime.ts.
</file>

<file path="docs/develop/reference/compact/opaque_data.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Opaque data types

Data types whose representations are visible are called transparent. These expose the inner structure of the data so that operations on the data can be understood.

Drawbacks to having transparent data types include lesser type safety (or type soundness) - how a programming language discourages or prevents type errors, such as assigning the wrong type to a variable.

Opaque data types present an interface without sharing the actual, concrete data structure. These can only be manipulated by calling subroutines that have access to knowledge about the missing structure.

The principle of information hiding, segregating design decisions from the underlying software implementation, results in more resilient code. Implementations can be improved or changed completely without the fragility that comes from inner details being depended upon. Defensively coding the parts most likely to change results in more robust code overall.

# Midnight opaque data types

Opaque types in Compact are a compact type system feature that allow "foreign" JavaScript data to be stored, passed around, and retrieved on behalf of a DApp (but not inspected by Compact code).

Midnight’s Compact language currently supports `Opaque<'string'>` and `Opaque<'Uint8Array'>`. These can be stored in a contract's public state.

NOTE: These are opaque only within Compact. They are transparent in a DApp's JavaScript code. Their representation on-chain is **NOT** hidden - `Uint8Array` is represented by the array of bytes and `string` is represented by its UTF-8 encoding.

# Examples

The Bulletin Board example DApp, in the developer tutorial, has an example of opaque data type usage.

* The Compact post circuit is a contract entry point that's called from a DApp and passed an `Opaque<'string'>`. Compact code can't look inside this; it does store it in the contract's public state.

* Later, the Compact take_down circuit reads this value and returns it to the JavaScript or TypeScript caller.
</file>

<file path="docs/develop/reference/compact/writing.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Writing a contract

Midnight comes with its own programming language,
[*Compact*](/docs/learn/04-glossary.mdx#compact), which enables you to
write smart contracts as described in
[the overview](/docs/develop/how-midnight-works/smart-contracts.mdx).
The Compact compiler outputs zero-knowledge circuits that are used to
prove the correctness of interactions with the 
[*ledger*](/docs/learn/04-glossary.mdx#ledger).
This page walks
through the construction of a simple smart contract, which manages a
publicly accessible value and supports the operations `get`, `set`,
and `clear`.  Because the value is public, anyone can call `get`, but if
the value is currently set, only the user that last called `set` can
`clear` it, and it must be `clear`ed before `set`ting it again.

To start, the contract specifies the version of the language it is using,
imports Midnight's standard libraries,
and declares an `enum` for the state it may currently be in:

```compact title=lock.compact
pragma language_version 0.16;

import CompactStandardLibrary;

enum State {
  UNSET,
  SET
}
```

In addition to the `enum` declaration, custom data can also be defined with
`struct`s.  Details can be found in the 
[language reference](./lang-ref.mdx#user-defined-types).

## The `ledger` section

A key part of a Compact smart contract is the `ledger` section, which describes
the state kept on chain. This example stores a key that can be used to identify the user who is permitted to
`clear` the value, the value itself (this example uses a 64-bit unsigned integer), and what state the contract is in.

In addition to these, it is necessary to add a `round` counter, which is useful to retain
anonymity, as discussed [below](#basic-confidentiality).

Each field in a smart contract's on-chain state is declared with a `ledger` declaration.
A constructor can be used to initialize the ledger fields when the contract is deployed.
In this case, the ledger declarations are as follows:

```compact title=lock.compact
export ledger authority: Bytes<32>;

export ledger value: Uint<64>;

export ledger state: State;

export ledger round: Counter;

constructor(sk: Bytes<32>, v: Uint<64>) {
  authority = disclose(publicKey(round, sk));
  value = disclose(v);
  state = State.SET;
}

circuit publicKey(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "midnight:examples:lock:pk"), round as Bytes<32>, sk]);
}
```

In addition to the `ledger` section, the `constructor` also demonstrates basic
interaction with the state contained in it, using the field names to refer to
the items in the ledger's state. Many ledger types also support *operations* as
demonstrated in `clear`.

## The `circuit` definitions

The example above already demonstrates use of a `circuit` to calculate the
`publicKey` of a user. A `circuit` in Compact is equivalent to a function in many
programming languages, but it is restricted to fixed computational bounds at
compile time.  A smart contract's `circuit`s can also be its main entry points;
they are what users can call directly in transactions. Of the three entry points mentioned above, `get` is *unrestricted* and is simply implemented as
follows:

```compact title=lock.compact
export circuit get(): Uint<64> {
  assert(state == State.SET, "Attempted to get uninitialized value");
  return value;
}
```

Here `export` marks this circuit as an entry point to the smart contract, and
`assert` ensures that it can only be used when the contract is in the correct
state. The [language reference](./lang-ref.mdx#circuits) details permissible contents
of `circuit`s.

## Local state and computations

The third context mentioned was the local machine of the user. This is
explicitly programmable in the form of the DApp running on the
user's machine.  Compact can 'call out' to the local context through
*witnesses*[^1], which are declared in a similar way to circuits. In this case, retrieving a user's
*secret key* requires such a witness, because the secret must be kept local to a user's
machine.

The code for this follows:

```compact title=lock.compact
witness secretKey(): Bytes<32>;

export circuit set(v: Uint<64>): [] {
  assert(state == State.UNSET, "Attempted to set initialized value");
  const sk = secretKey();
  const pk = publicKey(round, sk);
  authority = disclose(pk);
  value = disclose(v);
  state = State.SET;
}

export circuit clear(): [] {
  assert(state == State.SET, "Attempted to clear uninitialized value");
  const sk = secretKey();
  const pk = publicKey(round, sk);
  assert(authority == pk, "Attempted to clear without authorization");
  state = State.UNSET;
  round.increment(1);
}
```

Note that the `witness` is not implemented in the Compact source code.
Instead, the implementation is the responsibility of the TypeScript
code of the DApp. It's important to note that each user could
reasonably use a different implementation for the `witness`, so its
results cannot be trusted inherently by the contract.

## The full contract

All put together, the full example is:

```compact title=lock.compact
pragma language_version 0.16;

import CompactStandardLibrary;

enum State {
  UNSET,
  SET
}

export ledger authority: Bytes<32>;

export ledger value: Uint<64>;

export ledger state: State;

export ledger round: Counter;

constructor(sk: Bytes<32>, v: Uint<64>) {
  authority = disclose(publicKey(round, sk));
  value = disclose(v);
  state = State.SET;
}

circuit publicKey(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "midnight:examples:lock:pk"), round as Bytes<32>, sk]);
}

export circuit get(): Uint<64> {
  assert(state == State.SET, "Attempted to get uninitialized value");
  return value;
}

witness secretKey(): Bytes<32>;

export circuit set(v: Uint<64>): [] {
  assert(state == State.UNSET, "Attempted to set initialized value");
  const sk = secretKey();
  const pk = publicKey(round, sk);
  authority = disclose(pk);
  value = disclose(v);
  state = State.SET;
}

export circuit clear(): [] {
  assert(state == State.SET, "Attempted to clear uninitialized value");
  const sk = secretKey();
  const pk = publicKey(round, sk);
  assert(authority == pk, "Attempted to clear without authorization");
  state = State.UNSET;
  round.increment(1);
}
```

## Basic confidentiality

It may not be immediately apparent what is held confidential in this example
and what is enforced in the contract. Thankfully, both are well-defined:
- all data that is not a ledger field and is not an argument or return value of a ledger operation is kept confidential
- all computation that is not done in a `witness` function is enforced to be
  correct.

In particular, observe that this keeps the `secretKey` output confidential,
while enforcing that *its hash* is the correct value in the case of `clear`.

This is also the reason for the `round` parameter: The `pk` "public key"
*isn't* confidential, and would allow linkability between the same user
publishing data in multiple rounds. By adding a round parameter into the public
key computation, this linkability is broken.

Despite the terms "secret key" and "public key", these two keys are *not*
public key cryptography: they are simply a binary string and its hash. This is
due to zero-knowledge circuits being able to have similar effects to digital
signatures, relying only on the preimage resistance of hashes.

This pattern of hashing an arbitrary binary string and using it as a key is
quite powerful. A similar concept that can be very useful is the use of
[*commitment schemes*](../..//how-midnight-works/keeping-data-private.mdx),
where arbitrary data is hashed together with a random
*nonce*. The result can be safely placed into the ledger's state, without
revealing the original data. (Note that the nonce *must* not be reused. If it
is, you can link the commitments with the same nonces and values.) At a later
point, the commitment can be "opened" by revealing the value and nonce, or a
contract can simply prove (`assert`) that it *has* the correct value and nonce,
without ever revealing them.

The `CompactStandardLibrary` module provides the following circuits for such uses:
```compact title=standard-library.compact
circuit transientHash<T>(value: T): Field;
circuit transientCommit<T>(value: T, rand: Field): Field;
circuit persistentHash<T>(value: T): Bytes<32>;
circuit persistentCommit<T>(value: T, rand: Bytes<32>): Bytes<32>;
```

The `*Hash` variants are the basic hash function, with `*Commit` being a
commitment function to arbitrary data. The `transient*` functions should only
be used when the values are *not* kept in state, while `persistent*` outputs
being suitable for storage in a contract's `ledger` state.

## Next steps

This section continues with a more detailed overview of the Compact language.
Alternatively, you may wish to jump to a [more detailed example](/docs/develop/tutorial/index.mdx)
that showcases some more interesting things you can do with a DApp on Midnight.
While this section has focused on the Compact language,
the section about [how Midnight works](/docs/develop/how-midnight-works/index.mdx)
provides more detail about Midnight's ledger and how it functions.

[^1] The name *witness* comes from zero-knowledge literature; the etymology is
roughly that it's the evidence you need to believe a statement. In this
example, it's the evidence you need to believe that a `clear` was permissible.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactError.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactError

# Class: CompactError

An error originating from code generated by the Compact compiler

## Extends

- `Error`

## Constructors

### Constructor

```ts
new CompactError(msg): CompactError;
```

#### Parameters

##### msg

`string`

#### Returns

`CompactError`

#### Overrides

```ts
Error.constructor
```

## Properties

### message

```ts
message: string;
```

#### Inherited from

```ts
Error.message
```

***

### name

```ts
name: string;
```

#### Inherited from

```ts
Error.name
```

***

### stack?

```ts
optional stack: string;
```

#### Inherited from

```ts
Error.stack
```

***

### stackTraceLimit

```ts
static stackTraceLimit: number;
```

The `Error.stackTraceLimit` property specifies the number of stack frames
collected by a stack trace (whether generated by `new Error().stack` or
`Error.captureStackTrace(obj)`).

The default value is `10` but may be set to any valid JavaScript number. Changes
will affect any stack trace captured _after_ the value has been changed.

If set to a non-number value, or set to a negative number, stack traces will
not capture any frames.

#### Inherited from

```ts
Error.stackTraceLimit
```

## Methods

### captureStackTrace()

```ts
static captureStackTrace(targetObject, constructorOpt?): void;
```

Creates a `.stack` property on `targetObject`, which when accessed returns
a string representing the location in the code at which
`Error.captureStackTrace()` was called.

```js
const myObject = {};
Error.captureStackTrace(myObject);
myObject.stack;  // Similar to `new Error().stack`
```

The first line of the trace will be prefixed with
`${myObject.name}: ${myObject.message}`.

The optional `constructorOpt` argument accepts a function. If given, all frames
above `constructorOpt`, including `constructorOpt`, will be omitted from the
generated stack trace.

The `constructorOpt` argument is useful for hiding implementation
details of error generation from the user. For instance:

```js
function a() {
  b();
}

function b() {
  c();
}

function c() {
  // Create an error without stack trace to avoid calculating the stack trace twice.
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  const error = new Error();
  Error.stackTraceLimit = stackTraceLimit;

  // Capture the stack trace above function b
  Error.captureStackTrace(error, b); // Neither function c, nor b is included in the stack trace
  throw error;
}

a();
```

#### Parameters

##### targetObject

`object`

##### constructorOpt?

`Function`

#### Returns

`void`

#### Inherited from

```ts
Error.captureStackTrace
```

***

### prepareStackTrace()

```ts
static prepareStackTrace(err, stackTraces): any;
```

#### Parameters

##### err

`Error`

##### stackTraces

`CallSite`[]

#### Returns

`any`

#### See

https://v8.dev/docs/stack-trace-api#customizing-stack-traces

#### Inherited from

```ts
Error.prepareStackTrace
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeBoolean.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeBoolean

# Class: CompactTypeBoolean

Runtime type of the builtin `Boolean` type

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`boolean`\>

## Constructors

### Constructor

```ts
new CompactTypeBoolean(): CompactTypeBoolean;
```

#### Returns

`CompactTypeBoolean`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): boolean;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`boolean`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`boolean`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeBytes.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeBytes

# Class: CompactTypeBytes

Runtime type of the builtin `Bytes` types

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`Uint8Array`\>

## Constructors

### Constructor

```ts
new CompactTypeBytes(length): CompactTypeBytes;
```

#### Parameters

##### length

`number`

#### Returns

`CompactTypeBytes`

## Properties

### length

```ts
readonly length: number;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): Uint8Array;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`Uint8Array`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`Uint8Array`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeCurvePoint.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeCurvePoint

# Class: CompactTypeCurvePoint

Runtime type of [CurvePoint](../interfaces/CurvePoint.md)

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<[`CurvePoint`](../interfaces/CurvePoint.md)\>

## Constructors

### Constructor

```ts
new CompactTypeCurvePoint(): CompactTypeCurvePoint;
```

#### Returns

`CompactTypeCurvePoint`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): CurvePoint;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

[`CurvePoint`](../interfaces/CurvePoint.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

[`CurvePoint`](../interfaces/CurvePoint.md)

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeEnum.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeEnum

# Class: CompactTypeEnum

Runtime type of an enum with a given number of entries

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`number`\>

## Constructors

### Constructor

```ts
new CompactTypeEnum(maxValue, length): CompactTypeEnum;
```

#### Parameters

##### maxValue

`number`

##### length

`number`

#### Returns

`CompactTypeEnum`

## Properties

### length

```ts
readonly length: number;
```

***

### maxValue

```ts
readonly maxValue: number;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): number;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`number`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`number`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeField.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeField

# Class: CompactTypeField

Runtime type of the builtin `Field` type

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`bigint`\>

## Constructors

### Constructor

```ts
new CompactTypeField(): CompactTypeField;
```

#### Returns

`CompactTypeField`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): bigint;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`bigint`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`bigint`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeMerkleTreeDigest.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeMerkleTreeDigest

# Class: CompactTypeMerkleTreeDigest

Runtime type of [MerkleTreeDigest](../interfaces/MerkleTreeDigest.md)

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<[`MerkleTreeDigest`](../interfaces/MerkleTreeDigest.md)\>

## Constructors

### Constructor

```ts
new CompactTypeMerkleTreeDigest(): CompactTypeMerkleTreeDigest;
```

#### Returns

`CompactTypeMerkleTreeDigest`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): MerkleTreeDigest;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

[`MerkleTreeDigest`](../interfaces/MerkleTreeDigest.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

[`MerkleTreeDigest`](../interfaces/MerkleTreeDigest.md)

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeMerkleTreePath.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeMerkleTreePath

# Class: CompactTypeMerkleTreePath\<a\>

Runtime type of [MerkleTreePath](../interfaces/MerkleTreePath.md)

## Type Parameters

### a

`a`

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<[`MerkleTreePath`](../interfaces/MerkleTreePath.md)\<`a`\>\>

## Constructors

### Constructor

```ts
new CompactTypeMerkleTreePath<a>(n, leaf): CompactTypeMerkleTreePath<a>;
```

#### Parameters

##### n

`number`

##### leaf

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

#### Returns

`CompactTypeMerkleTreePath`\<`a`\>

## Properties

### leaf

```ts
readonly leaf: CompactType<a>;
```

***

### path

```ts
readonly path: CompactTypeVector<MerkleTreePathEntry>;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): MerkleTreePath<a>;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

[`MerkleTreePath`](../interfaces/MerkleTreePath.md)\<`a`\>

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

[`MerkleTreePath`](../interfaces/MerkleTreePath.md)\<`a`\>

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeMerkleTreePathEntry.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeMerkleTreePathEntry

# Class: CompactTypeMerkleTreePathEntry

Runtime type of [MerkleTreePathEntry](../interfaces/MerkleTreePathEntry.md)

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<[`MerkleTreePathEntry`](../interfaces/MerkleTreePathEntry.md)\>

## Constructors

### Constructor

```ts
new CompactTypeMerkleTreePathEntry(): CompactTypeMerkleTreePathEntry;
```

#### Returns

`CompactTypeMerkleTreePathEntry`

## Properties

### bool

```ts
readonly bool: CompactTypeBoolean;
```

***

### digest

```ts
readonly digest: CompactTypeMerkleTreeDigest;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): MerkleTreePathEntry;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

[`MerkleTreePathEntry`](../interfaces/MerkleTreePathEntry.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

[`MerkleTreePathEntry`](../interfaces/MerkleTreePathEntry.md)

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeOpaqueString.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeOpaqueString

# Class: CompactTypeOpaqueString

Runtime type of `Opaque["string"]`

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`string`\>

## Constructors

### Constructor

```ts
new CompactTypeOpaqueString(): CompactTypeOpaqueString;
```

#### Returns

`CompactTypeOpaqueString`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): string;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`string`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`string`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeOpaqueUint8Array.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeOpaqueUint8Array

# Class: CompactTypeOpaqueUint8Array

Runtime type of `Opaque["Uint8Array"]`

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`Uint8Array`\>

## Constructors

### Constructor

```ts
new CompactTypeOpaqueUint8Array(): CompactTypeOpaqueUint8Array;
```

#### Returns

`CompactTypeOpaqueUint8Array`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): Uint8Array;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`Uint8Array`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`Uint8Array`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeUnsignedInteger.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeUnsignedInteger

# Class: CompactTypeUnsignedInteger

Runtime type of the builtin `Unsigned Integer` types

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`bigint`\>

## Constructors

### Constructor

```ts
new CompactTypeUnsignedInteger(maxValue, length): CompactTypeUnsignedInteger;
```

#### Parameters

##### maxValue

`bigint`

##### length

`number`

#### Returns

`CompactTypeUnsignedInteger`

## Properties

### length

```ts
readonly length: number;
```

***

### maxValue

```ts
readonly maxValue: bigint;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): bigint;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`bigint`

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`bigint`

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CompactTypeVector.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactTypeVector

# Class: CompactTypeVector\<a\>

Runtime type of the builtin `Vector` types

## Type Parameters

### a

`a`

## Implements

- [`CompactType`](../interfaces/CompactType.md)\<`a`[]\>

## Constructors

### Constructor

```ts
new CompactTypeVector<a>(length, type): CompactTypeVector<a>;
```

#### Parameters

##### length

`number`

##### type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

#### Returns

`CompactTypeVector`\<`a`\>

## Properties

### length

```ts
readonly length: number;
```

***

### type

```ts
readonly type: CompactType<a>;
```

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`alignment`](../interfaces/CompactType.md#alignment)

***

### fromValue()

```ts
fromValue(value): a[];
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`a`[]

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`fromValue`](../interfaces/CompactType.md#fromvalue)

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`a`[]

#### Returns

[`Value`](../type-aliases/Value.md)

#### Implementation of

[`CompactType`](../interfaces/CompactType.md).[`toValue`](../interfaces/CompactType.md#tovalue)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/ContractMaintenanceAuthority.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractMaintenanceAuthority

# Class: ContractMaintenanceAuthority

A committee permitted to make changes to this contract. If a threshold of
the public keys in this committee sign off, they can change the rules of
this contract, or recompile it for a new version.

If the threshold is greater than the number of committee members, it is
impossible for them to sign anything.

## Constructors

### Constructor

```ts
new ContractMaintenanceAuthority(
   committee, 
   threshold, 
   counter?): ContractMaintenanceAuthority;
```

Constructs a new authority from its components

If not supplied, `counter` will default to `0n`. Values should be
non-negative, and at most 2^32 - 1.

At deployment, `counter` must be `0n`, and any subsequent update should
set counter to exactly one greater than the current value.

#### Parameters

##### committee

`string`[]

##### threshold

`number`

##### counter?

`bigint`

#### Returns

`ContractMaintenanceAuthority`

## Properties

### committee

```ts
readonly committee: string[];
```

The committee public keys

***

### counter

```ts
readonly counter: bigint;
```

The replay protection counter

***

### threshold

```ts
readonly threshold: number;
```

How many keys must sign rule changes

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array;
```

#### Parameters

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState;
```

#### Parameters

##### raw

`Uint8Array`

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractState`](ContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/ContractOperation.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractOperation

# Class: ContractOperation

An individual operation, or entry point of a contract, consisting primarily
of a ZK verifier keys, potentially for different versions of the proving
system.

Only the latest available version is exposed to this API.

Note that the serialized form of the key is checked on initialization

## Constructors

### Constructor

```ts
new ContractOperation(): ContractOperation;
```

#### Returns

`ContractOperation`

## Properties

### verifierKey

```ts
verifierKey: Uint8Array;
```

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array;
```

#### Parameters

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractOperation;
```

#### Parameters

##### raw

`Uint8Array`

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`ContractOperation`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/ContractState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractState

# Class: ContractState

The state of a contract, consisting primarily of the [data](#data) accessible
directly to the contract, and the map of [ContractOperation](ContractOperation.md)s that can
be called on it, the keys of which can be accessed with [operations](#operations),
and the individual operations can be read with [operation](#operation) and written
to with [setOperation](#setoperation).

## Constructors

### Constructor

```ts
new ContractState(): ContractState;
```

Creates a blank contract state

#### Returns

`ContractState`

## Properties

### data

```ts
data: StateValue;
```

The current value of the primary state of the contract

***

### maintenanceAuthority

```ts
maintenanceAuthority: ContractMaintenanceAuthority;
```

The maintenance authority associated with this contract

## Methods

### operation()

```ts
operation(operation): undefined | ContractOperation;
```

Get the operation at a specific entry point name

#### Parameters

##### operation

`string` | `Uint8Array`\<`ArrayBufferLike`\>

#### Returns

`undefined` \| [`ContractOperation`](ContractOperation.md)

***

### operations()

```ts
operations(): (string | Uint8Array<ArrayBufferLike>)[];
```

Return a list of the entry points currently registered on this contract

#### Returns

(`string` \| `Uint8Array`\<`ArrayBufferLike`\>)[]

***

### query()

```ts
query(query, cost_model): GatherResult[];
```

Runs a series of operations against the current state, and returns the
results

#### Parameters

##### query

[`Op`](../type-aliases/Op.md)\<`null`\>[]

##### cost\_model

[`CostModel`](CostModel.md)

#### Returns

[`GatherResult`](../type-aliases/GatherResult.md)[]

***

### serialize()

```ts
serialize(networkid): Uint8Array;
```

#### Parameters

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### setOperation()

```ts
setOperation(operation, value): void;
```

Set a specific entry point name to contain a given operation

#### Parameters

##### operation

`string` | `Uint8Array`\<`ArrayBufferLike`\>

##### value

[`ContractOperation`](ContractOperation.md)

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState;
```

#### Parameters

##### raw

`Uint8Array`

##### networkid

[`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`ContractState`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/CostModel.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CostModel

# Class: CostModel

A cost model for calculating transaction fees

## Methods

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### dummyCostModel()

```ts
static dummyCostModel(): CostModel;
```

A cost model for use in non-critical contexts

#### Returns

`CostModel`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/QueryContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / QueryContext

# Class: QueryContext

Provides the information needed to fully process a transaction, including
information about the rest of the transaction, and the state of the chain at
the time of execution.

## Constructors

### Constructor

```ts
new QueryContext(state, address): QueryContext;
```

Construct a basic context from a contract's address and current state
value

#### Parameters

##### state

[`StateValue`](StateValue.md)

##### address

`string`

#### Returns

`QueryContext`

## Properties

### address

```ts
readonly address: string;
```

The address of the contract

***

### block

```ts
block: BlockContext;
```

The block-level information accessible to the contract

***

### comIndicies

```ts
readonly comIndicies: Map<string, bigint>;
```

The commitment indices map accessible to the contract, primarily via
[qualify](#qualify)

***

### effects

```ts
effects: Effects;
```

The effects that occurred during execution against this context, should
match those declared in a [Transcript](../type-aliases/Transcript.md)

***

### state

```ts
readonly state: StateValue;
```

The current contract state retained in the context

## Methods

### insertCommitment()

```ts
insertCommitment(comm, index): QueryContext;
```

Register a given coin commitment as being accessible at a specific index,
for use when receiving coins in-contract, and needing to record their
index to later spend them

#### Parameters

##### comm

`string`

##### index

`bigint`

#### Returns

`QueryContext`

***

### ~~intoTranscript()~~

```ts
intoTranscript(program, cost_model): [
  | undefined
  | Transcript<AlignedValue>, 
  | undefined
  | Transcript<AlignedValue>];
```

Finalizes a sequence of operations against their initial context,
resulting in a guaranteed and fallible [Transcript](../type-aliases/Transcript.md), optimally
allocated, and heuristically covered for gas fees.

#### Parameters

##### program

[`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

##### cost\_model

[`CostModel`](CostModel.md)

#### Returns

\[
  \| `undefined`
  \| `Transcript`\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>, 
  \| `undefined`
  \| `Transcript`\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>\]

#### Deprecated

Please use the ledger's `partitionTranscripts` instead.

***

### qualify()

```ts
qualify(coin): undefined | Value;
```

**`Internal`**

Internal counterpart to [insertCommitment](#insertcommitment); upgrades an encoded
[CoinInfo](../type-aliases/CoinInfo.md) to an encoded [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) using the
inserted commitments

#### Parameters

##### coin

[`Value`](../type-aliases/Value.md)

#### Returns

`undefined` \| [`Value`](../type-aliases/Value.md)

***

### query()

```ts
query(
   ops, 
   cost_model, 
   gas_limit?): QueryResults;
```

Runs a sequence of operations in gather mode, returning the results of the
gather.

#### Parameters

##### ops

[`Op`](../type-aliases/Op.md)\<`null`\>[]

##### cost\_model

[`CostModel`](CostModel.md)

##### gas\_limit?

`bigint`

#### Returns

[`QueryResults`](QueryResults.md)

***

### runTranscript()

```ts
runTranscript(transcript, cost_model): QueryContext;
```

Runs a transcript in verifying mode against the current query context,
outputting a new query context, with the [state](#state) and [effects](#effects)
from after the execution.

#### Parameters

##### transcript

`Transcript`\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>

##### cost\_model

[`CostModel`](CostModel.md)

#### Returns

`QueryContext`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/QueryResults.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / QueryResults

# Class: QueryResults

The results of making a query against a specific state or context

## Properties

### context

```ts
readonly context: QueryContext;
```

The context state after executing the query. This can be used to execute
further queries

***

### events

```ts
readonly events: GatherResult[];
```

Any events/results that occurred during or from the query

***

### gasCost

```ts
readonly gasCost: bigint;
```

The measured cost of executing the query

## Methods

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/StateBoundedMerkleTree.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / StateBoundedMerkleTree

# Class: StateBoundedMerkleTree

Represents a fixed-depth Merkle tree storing hashed data, whose preimages
are unknown

## Constructors

### Constructor

```ts
new StateBoundedMerkleTree(height): StateBoundedMerkleTree;
```

Create a blank tree with the given height

#### Parameters

##### height

`number`

#### Returns

`StateBoundedMerkleTree`

## Properties

### height

```ts
readonly height: number;
```

## Methods

### collapse()

```ts
collapse(start, end): StateBoundedMerkleTree;
```

**`Internal`**

Erases all but necessary hashes between, and inclusive of, `start` and
`end` inidices

#### Parameters

##### start

`bigint`

##### end

`bigint`

#### Returns

`StateBoundedMerkleTree`

#### Throws

If the indices are out-of-bounds for the tree, or `end < start`

***

### findPathForLeaf()

```ts
findPathForLeaf(leaf): AlignedValue;
```

**`Internal`**

Internal implementation of the finding path primitive

#### Parameters

##### leaf

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the leaf is not in the tree

***

### pathForLeaf()

```ts
pathForLeaf(index, leaf): AlignedValue;
```

**`Internal`**

Internal implementation of the path construction primitive

#### Parameters

##### index

`bigint`

##### leaf

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the index is out-of-bounds for the tree

***

### root()

```ts
root(): Value;
```

**`Internal`**

Internal implementation of the merkle tree root primitive

#### Returns

[`Value`](../type-aliases/Value.md)

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### update()

```ts
update(index, leaf): StateBoundedMerkleTree;
```

Inserts a value into the Merkle tree, returning the updated tree

#### Parameters

##### index

`bigint`

##### leaf

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`StateBoundedMerkleTree`

#### Throws

If the index is out-of-bounds for the tree
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/StateMap.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / StateMap

# Class: StateMap

Represents a key-value map, where keys are [AlignedValue](../type-aliases/AlignedValue.md)s, and values
are [StateValue](StateValue.md)s.

## Constructors

### Constructor

```ts
new StateMap(): StateMap;
```

#### Returns

`StateMap`

## Methods

### get()

```ts
get(key): undefined | StateValue;
```

#### Parameters

##### key

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### insert()

```ts
insert(key, value): StateMap;
```

#### Parameters

##### key

[`AlignedValue`](../type-aliases/AlignedValue.md)

##### value

[`StateValue`](StateValue.md)

#### Returns

`StateMap`

***

### keys()

```ts
keys(): AlignedValue[];
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)[]

***

### remove()

```ts
remove(key): StateMap;
```

#### Parameters

##### key

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`StateMap`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/StateValue.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / StateValue

# Class: StateValue

Represents the core of a contract's state, and recursively represents each
of its components.

There are different *classes* of state values:
- `null`
- Cells of [AlignedValue](../type-aliases/AlignedValue.md)s
- Maps from [AlignedValue](../type-aliases/AlignedValue.md)s to state values
- Bounded Merkle trees containing [AlignedValue](../type-aliases/AlignedValue.md) leaves
- Short (\<= 15 element) arrays of state values

State values are *immutable*, any operations that mutate states will return
a new state instead.

## Methods

### arrayPush()

```ts
arrayPush(value): StateValue;
```

#### Parameters

##### value

`StateValue`

#### Returns

`StateValue`

***

### asArray()

```ts
asArray(): undefined | StateValue[];
```

#### Returns

`undefined` \| `StateValue`[]

***

### asBoundedMerkleTree()

```ts
asBoundedMerkleTree(): undefined | StateBoundedMerkleTree;
```

#### Returns

`undefined` \| [`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

***

### asCell()

```ts
asCell(): AlignedValue;
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

***

### asMap()

```ts
asMap(): undefined | StateMap;
```

#### Returns

`undefined` \| [`StateMap`](StateMap.md)

***

### encode()

```ts
encode(): EncodedStateValue;
```

**`Internal`**

#### Returns

`EncodedStateValue`

***

### logSize()

```ts
logSize(): number;
```

#### Returns

`number`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`

***

### type()

```ts
type(): "map" | "null" | "cell" | "array" | "boundedMerkleTree";
```

#### Returns

`"map"` \| `"null"` \| `"cell"` \| `"array"` \| `"boundedMerkleTree"`

***

### decode()

```ts
static decode(value): StateValue;
```

**`Internal`**

#### Parameters

##### value

`EncodedStateValue`

#### Returns

`StateValue`

***

### newArray()

```ts
static newArray(): StateValue;
```

#### Returns

`StateValue`

***

### newBoundedMerkleTree()

```ts
static newBoundedMerkleTree(tree): StateValue;
```

#### Parameters

##### tree

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Returns

`StateValue`

***

### newCell()

```ts
static newCell(value): StateValue;
```

#### Parameters

##### value

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`StateValue`

***

### newMap()

```ts
static newMap(map): StateValue;
```

#### Parameters

##### map

[`StateMap`](StateMap.md)

#### Returns

`StateValue`

***

### newNull()

```ts
static newNull(): StateValue;
```

#### Returns

`StateValue`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/VmResults.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / VmResults

# Class: VmResults

Represents the results of a VM call

## Properties

### events

```ts
readonly events: GatherResult[];
```

The events that got emitted by this VM invocation

***

### gasCost

```ts
readonly gasCost: bigint;
```

The computed gas cost of running this VM invocation

***

### stack

```ts
readonly stack: VmStack;
```

The VM stack at the end of the VM invocation

## Methods

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/classes/VmStack.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / VmStack

# Class: VmStack

Represents the state of the VM's stack at a specific point. The stack is an
array of [StateValue](StateValue.md)s, each of which is also annotated with whether
it is "strong" or "weak"; that is, whether it is permitted to be stored
on-chain or not.

## Constructors

### Constructor

```ts
new VmStack(): VmStack;
```

#### Returns

`VmStack`

## Methods

### get()

```ts
get(idx): undefined | StateValue;
```

#### Parameters

##### idx

`number`

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### isStrong()

```ts
isStrong(idx): undefined | boolean;
```

#### Parameters

##### idx

`number`

#### Returns

`undefined` \| `boolean`

***

### length()

```ts
length(): number;
```

#### Returns

`number`

***

### push()

```ts
push(value, is_strong): void;
```

#### Parameters

##### value

[`StateValue`](StateValue.md)

##### is\_strong

`boolean`

#### Returns

`void`

***

### removeLast()

```ts
removeLast(): void;
```

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string;
```

#### Parameters

##### compact?

`boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/enumerations/NetworkId.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / NetworkId

# Enumeration: NetworkId

The network currently being targeted

## Enumeration Members

### DevNet

```ts
DevNet: 1;
```

A developer network, not guaranteed to be persistent

***

### MainNet

```ts
MainNet: 3;
```

The Midnight mainnet

***

### TestNet

```ts
TestNet: 2;
```

A persistent testnet

***

### Undeployed

```ts
Undeployed: 0;
```

A local test network
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/addField.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / addField

# Function: addField()

```ts
function addField(x, y): bigint;
```

Field addition
returns the result of adding x and y, wrapping if necessary
x and y are assumed to be values in the range [0, FIELD_MODULUS)

## Parameters

### x

`bigint`

### y

`bigint`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/alignedConcat.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / alignedConcat

# Function: alignedConcat()

```ts
function alignedConcat(...values): AlignedValue;
```

**`Internal`**

Concatenates multiple [AlignedValue](../type-aliases/AlignedValue.md)s

## Parameters

### values

...[`AlignedValue`](../type-aliases/AlignedValue.md)[]

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/assert.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / assert

# Function: assert()

```ts
function assert(b, s): void;
```

**`Internal`**

Compiler internal for assertions

## Parameters

### b

`boolean`

### s

`string`

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/bigIntToValue.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / bigIntToValue

# Function: bigIntToValue()

```ts
function bigIntToValue(x): Value;
```

**`Internal`**

Internal conversion between bigints and their field-aligned binary
representation

## Parameters

### x

`bigint`

## Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/checkProofData.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / checkProofData

# Function: checkProofData()

```ts
function checkProofData(zkir, proofData): void;
```

Verifies a given [ProofData](../interfaces/ProofData.md) satisfies the constrains of a ZK circuit
descripted by given IR

## Parameters

### zkir

`string`

### proofData

[`ProofData`](../interfaces/ProofData.md)

## Returns

`void`

## Throws

If the circuit is not satisfied
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/coinCommitment.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / coinCommitment

# Function: coinCommitment()

```ts
function coinCommitment(coin, recipient): AlignedValue;
```

**`Internal`**

Internal implementation of the coin commitment primitive.

## Parameters

### coin

[`AlignedValue`](../type-aliases/AlignedValue.md)

### recipient

[`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/constructorContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / constructorContext

# Function: constructorContext()

```ts
function constructorContext<T>(initialPrivateState, coinPublicKey): ConstructorContext<T>;
```

Creates a new [ConstructorContext](../interfaces/ConstructorContext.md) with the given initial private state and an empty Zswap local state.

## Type Parameters

### T

`T`

## Parameters

### initialPrivateState

`T`

The private state to use to execute the contract's constructor.

### coinPublicKey

`string`

The Zswap coin public key of the user executing the contract.

## Returns

[`ConstructorContext`](../interfaces/ConstructorContext.md)\<`T`\>
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/contractDependencies.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / contractDependencies

# Function: contractDependencies()

```ts
function contractDependencies(contractReferenceLocations, state): string[];
```

Given a [StateValue](../classes/StateValue.md) representing the current ledger state of a contract, uses the [ContractReferenceLocations](../type-aliases/ContractReferenceLocations.md)
object produced by the Compact compiler to extract the current contract addresses present in the given ledger state. The produced
contract addresses represent the contracts on which the root contract depends. The dependencies are used in a multi-contract
setting to fetch the ledger states of all contracts on which the root contract depends prior to execution.

NOTE: The given [ContractReferenceLocations](../type-aliases/ContractReferenceLocations.md) must be from the contract executable containing the ledger state constructor
      that produced the given [StateValue](../classes/StateValue.md).

## Parameters

### contractReferenceLocations

[`ContractReferenceLocations`](../type-aliases/ContractReferenceLocations.md)

A data structure pointing to contract references in the ledger state of the root contract.

### state

[`StateValue`](../classes/StateValue.md)

The current ledger state of the root contract.

## Returns

`string`[]

A list of all contract addresses (references) present in the given ledger state.

## Remarks

The algorithm has three main stages:

         1. It unwraps the PublicLedgerSegments in the given [ContractReferenceLocations](../type-aliases/ContractReferenceLocations.md) until a [SparseCompactADT](../type-aliases/SparseCompactADT.md) is reached.
            Each time a PublicLedgerSegments is unwrapped, it casts the current state value to a state value array and proceeds recursively with each
            of the state values and unwrapped ledger segments.
         2. It unwraps each [SparseCompactADT](../type-aliases/SparseCompactADT.md) in the current PublicLedgerSegments until a [SparseCompactType](../type-aliases/SparseCompactType.md) is reached.
            Each time a [SparseCompactADT](../type-aliases/SparseCompactADT.md) is unwrapped, it casts the current state value to a state representation indicated by
            the [SparseCompactADT](../type-aliases/SparseCompactADT.md).
         3. Once the current state can no longer be reduced, it must represent a Compact contract address somewhere inside the state,
            and that contract address is added to the dependency set.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/convert_bigint_to_Uint8Array.md">
[**@midnight-ntwrk/compact-runtime v0.8.1**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / convert\_bigint\_to\_Uint8Array

# Function: convert\_bigint\_to\_Uint8Array()

```ts
function convert_bigint_to_Uint8Array(n, x): Uint8Array;
```

**`Internal`**

Compiler internal for typecasts

## Parameters

### n

`number`

### x

`bigint`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/convert_Uint8Array_to_bigint.md">
[**@midnight-ntwrk/compact-runtime v0.8.1**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / convert\_Uint8Array\_to\_bigint

# Function: convert\_Uint8Array\_to\_bigint()

```ts
function convert_Uint8Array_to_bigint(n, a): bigint;
```

**`Internal`**

Compiler internal for typecasts

## Parameters

### n

`number`

### a

`Uint8Array`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/convertBytesToField.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / convertBytesToField

# Function: convertBytesToField()

```ts
function convertBytesToField(
   n, 
   a, 
   src): bigint;
```

**`Internal`**

Compiler internal for typecasts

## Parameters

### n

`number`

### a

`Uint8Array`

### src

`String`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/convertBytesToUint.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / convertBytesToUint

# Function: convertBytesToUint()

```ts
function convertBytesToUint(
   maxval, 
   n, 
   a, 
   src): bigint;
```

**`Internal`**

Compiler internal for typecasts

## Parameters

### maxval

`number`

### n

`number`

### a

`Uint8Array`

### src

`String`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/convertFieldToBytes.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / convertFieldToBytes

# Function: convertFieldToBytes()

```ts
function convertFieldToBytes(
   n, 
   x, 
   src): Uint8Array;
```

**`Internal`**

Compiler internal for typecasts

## Parameters

### n

`number`

### x

`bigint`

### src

`String`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/createZswapInput.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / createZswapInput

# Function: createZswapInput()

```ts
function createZswapInput(circuitContext, qualifiedCoinInfo): void;
```

Adds a coin to the list of inputs consumed by the circuit.

## Parameters

### circuitContext

[`CircuitContext`](../interfaces/CircuitContext.md)\<`unknown`\>

The current circuit context.

### qualifiedCoinInfo

[`EncodedQualifiedCoinInfo`](../interfaces/EncodedQualifiedCoinInfo.md)

The input to consume.

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/createZswapOutput.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / createZswapOutput

# Function: createZswapOutput()

```ts
function createZswapOutput(
   circuitContext, 
   coinInfo, 
   recipient): void;
```

Adds a coin to the list of outputs produced by the circuit.

## Parameters

### circuitContext

[`CircuitContext`](../interfaces/CircuitContext.md)\<`unknown`\>

The current circuit context.

### coinInfo

[`EncodedCoinInfo`](../interfaces/EncodedCoinInfo.md)

The coin to produce.

### recipient

[`EncodedRecipient`](../interfaces/EncodedRecipient.md)

The coin recipient - either a coin public key representing an end user or a contract address
                 representing a contract.

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeCoinInfo

# Function: decodeCoinInfo()

```ts
function decodeCoinInfo(coin): CoinInfo;
```

Decode a [CoinInfo](../type-aliases/CoinInfo.md) from Compact's `CoinInfo` TypeScript representation

## Parameters

### coin

#### color

`Uint8Array`

#### nonce

`Uint8Array`

#### value

`bigint`

## Returns

[`CoinInfo`](../type-aliases/CoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeCoinPublicKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeCoinPublicKey

# Function: decodeCoinPublicKey()

```ts
function decodeCoinPublicKey(pk): string;
```

Decode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) from a `Uint8Array` originating from Compact's
`CoinPublicKey` type

## Parameters

### pk

`Uint8Array`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeContractAddress

# Function: decodeContractAddress()

```ts
function decodeContractAddress(addr): string;
```

Decode a [ContractAddress](../type-aliases/ContractAddress.md) from a `Uint8Array` originating from
Compact's `ContractAddress` type

## Parameters

### addr

`Uint8Array`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeQualifiedCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeQualifiedCoinInfo

# Function: decodeQualifiedCoinInfo()

```ts
function decodeQualifiedCoinInfo(coin): QualifiedCoinInfo;
```

Decode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) from Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

### coin

#### color

`Uint8Array`

#### mt_index

`bigint`

#### nonce

`Uint8Array`

#### value

`bigint`

## Returns

[`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeRecipient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeRecipient

# Function: decodeRecipient()

```ts
function decodeRecipient(__namedParameters): Recipient;
```

Converts an [EncodedRecipient](../interfaces/EncodedRecipient.md) to a [Recipient](../interfaces/Recipient.md).

## Parameters

### \_\_namedParameters

[`EncodedRecipient`](../interfaces/EncodedRecipient.md)

## Returns

[`Recipient`](../interfaces/Recipient.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeTokenType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeTokenType

# Function: decodeTokenType()

```ts
function decodeTokenType(tt): string;
```

Decode a [TokenType](../type-aliases/TokenType.md) from a `Uint8Array` originating from Compact's
`TokenType` type

## Parameters

### tt

`Uint8Array`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/decodeZswapLocalState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / decodeZswapLocalState

# Function: decodeZswapLocalState()

```ts
function decodeZswapLocalState(state): ZswapLocalState;
```

Converts an [EncodedZswapLocalState](../interfaces/EncodedZswapLocalState.md) to a [ZswapLocalState](../interfaces/ZswapLocalState.md). Used when we need to use data from contract
execution to construct transactions.

## Parameters

### state

[`EncodedZswapLocalState`](../interfaces/EncodedZswapLocalState.md)

The encoded Zswap local state.

## Returns

[`ZswapLocalState`](../interfaces/ZswapLocalState.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/degradeToTransient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / degradeToTransient

# Function: degradeToTransient()

```ts
function degradeToTransient(x): bigint;
```

The Compact builtin `degrade_to_transient` function

This function "degrades" the output of a [persistentHash](persistentHash.md) or
[persistentCommit](persistentCommit.md) to a field element, which can then be used in
[transientHash](transientHash.md) or [transientCommit](transientCommit.md).

## Parameters

### x

`Uint8Array`

## Returns

`bigint`

## Throws

If `x` is not 32 bytes long
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/dummyContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / dummyContractAddress

# Function: dummyContractAddress()

```ts
function dummyContractAddress(): string;
```

A sample contract address, guaranteed to be the same for a given network ID
for use in testing

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/ecAdd.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ecAdd

# Function: ecAdd()

```ts
function ecAdd(a, b): CurvePoint;
```

The Compact builtin `ec_add` function

This function add two elliptic curve points (in multiplicative notation)

## Parameters

### a

[`CurvePoint`](../interfaces/CurvePoint.md)

### b

[`CurvePoint`](../interfaces/CurvePoint.md)

## Returns

[`CurvePoint`](../interfaces/CurvePoint.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/ecMul.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ecMul

# Function: ecMul()

```ts
function ecMul(a, b): CurvePoint;
```

The Compact builtin `ec_mul` function

This function multiplies an elliptic curve point by a scalar (in
multiplicative notation)

## Parameters

### a

[`CurvePoint`](../interfaces/CurvePoint.md)

### b

`bigint`

## Returns

[`CurvePoint`](../interfaces/CurvePoint.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/ecMulGenerator.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ecMulGenerator

# Function: ecMulGenerator()

```ts
function ecMulGenerator(b): CurvePoint;
```

The Compact builtin `ec_mul_generator` function

This function multiplies the primary group generator of the embedded curve
by a scalar (in multiplicative notation)

## Parameters

### b

`bigint`

## Returns

[`CurvePoint`](../interfaces/CurvePoint.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/emptyZswapLocalState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / emptyZswapLocalState

# Function: emptyZswapLocalState()

```ts
function emptyZswapLocalState(coinPublicKey): EncodedZswapLocalState;
```

Constructs a new [EncodedZswapLocalState](../interfaces/EncodedZswapLocalState.md) with the given coin public key. The result can be used to create a
[ConstructorContext](../interfaces/ConstructorContext.md).

## Parameters

### coinPublicKey

`string`

The Zswap coin public key of the user executing the circuit.

## Returns

[`EncodedZswapLocalState`](../interfaces/EncodedZswapLocalState.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeCoinInfo

# Function: encodeCoinInfo()

```ts
function encodeCoinInfo(coin): {
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
};
```

Encode a [CoinInfo](../type-aliases/CoinInfo.md) into a Compact's `CoinInfo` TypeScript
representation

## Parameters

### coin

[`CoinInfo`](../type-aliases/CoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeCoinPublicKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeCoinPublicKey

# Function: encodeCoinPublicKey()

```ts
function encodeCoinPublicKey(pk): Uint8Array;
```

Encode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) into a `Uint8Array` for use in Compact's
`CoinPublicKey` type

## Parameters

### pk

`string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeContractAddress

# Function: encodeContractAddress()

```ts
function encodeContractAddress(addr): Uint8Array;
```

Encode a [ContractAddress](../type-aliases/ContractAddress.md) into a `Uint8Array` for use in Compact's
`ContractAddress` type

## Parameters

### addr

`string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeQualifiedCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeQualifiedCoinInfo

# Function: encodeQualifiedCoinInfo()

```ts
function encodeQualifiedCoinInfo(coin): {
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
};
```

Encode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) into a Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

### coin

[`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### mt\_index

```ts
mt_index: bigint;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeRecipient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeRecipient

# Function: encodeRecipient()

```ts
function encodeRecipient(__namedParameters): EncodedRecipient;
```

Converts an [Recipient](../interfaces/Recipient.md) to an [EncodedRecipient](../interfaces/EncodedRecipient.md). Useful for testing.

## Parameters

### \_\_namedParameters

[`Recipient`](../interfaces/Recipient.md)

## Returns

[`EncodedRecipient`](../interfaces/EncodedRecipient.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeTokenType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeTokenType

# Function: encodeTokenType()

```ts
function encodeTokenType(tt): Uint8Array;
```

Encode a [TokenType](../type-aliases/TokenType.md) into a `Uint8Array` for use in Compact's
`TokenType` type

## Parameters

### tt

`string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/encodeZswapLocalState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / encodeZswapLocalState

# Function: encodeZswapLocalState()

```ts
function encodeZswapLocalState(state): EncodedZswapLocalState;
```

Converts a [ZswapLocalState](../interfaces/ZswapLocalState.md) to an [EncodedZswapLocalState](../interfaces/EncodedZswapLocalState.md). Useful for testing.

## Parameters

### state

[`ZswapLocalState`](../interfaces/ZswapLocalState.md)

The decoded Zswap local state.

## Returns

[`EncodedZswapLocalState`](../interfaces/EncodedZswapLocalState.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/hasCoinCommitment.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / hasCoinCommitment

# Function: hasCoinCommitment()

```ts
function hasCoinCommitment(
   context, 
   coinInfo, 
   recipient): boolean;
```

Checks whether a coin commitment has already been added to the current query context.

## Parameters

### context

[`CircuitContext`](../interfaces/CircuitContext.md)\<`unknown`\>

The current circuit context.

### coinInfo

[`EncodedCoinInfo`](../interfaces/EncodedCoinInfo.md)

The coin information to check.

### recipient

[`EncodedRecipient`](../interfaces/EncodedRecipient.md)

The coin recipient to check.

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/hashToCurve.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / hashToCurve

# Function: hashToCurve()

```ts
function hashToCurve<a>(rt_type, x): CurvePoint;
```

The Compact builtin `hash_to_curve` function

This function maps arbitrary values representable in Compact to elliptic
curve points in the proof system's embedded curve.

Outputs are guaranteed to have unknown discrete logarithm with respect to
the group base, and any other output, but are not guaranteed to be unique (a
given input can be proven correct for multiple outputs).

Inputs of different types may have the same output, if they have the same
field-aligned binary representation.

## Type Parameters

### a

`a`

## Parameters

### rt\_type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

### x

`a`

## Returns

[`CurvePoint`](../interfaces/CurvePoint.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/leafHash.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / leafHash

# Function: leafHash()

```ts
function leafHash(value): AlignedValue;
```

**`Internal`**

Internal implementation of the Merkle tree leaf hash primitive.

## Parameters

### value

[`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/maxAlignedSize.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / maxAlignedSize

# Function: maxAlignedSize()

```ts
function maxAlignedSize(alignment): bigint;
```

**`Internal`**

Internal implementation of the max aligned size primitive.

## Parameters

### alignment

[`Alignment`](../type-aliases/Alignment.md)

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/mulField.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / mulField

# Function: mulField()

```ts
function mulField(x, y): bigint;
```

Field multiplication
returns the result of multipying x and y, wrapping if necessary
x and y are assumed to be values in the range [0, FIELD_MODULUS)

## Parameters

### x

`bigint`

### y

`bigint`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/ownPublicKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ownPublicKey

# Function: ownPublicKey()

```ts
function ownPublicKey(circuitContext): EncodedCoinPublicKey;
```

Retrieves the Zswap coin public key of the user executing the circuit.

## Parameters

### circuitContext

[`CircuitContext`](../interfaces/CircuitContext.md)\<`unknown`\>

The current circuit context.

## Returns

[`EncodedCoinPublicKey`](../interfaces/EncodedCoinPublicKey.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/persistentCommit.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / persistentCommit

# Function: persistentCommit()

```ts
function persistentCommit<a>(
   rt_type, 
   value, 
   opening): Uint8Array;
```

The Compact builtin `persistent_commit` function

This function is a non-circuit-optimised commitment function from arbitrary
values representable in Compact, and a 256-bit bytestring opening, to a
256-bit bytestring. It is guaranteed to persist between upgrades. It
*should* be used to derive state data, and not for consistency checks where
avoidable.

Note that data containing `Opaque` elements *may* throw runtime errors, and
cannot be relied upon as a consistent representation.

## Type Parameters

### a

`a`

## Parameters

### rt\_type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

### value

`a`

### opening

`Uint8Array`

## Returns

`Uint8Array`

## Throws

If `rt_type` encodes a type containing Compact 'Opaque' types, or
`opening` is not 32 bytes long
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/persistentHash.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / persistentHash

# Function: persistentHash()

```ts
function persistentHash<a>(rt_type, value): Uint8Array;
```

The Compact builtin `persistent_hash` function

This function is a non-circuit-optimised hash function for mostly arbitrary
data. It is guaranteed to persist between upgrades, with the exception of
devnet. It *should* be used to derive state data, and not for consistency
checks where avoidable.

Note that data containing `Opaque` elements *may* throw runtime errors, and
cannot be relied upon as a consistent representation.

## Type Parameters

### a

`a`

## Parameters

### rt\_type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

### value

`a`

## Returns

`Uint8Array`

## Throws

If `rt_type` encodes a type containing Compact 'Opaque' types
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/runProgram.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / runProgram

# Function: runProgram()

```ts
function runProgram(
   initial, 
   ops, 
   cost_model, 
   gas_limit?): VmResults;
```

Runs a VM program against an initial stack, with an optional gas limit

## Parameters

### initial

[`VmStack`](../classes/VmStack.md)

### ops

[`Op`](../type-aliases/Op.md)\<`null`\>[]

### cost\_model

[`CostModel`](../classes/CostModel.md)

### gas\_limit?

`bigint`

## Returns

[`VmResults`](../classes/VmResults.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/sampleContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / sampleContractAddress

# Function: sampleContractAddress()

```ts
function sampleContractAddress(): string;
```

Samples a uniform contract address, for use in testing

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/sampleSigningKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / sampleSigningKey

# Function: sampleSigningKey()

```ts
function sampleSigningKey(): string;
```

Randomly samples a [SigningKey](../type-aliases/SigningKey.md).

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/sampleTokenType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / sampleTokenType

# Function: sampleTokenType()

```ts
function sampleTokenType(): string;
```

Samples a uniform token type, for use in testing

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/signatureVerifyingKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / signatureVerifyingKey

# Function: signatureVerifyingKey()

```ts
function signatureVerifyingKey(sk): string;
```

Returns the verifying key for a given signing key

## Parameters

### sk

`string`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/signData.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / signData

# Function: signData()

```ts
function signData(key, data): string;
```

Signs arbitrary data with the given signing key.

WARNING: Do not expose access to this function for valuable keys for data
that is not strictly controlled!

## Parameters

### key

`string`

### data

`Uint8Array`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/subField.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / subField

# Function: subField()

```ts
function subField(x, y): bigint;
```

Field subtraction
returns the result of subtracting y from x, wrapping if necessary
x and y are assumed to be values in the range [0, FIELD_MODULUS)

## Parameters

### x

`bigint`

### y

`bigint`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/tokenType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / tokenType

# Function: tokenType()

```ts
function tokenType(domain_sep, contract): string;
```

Derives the [TokenType](../type-aliases/TokenType.md) associated with a particular
[DomainSeperator](../type-aliases/DomainSeperator.md) and contract.

## Parameters

### domain\_sep

[`DomainSeperator`](../type-aliases/DomainSeperator.md)

### contract

`string`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/transientCommit.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / transientCommit

# Function: transientCommit()

```ts
function transientCommit<a>(
   rt_type, 
   value, 
   opening): bigint;
```

The Compact builtin `transient_commit` function

This function is a circuit-efficient commitment function from arbitrary
values representable in Compact, and a field element commitment opening, to
field elements, which is not guaranteed to persist between
upgrades. It should not be used to derive state data, but can be used for
consistency checks.

## Type Parameters

### a

`a`

## Parameters

### rt\_type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

### value

`a`

### opening

`bigint`

## Returns

`bigint`

## Throws

If `opening` is out of range for field elements
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/transientHash.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / transientHash

# Function: transientHash()

```ts
function transientHash<a>(rt_type, value): bigint;
```

The Compact builtin `transient_hash` function

This function is a circuit-efficient compression function from arbitrary
data to field elements, which is not guaranteed to persist between upgrades.
It should not be used to derive state data, but can be used for consistency
checks.

## Type Parameters

### a

`a`

## Parameters

### rt\_type

[`CompactType`](../interfaces/CompactType.md)\<`a`\>

### value

`a`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/type_error.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / type\_error

# Function: type\_error()

```ts
function type_error(
   who, 
   what, 
   where, 
   type, 
   x): never;
```

**`Internal`**

Compiler internal for type errors

## Parameters

### who

`string`

### what

`string`

### where

`string`

### type

`string`

### x

`any`

## Returns

`never`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/upgradeFromTransient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / upgradeFromTransient

# Function: upgradeFromTransient()

```ts
function upgradeFromTransient(x): Uint8Array;
```

The Compact builtin `upgrade_from_transient` function

This function "upgrades" the output of a [transientHash](transientHash.md) or
[transientCommit](transientCommit.md) to 256-bit byte string, which can then be used in
[persistentHash](persistentHash.md) or [persistentCommit](persistentCommit.md).

## Parameters

### x

`bigint`

## Returns

`Uint8Array`

## Throws

If `x` is not a valid field element
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/valueToBigInt.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / valueToBigInt

# Function: valueToBigInt()

```ts
function valueToBigInt(x): bigint;
```

**`Internal`**

Internal conversion between field-aligned binary values and bigints within
the scalar field

## Parameters

### x

[`Value`](../type-aliases/Value.md)

## Returns

`bigint`

## Throws

If the value does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/verifySignature.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / verifySignature

# Function: verifySignature()

```ts
function verifySignature(
   vk, 
   data, 
   signature): boolean;
```

Verifies if a signature is correct

## Parameters

### vk

`string`

### data

`Uint8Array`

### signature

`string`

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/functions/witnessContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / witnessContext

# Function: witnessContext()

```ts
function witnessContext<L, T>(
   ledger, 
   privateState, 
contractAddress): WitnessContext<L, T>;
```

**`Internal`**

Internal constructor for [WitnessContext](../interfaces/WitnessContext.md).

## Type Parameters

### L

`L`

### T

`T`

## Parameters

### ledger

`L`

### privateState

`T`

### contractAddress

`string`

## Returns

[`WitnessContext`](../interfaces/WitnessContext.md)\<`L`, `T`\>
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/CircuitContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CircuitContext

# Interface: CircuitContext\<T\>

The external information accessible from within a Compact circuit call

## Type Parameters

### T

`T`

## Properties

### currentPrivateState

```ts
currentPrivateState: T;
```

The current private state for the contract.

***

### currentZswapLocalState

```ts
currentZswapLocalState: EncodedZswapLocalState;
```

The current Zswap local state. Tracks inputs and outputs produced during circuit execution.

***

### originalState

```ts
originalState: ContractState;
```

The original contract state the circuit call was started at.

***

### transactionContext

```ts
transactionContext: QueryContext;
```

The current on-chain context the transaction is evolving.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/CircuitResults.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CircuitResults

# Interface: CircuitResults\<T, U\>

The results of the call to a Compact circuit

## Type Parameters

### T

`T`

### U

`U`

## Properties

### context

```ts
context: CircuitContext<T>;
```

The updated context after the circuit execution, that can be used to
inform further runs

***

### proofData

```ts
proofData: ProofData;
```

The data required to prove this circuit run

***

### result

```ts
result: U;
```

The primary result, as returned from Compact
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/CompactType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CompactType

# Interface: CompactType\<a\>

A runtime representation of a type in Compact

## Type Parameters

### a

`a`

## Methods

### alignment()

```ts
alignment(): Alignment;
```

The field-aligned binary alignment of this type.

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

***

### fromValue()

```ts
fromValue(value): a;
```

Converts this type's field-aligned binary representation to its TypeScript
representation destructively; (partially) consuming the input, and
ignoring superflous data for chaining.

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

`a`

***

### toValue()

```ts
toValue(value): Value;
```

Converts this type's TypeScript representation to its field-aligned binary
representation

#### Parameters

##### value

`a`

#### Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/ConstructorContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ConstructorContext

# Interface: ConstructorContext\<T\>

Passed to the constructor of a contract. Used to compute the contract's initial ledger state.

## Type Parameters

### T

`T`

## Properties

### initialPrivateState

```ts
initialPrivateState: T;
```

The private state we would like to use to execute the contract's constructor.

***

### initialZswapLocalState

```ts
initialZswapLocalState: EncodedZswapLocalState;
```

An initial (usually empty) Zswap local state to use to execute the contract's constructor.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/ConstructorResult.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ConstructorResult

# Interface: ConstructorResult\<T\>

The result of executing a contract constructor.

## Type Parameters

### T

`T`

## Properties

### currentContractState

```ts
currentContractState: ContractState;
```

The contract's initial ledger (public state).

***

### currentPrivateState

```ts
currentPrivateState: T;
```

The contract's initial private state. Potentially different from the private state passed in [ConstructorContext](ConstructorContext.md).

***

### currentZswapLocalState

```ts
currentZswapLocalState: EncodedZswapLocalState;
```

The contract's initial Zswap local state. Potentially includes outputs created in the contract's constructor.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/CurvePoint.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CurvePoint

# Interface: CurvePoint

A point in the embedded elliptic curve. TypeScript representation of the
Compact type of the same name

## Properties

### x

```ts
readonly x: bigint;
```

***

### y

```ts
readonly y: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedCoinInfo

# Interface: EncodedCoinInfo

A [CoinInfo](../type-aliases/CoinInfo.md) with its fields encoded as byte strings. This representation is used internally by
the contract executable.

## Properties

### color

```ts
readonly color: Uint8Array;
```

The coin's type, identifying the currency it represents.

***

### nonce

```ts
readonly nonce: Uint8Array;
```

The coin's randomness, preventing it from colliding with other coins.

***

### value

```ts
readonly value: bigint;
```

The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedCoinPublicKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedCoinPublicKey

# Interface: EncodedCoinPublicKey

A [CoinPublicKey](../type-aliases/CoinPublicKey.md) encoded as a byte string. This representation is used internally by the contract executable.

## Properties

### bytes

```ts
readonly bytes: Uint8Array;
```

The coin public key's bytes.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedContractAddress

# Interface: EncodedContractAddress

A [ContractAddress](../type-aliases/ContractAddress.md) encoded as a byte string. This representation is used internally by the contract executable.

## Properties

### bytes

```ts
readonly bytes: Uint8Array;
```

The contract address's bytes.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedQualifiedCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedQualifiedCoinInfo

# Interface: EncodedQualifiedCoinInfo

A [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) with its fields encoded as byte strings. This representation is used internally by
the contract executable.

## Properties

### color

```ts
readonly color: Uint8Array;
```

The coin's type, identifying the currency it represents.

***

### mt\_index

```ts
readonly mt_index: bigint;
```

The coin's location in the chain's Merkle tree of coin commitments. Bounded to be a non-negative 64-bit integer.

***

### nonce

```ts
readonly nonce: Uint8Array;
```

The coin's randomness, preventing it from colliding with other coins.

***

### value

```ts
readonly value: bigint;
```

The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedRecipient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedRecipient

# Interface: EncodedRecipient

A [Recipient](Recipient.md) with its fields encoded as byte strings. This representation is used internally by the contract executable.

## Properties

### is\_left

```ts
readonly is_left: boolean;
```

Whether the recipient is a user or a contract.

***

### left

```ts
readonly left: EncodedCoinPublicKey;
```

The recipient's public key, if the recipient is a user.

***

### right

```ts
readonly right: EncodedContractAddress;
```

The recipient's contract address, if the recipient is a contract.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/EncodedZswapLocalState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / EncodedZswapLocalState

# Interface: EncodedZswapLocalState

Tracks the coins consumed and produced throughout circuit execution.

## Properties

### coinPublicKey

```ts
coinPublicKey: EncodedCoinPublicKey;
```

The Zswap coin public key of the user executing the circuit.

***

### currentIndex

```ts
currentIndex: bigint;
```

The Merkle tree index of the next coin produced.

***

### inputs

```ts
inputs: EncodedQualifiedCoinInfo[];
```

The coins consumed as inputs to the circuit.

***

### outputs

```ts
outputs: {
  coinInfo: EncodedCoinInfo;
  recipient: EncodedRecipient;
}[];
```

The coins produced as outputs from the circuit.

#### coinInfo

```ts
coinInfo: EncodedCoinInfo;
```

#### recipient

```ts
recipient: EncodedRecipient;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/MerkleTreeDigest.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / MerkleTreeDigest

# Interface: MerkleTreeDigest

The hash value of a Merkle tree. TypeScript representation of the Compact
type of the same name

## Properties

### field

```ts
readonly field: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/MerkleTreePath.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / MerkleTreePath

# Interface: MerkleTreePath\<a\>

A path demonstrating inclusion in a Merkle tree. TypeScript representation
of the Compact type of the same name.

## Type Parameters

### a

`a`

## Properties

### leaf

```ts
readonly leaf: a;
```

***

### path

```ts
readonly path: MerkleTreePathEntry[];
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/MerkleTreePathEntry.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / MerkleTreePathEntry

# Interface: MerkleTreePathEntry

An entry in a Merkle path. TypeScript representation of the Compact type of
the same name.

## Properties

### goes\_left

```ts
readonly goes_left: boolean;
```

***

### sibling

```ts
readonly sibling: MerkleTreeDigest;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/ProofData.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ProofData

# Interface: ProofData

Encapsulates the data required to produce a zero-knowledge proof

## Properties

### input

```ts
input: AlignedValue;
```

The inputs to a circuit

***

### output

```ts
output: AlignedValue;
```

The outputs from a circuit

***

### privateTranscriptOutputs

```ts
privateTranscriptOutputs: AlignedValue[];
```

The transcript of the witness call outputs

***

### publicTranscript

```ts
publicTranscript: Op<AlignedValue>[];
```

The public transcript of operations
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/Recipient.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Recipient

# Interface: Recipient

The recipient of a coin produced by a circuit.

## Properties

### is\_left

```ts
readonly is_left: boolean;
```

Whether the recipient is a user or a contract.

***

### left

```ts
readonly left: string;
```

The recipient's public key, if the recipient is a user.

***

### right

```ts
readonly right: string;
```

The recipient's contract address, if the recipient is a contract.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/WitnessContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / WitnessContext

# Interface: WitnessContext\<L, T\>

The external information accessible from within a Compact witness call

## Type Parameters

### L

`L`

### T

`T`

## Properties

### contractAddress

```ts
readonly contractAddress: string;
```

The address of the contract being called

***

### ledger

```ts
readonly ledger: L;
```

The projected ledger state, if the transaction were to run against the
ledger state as you locally see it currently

***

### privateState

```ts
readonly privateState: T;
```

The current private state for the contract
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/interfaces/ZswapLocalState.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ZswapLocalState

# Interface: ZswapLocalState

Tracks the coins consumed and produced throughout circuit execution.

## Properties

### coinPublicKey

```ts
coinPublicKey: string;
```

The Zswap coin public key of the user executing the circuit.

***

### currentIndex

```ts
currentIndex: bigint;
```

The Merkle tree index of the next coin produced.

***

### inputs

```ts
inputs: QualifiedCoinInfo[];
```

The coins consumed as inputs to the circuit.

***

### outputs

```ts
outputs: {
  coinInfo: CoinInfo;
  recipient: Recipient;
}[];
```

The coins produced as outputs from the circuit.

#### coinInfo

```ts
coinInfo: CoinInfo;
```

#### recipient

```ts
recipient: Recipient;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/AlignedValue.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / AlignedValue

# Type Alias: AlignedValue

```ts
type AlignedValue = {
  alignment: Alignment;
  value: Value;
};
```

An onchain data value, in field-aligned binary format, annotated with its
alignment.

## Properties

### alignment

```ts
alignment: Alignment;
```

***

### value

```ts
value: Value;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Alignment.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Alignment

# Type Alias: Alignment

```ts
type Alignment = AlignmentSegment[];
```

The alignment of an onchain field-aligned binary data value.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/AlignmentAtom.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / AlignmentAtom

# Type Alias: AlignmentAtom

```ts
type AlignmentAtom = 
  | {
  tag: "compress";
}
  | {
  tag: "field";
}
  | {
  length: number;
  tag: "bytes";
};
```

A atom in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/AlignmentSegment.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / AlignmentSegment

# Type Alias: AlignmentSegment

```ts
type AlignmentSegment = 
  | {
  tag: "option";
  value: Alignment[];
}
  | {
  tag: "atom";
  value: AlignmentAtom;
};
```

A segment in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/BlockContext.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / BlockContext

# Type Alias: BlockContext

```ts
type BlockContext = {
  blockHash: string;
  secondsSinceEpoch: bigint;
  secondsSinceEpochErr: number;
};
```

The context information about a block available inside the VM

## Properties

### blockHash

```ts
blockHash: string;
```

The hash of the block prior to this transaction, as a hex-encoded string

***

### secondsSinceEpoch

```ts
secondsSinceEpoch: bigint;
```

The seconds since the UNIX epoch that have elapsed

***

### secondsSinceEpochErr

```ts
secondsSinceEpochErr: number;
```

The maximum error on [secondsSinceEpoch](#secondssinceepoch) that should occur, as a
positive seconds value
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/CoinCommitment.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CoinCommitment

# Type Alias: CoinCommitment

```ts
type CoinCommitment = string;
```

A Zswap coin commitment, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/CoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CoinInfo

# Type Alias: CoinInfo

```ts
type CoinInfo = {
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to create a new coin, alongside details about the
recipient

## Properties

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

***

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

***

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/CoinPublicKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CoinPublicKey

# Type Alias: CoinPublicKey

```ts
type CoinPublicKey = string;
```

A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
string
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/ContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractAddress

# Type Alias: ContractAddress

```ts
type ContractAddress = string;
```

A contract address, as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/ContractReferenceLocations.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractReferenceLocations

# Type Alias: ContractReferenceLocations

```ts
type ContractReferenceLocations = EmptyPublicLedger | PublicLedgerSegments;
```

A data structure indicating the locations of all contract references in a given ledger state. If it is a EmptyPublicLedger,
then no contract references are present in the ledger state. If it is a PublicLedgerSegments, then contract references are
present and can be extracted using [contractDependencies](../functions/contractDependencies.md).
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/DomainSeperator.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / DomainSeperator

# Type Alias: DomainSeperator

```ts
type DomainSeperator = Uint8Array;
```

A token domain seperator, the pre-stage of `TokenType`, as 32-byte bytearray
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Effects.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Effects

# Type Alias: Effects

```ts
type Effects = {
  claimedContractCalls: [bigint, ContractAddress, string, Fr][];
  claimedNullifiers: Nullifier[];
  claimedReceives: CoinCommitment[];
  claimedSpends: CoinCommitment[];
  mints: Map<string, bigint>;
};
```

The contract-external effects of a transcript.

## Properties

### claimedContractCalls

```ts
claimedContractCalls: [bigint, ContractAddress, string, Fr][];
```

The contracts called from this contract. The values are, in order:

- The sequence number of this call
- The contract being called
- The entry point being called
- The communications commitment

***

### claimedNullifiers

```ts
claimedNullifiers: Nullifier[];
```

The nullifiers (spends) this contract call requires

***

### claimedReceives

```ts
claimedReceives: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
received

***

### claimedSpends

```ts
claimedSpends: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
sent

***

### mints

```ts
mints: Map<string, bigint>;
```

The tokens minted in this call, as a map from hex-encoded 256-bit domain
separators to non-negative 64-bit integers.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Fr.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Fr

# Type Alias: Fr

```ts
type Fr = Uint8Array;
```

An internal encoding of a value of the proof systems scalar field
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/GatherResult.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / GatherResult

# Type Alias: GatherResult

```ts
type GatherResult = 
  | {
  content: AlignedValue;
  tag: "read";
}
  | {
  content: EncodedStateValue;
  tag: "log";
};
```

An individual result of observing the results of a non-verifying VM program
execution
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Key.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Key

# Type Alias: Key

```ts
type Key = 
  | {
  tag: "value";
  value: AlignedValue;
}
  | {
  tag: "stack";
};
```

A key used to index into an array or map in the onchain VM
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Nonce.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Nonce

# Type Alias: Nonce

```ts
type Nonce = string;
```

A Zswap nonce, as a hex-encoded 256-bit string
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Nullifier.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Nullifier

# Type Alias: Nullifier

```ts
type Nullifier = string;
```

A Zswap nullifier, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Op.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Op

# Type Alias: Op\<R\>

```ts
type Op<R> = 
  | {
  noop: {
     n: number;
  };
}
  | "lt"
  | "eq"
  | "type"
  | "size"
  | "new"
  | "and"
  | "or"
  | "neg"
  | "log"
  | "root"
  | "pop"
  | {
  popeq: {
     cached: boolean;
     result: R;
  };
}
  | {
  addi: {
     immediate: number;
  };
}
  | {
  subi: {
     immediate: number;
  };
}
  | {
  push: {
     storage: boolean;
     value: EncodedStateValue;
  };
}
  | {
  branch: {
     skip: number;
  };
}
  | {
  jmp: {
     skip: number;
  };
}
  | "add"
  | "sub"
  | {
  concat: {
     cached: boolean;
     n: number;
  };
}
  | "member"
  | {
  rem: {
     cached: boolean;
  };
}
  | {
  dup: {
     n: number;
  };
}
  | {
  swap: {
     n: number;
  };
}
  | {
  idx: {
     cached: boolean;
     path: Key[];
     pushPath: boolean;
  };
}
  | {
  ins: {
     cached: boolean;
     n: number;
  };
}
  | "ckpt";
```

An individual operation in the onchain VM

## Type Parameters

### R

`R`

`null` or [AlignedValue](AlignedValue.md), for gathering and verifying
mode respectively
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/QualifiedCoinInfo.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / QualifiedCoinInfo

# Type Alias: QualifiedCoinInfo

```ts
type QualifiedCoinInfo = {
  mt_index: bigint;
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to spend an existing coin, alongside authorization of
the owner

## Properties

### mt\_index

```ts
mt_index: bigint;
```

The coin's location in the chain's Merkle tree of coin commitments

Bounded to be a non-negative 64-bit integer

***

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

***

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

***

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Signature.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Signature

# Type Alias: Signature

```ts
type Signature = string;
```

A hex-encoded signature BIP-340 signature, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SignatureVerifyingKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SignatureVerifyingKey

# Type Alias: SignatureVerifyingKey

```ts
type SignatureVerifyingKey = string;
```

A hex-encoded signature BIP-340 verifying key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SigningKey.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SigningKey

# Type Alias: SigningKey

```ts
type SigningKey = string;
```

A hex-encoded signature BIP-340 signing key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactADT

# Type Alias: SparseCompactADT

```ts
type SparseCompactADT = 
  | SparseCompactCellADT
  | SparseCompactArrayLikeADT
  | SparseCompactMapADT;
```

A discriminated union describing the locations of contract references in either a Compact `Cell`, `List`, `Set`, or `Map` ADT.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactArrayLikeADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactArrayLikeADT

# Type Alias: SparseCompactArrayLikeADT

```ts
type SparseCompactArrayLikeADT = 
  | SparseCompactSetADT
  | SparseCompactListADT;
```

A data structure indicating the locations of all contract references in a Compact `Set` or `List` ADT.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactCellADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactCellADT

# Type Alias: SparseCompactCellADT

```ts
type SparseCompactCellADT = {
  tag: "cell";
  valueType: SparseCompactValue;
};
```

A data structure indicating the locations of all contract references in a Compact `Cell` ADT.

## Properties

### tag

```ts
tag: "cell";
```

***

### valueType

```ts
valueType: SparseCompactValue;
```

A data structure indicating the locations of all contract references in the Compact value contained in the outer `Cell` ADT.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactContractAddress.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactContractAddress

# Type Alias: SparseCompactContractAddress

```ts
type SparseCompactContractAddress = {
  tag: "contractAddress";
};
```

A data structure indicating that the current CompactValue being explored is a contract reference. When this
type is recognized, the current CompactValue should be a [ContractAddress](ContractAddress.md), and the address is added to
the dependency set.

## Properties

### tag

```ts
tag: "contractAddress";
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactListADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactListADT

# Type Alias: SparseCompactListADT

```ts
type SparseCompactListADT = {
  tag: "list";
  valueType: SparseCompactValue;
};
```

A data structure indicating the locations of all contract references in a Compact `List` ADT.

## Properties

### tag

```ts
tag: "list";
```

***

### valueType

```ts
valueType: SparseCompactValue;
```

A data structure indicating the locations of all contract references in a Compact value in the outer `List` ADT.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactMapADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactMapADT

# Type Alias: SparseCompactMapADT

```ts
type SparseCompactMapADT = {
  keyType?: SparseCompactValue;
  tag: "map";
  valueType?:   | SparseCompactADT
     | SparseCompactValue;
};
```

A data structure indicating the locations of all contract references in a Compact `Map` ADT.

## Properties

### keyType?

```ts
optional keyType: SparseCompactValue;
```

A data structure indicating the locations of all contract references in the Compact values that are the keys of the
outer `Map` ADT.

***

### tag

```ts
tag: "map";
```

***

### valueType?

```ts
optional valueType: 
  | SparseCompactADT
  | SparseCompactValue;
```

A data structure indicating the locations of all contract references in the Compact entities that are the values of the
outer `Map` ADT. Since the values of a `Map` ADT may be either Compact values or other `Map` ADTs, we take the union
of the corresponding data structures.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactSetADT.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactSetADT

# Type Alias: SparseCompactSetADT

```ts
type SparseCompactSetADT = {
  tag: "set";
  valueType: SparseCompactValue;
};
```

A data structure indicating the locations of all contract references in a Compact `Set` ADT.

## Properties

### tag

```ts
tag: "set";
```

***

### valueType

```ts
valueType: SparseCompactValue;
```

A data structure indicating the locations of all contract references in a Compact value in the outer `Set` ADT.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactStruct.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactStruct

# Type Alias: SparseCompactStruct

```ts
type SparseCompactStruct = {
  elements: Record<string, SparseCompactType>;
  tag: "struct";
};
```

A data structure indicating the locations of contract references in a Compact struct.

## Properties

### elements

```ts
elements: Record<string, SparseCompactType>;
```

A data structure indicating the locations of contract references in the elements of a Compact struct. The keys of
the record correspond to fields of the Compact struct that contain contract references. We use the keys of the record
to explore the elements of the corresponding CompactStruct.

***

### tag

```ts
tag: "struct";
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactType

# Type Alias: SparseCompactType

```ts
type SparseCompactType = 
  | SparseCompactVector
  | SparseCompactStruct
  | SparseCompactContractAddress;
```

A data structure indicating the locations of contract references in a Compact struct, vector, or (the terminating case)
a contract address.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactValue.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactValue

# Type Alias: SparseCompactValue

```ts
type SparseCompactValue = {
  descriptor: CompactType<unknown>;
  sparseType: SparseCompactType;
  tag: "compactValue";
};
```

A data structure indicating the locations of all contract references in a Compact value.

## Properties

### descriptor

```ts
descriptor: CompactType<unknown>;
```

A descriptor that can be used to convert an [AlignedValue](AlignedValue.md) into a TypeScript representation of the same value.
This descriptor will only ever decode `struct`s or `Vector`s that contain contract addresses.

***

### sparseType

```ts
sparseType: SparseCompactType;
```

A data structure indicating how to navigate to the contract addresses present in the output of the above `descriptor`.

***

### tag

```ts
tag: "compactValue";
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/SparseCompactVector.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / SparseCompactVector

# Type Alias: SparseCompactVector

```ts
type SparseCompactVector = {
  sparseType: SparseCompactType;
  tag: "vector";
};
```

A data structure indicating the locations of contract references in a Compact vector.

## Properties

### sparseType

```ts
sparseType: SparseCompactType;
```

A data structure indicating the locations of contract references in the elements of a Compact vector.

***

### tag

```ts
tag: "vector";
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/TokenType.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / TokenType

# Type Alias: TokenType

```ts
type TokenType = string;
```

A token type (or color), as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Transcript.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Transcript

# Type Alias: Transcript

```ts
type Transcript = ocrt.Transcript<AlignedValue>;
```

A transcript of operations and their effects, for inclusion and replay in
transactions
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/type-aliases/Value.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Value

# Type Alias: Value

```ts
type Value = Uint8Array[];
```

An onchain data value, in field-aligned binary format.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/BooleanDescriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / BooleanDescriptor

# Variable: BooleanDescriptor

```ts
const BooleanDescriptor: CompactTypeBoolean;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/Bytes32Descriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / Bytes32Descriptor

# Variable: Bytes32Descriptor

```ts
const Bytes32Descriptor: CompactTypeBytes;
```

The following are type descriptors used to implement createCoinCommitment. They are not intended for direct
consumption.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/CoinInfoDescriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CoinInfoDescriptor

# Variable: CoinInfoDescriptor

```ts
const CoinInfoDescriptor: {
  alignment: Alignment;
  fromValue: {
     color: Uint8Array;
     nonce: Uint8Array;
     value: bigint;
  };
  toValue: Value;
};
```

## Type declaration

### alignment()

```ts
alignment(): Alignment;
```

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

### fromValue()

```ts
fromValue(value): {
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
};
```

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

```ts
{
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

##### color

```ts
color: Uint8Array;
```

##### nonce

```ts
nonce: Uint8Array;
```

##### value

```ts
value: bigint;
```

### toValue()

```ts
toValue(value): Value;
```

#### Parameters

##### value

###### color

`Uint8Array`

###### nonce

`Uint8Array`

###### value

`bigint`

#### Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/CoinRecipientDescriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / CoinRecipientDescriptor

# Variable: CoinRecipientDescriptor

```ts
const CoinRecipientDescriptor: {
  alignment: Alignment;
  fromValue: {
     is_left: boolean;
     left: {
        bytes: Uint8Array;
     };
     right: {
        bytes: Uint8Array;
     };
  };
  toValue: Value;
};
```

## Type declaration

### alignment()

```ts
alignment(): Alignment;
```

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

### fromValue()

```ts
fromValue(value): {
  is_left: boolean;
  left: {
     bytes: Uint8Array;
  };
  right: {
     bytes: Uint8Array;
  };
};
```

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

```ts
{
  is_left: boolean;
  left: {
     bytes: Uint8Array;
  };
  right: {
     bytes: Uint8Array;
  };
}
```

##### is\_left

```ts
is_left: boolean;
```

##### left

```ts
left: {
  bytes: Uint8Array;
};
```

###### left.bytes

```ts
bytes: Uint8Array;
```

##### right

```ts
right: {
  bytes: Uint8Array;
};
```

###### right.bytes

```ts
bytes: Uint8Array;
```

### toValue()

```ts
toValue(value): Value;
```

#### Parameters

##### value

###### is_left

`boolean`

###### left

\{
  `bytes`: `Uint8Array`;
\}

###### left.bytes

`Uint8Array`

###### right

\{
  `bytes`: `Uint8Array`;
\}

###### right.bytes

`Uint8Array`

#### Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/ContractAddressDescriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ContractAddressDescriptor

# Variable: ContractAddressDescriptor

```ts
const ContractAddressDescriptor: {
  alignment: Alignment;
  fromValue: {
     bytes: Uint8Array;
  };
  toValue: Value;
};
```

## Type declaration

### alignment()

```ts
alignment(): Alignment;
```

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

### fromValue()

```ts
fromValue(value): {
  bytes: Uint8Array;
};
```

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

```ts
{
  bytes: Uint8Array;
}
```

##### bytes

```ts
bytes: Uint8Array;
```

### toValue()

```ts
toValue(value): Value;
```

#### Parameters

##### value

###### bytes

`Uint8Array`

#### Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/DUMMY_ADDRESS.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / DUMMY\_ADDRESS

# Variable: ~~DUMMY\_ADDRESS~~

```ts
const DUMMY_ADDRESS: string;
```

A valid placeholder contract address

## Deprecated

Cannot handle [NetworkId](../enumerations/NetworkId.md)s, use
[dummyContractAddress](../functions/dummyContractAddress.md) instead.
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/MAX_FIELD.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / MAX\_FIELD

# Variable: MAX\_FIELD

```ts
const MAX_FIELD: bigint;
```

The maximum value representable in Compact's `Field` type

One less than the prime modulus of the proof system's scalar field
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/MaxUint8Descriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / MaxUint8Descriptor

# Variable: MaxUint8Descriptor

```ts
const MaxUint8Descriptor: CompactTypeUnsignedInteger;
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/versionString.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / versionString

# Variable: versionString

```ts
const versionString: string = "0.9.0";
```
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/variables/ZswapCoinPublicKeyDescriptor.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](../README.md)

***

[@midnight-ntwrk/compact-runtime](../globals.md) / ZswapCoinPublicKeyDescriptor

# Variable: ZswapCoinPublicKeyDescriptor

```ts
const ZswapCoinPublicKeyDescriptor: {
  alignment: Alignment;
  fromValue: {
     bytes: Uint8Array;
  };
  toValue: Value;
};
```

## Type declaration

### alignment()

```ts
alignment(): Alignment;
```

#### Returns

[`Alignment`](../type-aliases/Alignment.md)

### fromValue()

```ts
fromValue(value): {
  bytes: Uint8Array;
};
```

#### Parameters

##### value

[`Value`](../type-aliases/Value.md)

#### Returns

```ts
{
  bytes: Uint8Array;
}
```

##### bytes

```ts
bytes: Uint8Array;
```

### toValue()

```ts
toValue(value): Value;
```

#### Parameters

##### value

###### bytes

`Uint8Array`

#### Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/globals.md">
[**@midnight-ntwrk/compact-runtime v0.9.0**](README.md)

***

# @midnight-ntwrk/compact-runtime v0.9.0

## Enumerations

- [NetworkId](enumerations/NetworkId.md)

## Classes

- [CompactError](classes/CompactError.md)
- [CompactTypeBoolean](classes/CompactTypeBoolean.md)
- [CompactTypeBytes](classes/CompactTypeBytes.md)
- [CompactTypeCurvePoint](classes/CompactTypeCurvePoint.md)
- [CompactTypeEnum](classes/CompactTypeEnum.md)
- [CompactTypeField](classes/CompactTypeField.md)
- [CompactTypeMerkleTreeDigest](classes/CompactTypeMerkleTreeDigest.md)
- [CompactTypeMerkleTreePath](classes/CompactTypeMerkleTreePath.md)
- [CompactTypeMerkleTreePathEntry](classes/CompactTypeMerkleTreePathEntry.md)
- [CompactTypeOpaqueString](classes/CompactTypeOpaqueString.md)
- [CompactTypeOpaqueUint8Array](classes/CompactTypeOpaqueUint8Array.md)
- [CompactTypeUnsignedInteger](classes/CompactTypeUnsignedInteger.md)
- [CompactTypeVector](classes/CompactTypeVector.md)
- [ContractMaintenanceAuthority](classes/ContractMaintenanceAuthority.md)
- [ContractOperation](classes/ContractOperation.md)
- [ContractState](classes/ContractState.md)
- [CostModel](classes/CostModel.md)
- [QueryContext](classes/QueryContext.md)
- [QueryResults](classes/QueryResults.md)
- [StateBoundedMerkleTree](classes/StateBoundedMerkleTree.md)
- [StateMap](classes/StateMap.md)
- [StateValue](classes/StateValue.md)
- [VmResults](classes/VmResults.md)
- [VmStack](classes/VmStack.md)

## Interfaces

- [CircuitContext](interfaces/CircuitContext.md)
- [CircuitResults](interfaces/CircuitResults.md)
- [CompactType](interfaces/CompactType.md)
- [ConstructorContext](interfaces/ConstructorContext.md)
- [ConstructorResult](interfaces/ConstructorResult.md)
- [CurvePoint](interfaces/CurvePoint.md)
- [EncodedCoinInfo](interfaces/EncodedCoinInfo.md)
- [EncodedCoinPublicKey](interfaces/EncodedCoinPublicKey.md)
- [EncodedContractAddress](interfaces/EncodedContractAddress.md)
- [EncodedQualifiedCoinInfo](interfaces/EncodedQualifiedCoinInfo.md)
- [EncodedRecipient](interfaces/EncodedRecipient.md)
- [EncodedZswapLocalState](interfaces/EncodedZswapLocalState.md)
- [MerkleTreeDigest](interfaces/MerkleTreeDigest.md)
- [MerkleTreePath](interfaces/MerkleTreePath.md)
- [MerkleTreePathEntry](interfaces/MerkleTreePathEntry.md)
- [ProofData](interfaces/ProofData.md)
- [Recipient](interfaces/Recipient.md)
- [WitnessContext](interfaces/WitnessContext.md)
- [ZswapLocalState](interfaces/ZswapLocalState.md)

## Type Aliases

- [AlignedValue](type-aliases/AlignedValue.md)
- [Alignment](type-aliases/Alignment.md)
- [AlignmentAtom](type-aliases/AlignmentAtom.md)
- [AlignmentSegment](type-aliases/AlignmentSegment.md)
- [BlockContext](type-aliases/BlockContext.md)
- [CoinCommitment](type-aliases/CoinCommitment.md)
- [CoinInfo](type-aliases/CoinInfo.md)
- [CoinPublicKey](type-aliases/CoinPublicKey.md)
- [ContractAddress](type-aliases/ContractAddress.md)
- [ContractReferenceLocations](type-aliases/ContractReferenceLocations.md)
- [DomainSeperator](type-aliases/DomainSeperator.md)
- [Effects](type-aliases/Effects.md)
- [Fr](type-aliases/Fr.md)
- [GatherResult](type-aliases/GatherResult.md)
- [Key](type-aliases/Key.md)
- [Nonce](type-aliases/Nonce.md)
- [Nullifier](type-aliases/Nullifier.md)
- [Op](type-aliases/Op.md)
- [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md)
- [Signature](type-aliases/Signature.md)
- [SignatureVerifyingKey](type-aliases/SignatureVerifyingKey.md)
- [SigningKey](type-aliases/SigningKey.md)
- [SparseCompactADT](type-aliases/SparseCompactADT.md)
- [SparseCompactArrayLikeADT](type-aliases/SparseCompactArrayLikeADT.md)
- [SparseCompactCellADT](type-aliases/SparseCompactCellADT.md)
- [SparseCompactContractAddress](type-aliases/SparseCompactContractAddress.md)
- [SparseCompactListADT](type-aliases/SparseCompactListADT.md)
- [SparseCompactMapADT](type-aliases/SparseCompactMapADT.md)
- [SparseCompactSetADT](type-aliases/SparseCompactSetADT.md)
- [SparseCompactStruct](type-aliases/SparseCompactStruct.md)
- [SparseCompactType](type-aliases/SparseCompactType.md)
- [SparseCompactValue](type-aliases/SparseCompactValue.md)
- [SparseCompactVector](type-aliases/SparseCompactVector.md)
- [TokenType](type-aliases/TokenType.md)
- [Transcript](type-aliases/Transcript.md)
- [Value](type-aliases/Value.md)

## Variables

- [BooleanDescriptor](variables/BooleanDescriptor.md)
- [Bytes32Descriptor](variables/Bytes32Descriptor.md)
- [CoinInfoDescriptor](variables/CoinInfoDescriptor.md)
- [CoinRecipientDescriptor](variables/CoinRecipientDescriptor.md)
- [ContractAddressDescriptor](variables/ContractAddressDescriptor.md)
- [~~DUMMY\_ADDRESS~~](variables/DUMMY_ADDRESS.md)
- [MAX\_FIELD](variables/MAX_FIELD.md)
- [MaxUint8Descriptor](variables/MaxUint8Descriptor.md)
- [versionString](variables/versionString.md)
- [ZswapCoinPublicKeyDescriptor](variables/ZswapCoinPublicKeyDescriptor.md)

## Functions

- [addField](functions/addField.md)
- [alignedConcat](functions/alignedConcat.md)
- [assert](functions/assert.md)
- [bigIntToValue](functions/bigIntToValue.md)
- [checkProofData](functions/checkProofData.md)
- [coinCommitment](functions/coinCommitment.md)
- [constructorContext](functions/constructorContext.md)
- [contractDependencies](functions/contractDependencies.md)
- [convertBytesToField](functions/convertBytesToField.md)
- [convertBytesToUint](functions/convertBytesToUint.md)
- [convertFieldToBytes](functions/convertFieldToBytes.md)
- [createZswapInput](functions/createZswapInput.md)
- [createZswapOutput](functions/createZswapOutput.md)
- [decodeCoinInfo](functions/decodeCoinInfo.md)
- [decodeCoinPublicKey](functions/decodeCoinPublicKey.md)
- [decodeContractAddress](functions/decodeContractAddress.md)
- [decodeQualifiedCoinInfo](functions/decodeQualifiedCoinInfo.md)
- [decodeRecipient](functions/decodeRecipient.md)
- [decodeTokenType](functions/decodeTokenType.md)
- [decodeZswapLocalState](functions/decodeZswapLocalState.md)
- [degradeToTransient](functions/degradeToTransient.md)
- [dummyContractAddress](functions/dummyContractAddress.md)
- [ecAdd](functions/ecAdd.md)
- [ecMul](functions/ecMul.md)
- [ecMulGenerator](functions/ecMulGenerator.md)
- [emptyZswapLocalState](functions/emptyZswapLocalState.md)
- [encodeCoinInfo](functions/encodeCoinInfo.md)
- [encodeCoinPublicKey](functions/encodeCoinPublicKey.md)
- [encodeContractAddress](functions/encodeContractAddress.md)
- [encodeQualifiedCoinInfo](functions/encodeQualifiedCoinInfo.md)
- [encodeRecipient](functions/encodeRecipient.md)
- [encodeTokenType](functions/encodeTokenType.md)
- [encodeZswapLocalState](functions/encodeZswapLocalState.md)
- [hasCoinCommitment](functions/hasCoinCommitment.md)
- [hashToCurve](functions/hashToCurve.md)
- [leafHash](functions/leafHash.md)
- [maxAlignedSize](functions/maxAlignedSize.md)
- [mulField](functions/mulField.md)
- [ownPublicKey](functions/ownPublicKey.md)
- [persistentCommit](functions/persistentCommit.md)
- [persistentHash](functions/persistentHash.md)
- [runProgram](functions/runProgram.md)
- [sampleContractAddress](functions/sampleContractAddress.md)
- [sampleSigningKey](functions/sampleSigningKey.md)
- [sampleTokenType](functions/sampleTokenType.md)
- [signatureVerifyingKey](functions/signatureVerifyingKey.md)
- [signData](functions/signData.md)
- [subField](functions/subField.md)
- [tokenType](functions/tokenType.md)
- [transientCommit](functions/transientCommit.md)
- [transientHash](functions/transientHash.md)
- [type\_error](functions/type_error.md)
- [upgradeFromTransient](functions/upgradeFromTransient.md)
- [valueToBigInt](functions/valueToBigInt.md)
- [verifySignature](functions/verifySignature.md)
- [witnessContext](functions/witnessContext.md)
</file>

<file path="docs/develop/reference/midnight-api/compact-runtime/README.md">
# Compact runtime API

**@midnight-ntwrk/compact-runtime v0.9.0**

***

# Compact runtime library

This API provides runtime primitives used by Compact's TypeScript output, both
for use by the compiler output directly, and to utilise it or reproduce its
behaviour. This API re-exports a number of items from
`@midnight-ntwrk/onchain-runtime`, and wraps others in a more TypeScript-friendly
API. Key parts of the API are:

-  setNetworkId, required to ensure the right network is being targeted
- [CircuitContext](interfaces/CircuitContext.md), and [CircuitResults](interfaces/CircuitResults.md) part of the input and
  output definition of all circuits
- [WitnessContext](interfaces/WitnessContext.md), part of the input definition of all circuits
- Built-in functions:
  - Hashing/commitment
    - [transientHash](functions/transientHash.md)
    - [transientCommit](functions/transientCommit.md)
    - [persistentHash](functions/persistentHash.md)
    - [persistentCommit](functions/persistentCommit.md)
    - [degradeToTransient](functions/degradeToTransient.md)
  - Elliptic curve
    - [ecAdd](functions/ecAdd.md)
    - [ecMul](functions/ecMul.md)
    - [ecMulGenerator](functions/ecMulGenerator.md)
    - [hashToCurve](functions/hashToCurve.md)
- [ContractState](classes/ContractState.md), encapsulating the entirety of a smart contract's
  on-chain state
- [StateValue](classes/StateValue.md), encoding data a contract maintains on-chain
- [QueryContext](classes/QueryContext.md), providing an annotated view into the contract state,
  against which on-chain VM programs can be run
- [CompactType](interfaces/CompactType.md), providing a runtime representation of basic Compact
  datatypes
- Various TypeScript types matching same-named Compact types
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/classes/APIError.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / APIError

# Class: APIError

Whenever there's a function called that returns a promise,
an error with the shape can be thrown.

## Extends

- `CustomError`

## Constructors

### new APIError()

> **new APIError**(`code`, `reason`): [`APIError`](APIError.md)

#### Parameters

##### code

[`ErrorCode`](../type-aliases/ErrorCode.md)

##### reason

`string`

#### Returns

[`APIError`](APIError.md)

#### Overrides

`CustomError.constructor`

## Properties

### code

> **code**: [`ErrorCode`](../type-aliases/ErrorCode.md)

The code of the error that's thrown

***

### reason

> **reason**: `string`

The reason the error is thrown
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/interfaces/DAppConnectorAPI.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / DAppConnectorAPI

# Interface: DAppConnectorAPI

DApp Connector API Definition

When errors occur in functions returning a promise, they should be thrown in the form of an [APIError](../classes/APIError.md).

## Properties

### apiVersion

> **apiVersion**: `string`

Semver string. DApps are encouraged to check the compatibility whenever this changes.

***

### enable()

> **enable**: () => `Promise`\<[`DAppConnectorWalletAPI`](DAppConnectorWalletAPI.md)\>

Request access to the wallet, returns the wallet api on approval

#### Returns

`Promise`\<[`DAppConnectorWalletAPI`](DAppConnectorWalletAPI.md)\>

***

### isEnabled()

> **isEnabled**: () => `Promise`\<`boolean`\>

Check if the wallet has authorized the dapp

#### Returns

`Promise`\<`boolean`\>

***

### name

> **name**: `string`

The name of the wallet

***

### serviceUriConfig()

> **serviceUriConfig**: () => `Promise`\<[`ServiceUriConfig`](ServiceUriConfig.md)\>

Request the services (indexer, node, and proof server) URIs.

#### Returns

`Promise`\<[`ServiceUriConfig`](ServiceUriConfig.md)\>
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/interfaces/DAppConnectorWalletAPI.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / DAppConnectorWalletAPI

# Interface: DAppConnectorWalletAPI

Shape of the Wallet API in the DApp Connector

## Properties

### balanceAndProveTransaction()

> **balanceAndProveTransaction**: (`tx`, `newCoins`) => `Promise`\<`Transaction`\>

It will try to balance given transaction and prove it

#### Parameters

##### tx

`Transaction`

Transaction to balance

##### newCoins

`CoinInfo`[]

New coins created by transaction, for which wallet will watch for

#### Returns

`Promise`\<`Transaction`\>

Proved transaction or error

***

### ~~balanceTransaction()~~

> **balanceTransaction**: (`tx`, `newCoins`) => `Promise`\<`BalanceTransactionToProve` \| `NothingToProve`\>

Balances the provided transaction.

#### Parameters

##### tx

`Transaction`

Transaction to balance

##### newCoins

`CoinInfo`[]

CoinInfo array of coins created by the transaction, which the wallet will watch for and apply to the state

The `newCoins` parameter should be used in cases where a new coin is created (for example, a DApp mints a coin and wants to send it to the wallet).
Because of how Midnight works, newly created coins must be explicitly sent to the wallet using this method. This allows the wallet to monitor them and
incorporate them into its state.

#### Returns

`Promise`\<`BalanceTransactionToProve` \| `NothingToProve`\>

BalanceTransactionToProve or NothingToProve recipe (for the already balanced transaction) or error.

#### Remarks

Balancing a transaction means that for any given output and transaction fees, the wallet will take the available coins
from the state to cover them.

#### Deprecated

Deprecated since version 1.1.0 and will be removed in version 2.0.0. Please use the `balanceAndProveTransaction` method instead.

***

### ~~proveTransaction()~~

> **proveTransaction**: (`recipe`) => `Promise`\<`Transaction`\>

Calls the proving server with the proving recipe and returns the proven transaction or error.

#### Parameters

##### recipe

`ProvingRecipe`

ProvingRecipe with data to prove

#### Returns

`Promise`\<`Transaction`\>

Transaction or error

#### Remarks

- Proof generation takes time and resources, therefore depending on the user's computer specs, this can be an expensive operation
- There can be wallet implementations that do not need to support proving, in which case this method should return an error

#### Deprecated

Deprecated since version 1.1.0 and will be removed in version 2.0.0. Please use the `balanceAndProveTransaction` method instead.

***

### state()

> **state**: () => `Promise`\<[`DAppConnectorWalletState`](DAppConnectorWalletState.md)\>

Returns a promise with the exposed wallet state

#### Returns

`Promise`\<[`DAppConnectorWalletState`](DAppConnectorWalletState.md)\>

***

### submitTransaction()

> **submitTransaction**: (`tx`) => `Promise`\<`string`\>

It will submit given transaction to the node

Submits the provided transaction to the node

#### Parameters

##### tx

`Transaction`

Transaction to submit

#### Returns

`Promise`\<`string`\>

TransactionIdentifier - First transaction identifier from identifiers list or error

#### Param

Transaction to submit

#### Returns

First transaction identifier from identifiers list or error
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/interfaces/DAppConnectorWalletState.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / DAppConnectorWalletState

# Interface: DAppConnectorWalletState

The shape of the wallet state that must be exposed

## Properties

### address

> **address**: `string`

The bech32m encoded address

***

### ~~addressLegacy~~

> **addressLegacy**: `string`

#### Deprecated

please use the `address` field instead.

The wallet address, which is a concatenation of coinPublicKey and encryptionPublicKey

***

### coinPublicKey

> **coinPublicKey**: `string`

The bech32m encoded coin public key

***

### ~~coinPublicKeyLegacy~~

> **coinPublicKeyLegacy**: `string`

#### Deprecated

please use the `coinPublicKey` field instead.

The hex encoded coin public key

***

### encryptionPublicKey

> **encryptionPublicKey**: `string`

The bech32m encoded encryption public key

***

### ~~encryptionPublicKeyLegacy~~

> **encryptionPublicKeyLegacy**: `string`

#### Deprecated

please use the `encryptionPublicKey` field instead.

The hex encoded encryption public key
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/interfaces/ServiceUriConfig.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ServiceUriConfig

# Interface: ServiceUriConfig

The services configuration

## Properties

### indexerUri

> **indexerUri**: `string`

Indexer URI

***

### indexerWsUri

> **indexerWsUri**: `string`

Indexer WebSocket URI

***

### proverServerUri

> **proverServerUri**: `string`

Prover Server URI

***

### substrateNodeUri

> **substrateNodeUri**: `string`

Substrate URI
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/type-aliases/ErrorCode.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ErrorCode

# Type Alias: ErrorCode

> **ErrorCode**: *typeof* [`ErrorCodes`](../variables/ErrorCodes.md)\[keyof *typeof* [`ErrorCodes`](../variables/ErrorCodes.md)\]

ErrorCode type definition
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/variables/ErrorCodes.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](../README.md)

***

[@midnight-ntwrk/dapp-connector-api](../globals.md) / ErrorCodes

# Variable: ErrorCodes

> `const` **ErrorCodes**: `object`

The following error codes can be thrown by the dapp connector.

## Type declaration

### InternalError

> `readonly` **InternalError**: `"InternalError"` = `'InternalError'`

The dapp connector wasn't able to process the request

### InvalidRequest

> `readonly` **InvalidRequest**: `"InvalidRequest"` = `'InvalidRequest'`

Can be thrown in various circumstances, e.g. one being a malformed transaction

### Rejected

> `readonly` **Rejected**: `"Rejected"` = `'Rejected'`

The user rejected the request
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/globals.md">
[**@midnight-ntwrk/dapp-connector-api v3.0.0**](README.md)

***

# @midnight-ntwrk/dapp-connector-api v3.0.0

## Classes

- [APIError](classes/APIError.md)

## Interfaces

- [DAppConnectorAPI](interfaces/DAppConnectorAPI.md)
- [DAppConnectorWalletAPI](interfaces/DAppConnectorWalletAPI.md)
- [DAppConnectorWalletState](interfaces/DAppConnectorWalletState.md)
- [ServiceUriConfig](interfaces/ServiceUriConfig.md)

## Type Aliases

- [ErrorCode](type-aliases/ErrorCode.md)

## Variables

- [ErrorCodes](variables/ErrorCodes.md)
</file>

<file path="docs/develop/reference/midnight-api/dapp-connector/README.md">
# DApp connector API

**@midnight-ntwrk/dapp-connector-api v3.0.0**

***

# Midnight DApp connector API

This API provides a comprehensive interface for the DApp connector operations, defining the structure of the wallet state it exposes, the methods for interacting with it, and the types and variables used within.

## Installation

The Midnight DApp connector API is available as an NPM package with the namespace `@midnight-ntwrk/dapp-connector-api`. It can be installed using any node package manager, such as Yarn. To install the package using Yarn, execute the following command:

`yarn add @midnight-ntwrk/dapp-connector-api`

## Package usage

The package provides the type declarations that are documented in the [documentation](interfaces/DAppConnectorAPI.md) of this package.

The DApp connector API should be exposed through the global variable as follows:

`window.midnight.{walletName}`

## Available methods

| Name | Description |
|---|---|
| **apiVersion** | Provides a semver string version of the DApp connector API  |
| **enable** | Returns a promise with the [DAppConnectorWalletAPI](interfaces/DAppConnectorWalletAPI.md) or error |
| **isEnabled** | Returns a promise with a boolean showing whether the DApp is authorized to access the API or not |
| **name** | The name of the wallet that implements the API |
| **serviceUriConfig** | Returns a promise with [ServiceUriConfig](interfaces/ServiceUriConfig.md) or error if the DApp is not authorized. |

## API usage

## Authorizing a DApp

To authorize a DApp, call the `enable()` method and wait for the user to respond to the request.

```ts
try {
  const api = await window.midnight.{walletName}.enable();

  // api is available here
} catch (error) {
  console.log('an error occurred', error);
}
```

## Checking if the DApp is authorized

To check if the DApp is authorized, use the `isEnabled()` method as follows:

```ts
try {
  const isEnabled = await window.midnight.{walletName}.isEnabled();
} catch (error) {
  console.log('an error occurred', error);
}
```

## Getting information about the DApp connector API

### Name
To get the name of the wallet, use the `name` property in the implemented DApp connector API:

```ts
const name = window.midnight.{walletName}.name;

console.log('Wallet name', name);
```

### API version
To get the API version, use the `apiVersion` property as follows:

```ts
const apiVersion = window.midnight.{walletName}.apiVersion;

console.log('API version', apiVersion);
```

### Getting the service URI config

Midnight wallet users can configure the node, indexer, and proving server URIs in the wallet settings. To enable DApps to access and utilize these URLs, the following property is exposed:

| Name | Description |
|---|---|
| **Node URL** | The node the wallet is pointing to  |
| **Indexer URL** | The indexer URL the wallet is pointing to |
| **Proving Server URL** | The proving server URL the wallet is pointing to |

To get the service URI config, use the API as follows:

```ts
try {
  const serviceUriConfig = await window.midnight.{walletName}.serviceUriConfig();

  console.log('serviceUriConfig', serviceUriConfig);
} catch (error) {
  console.log('an error occurred', error);
}
```

**Note:** The DApp must be authorized before calling this method, otherwise it will throw an error.

## Interacting with the API

After calling the `enable()` method and the user approves the authorization request, you will receive an instance of the [DAppConnectorWalletAPI](interfaces/DAppConnectorWalletAPI.md), which includes the following properties:

| Name | Description | Note |
|---|---|---|
| **balanceAndProveTransaction** | Balances and proves a transaction  | - |
| **submitTransaction** | Submits a balanced and proven transaction | - |
| **state** | Returns [DAppConnectorWalletState](interfaces/DAppConnectorWalletState.md) object | - |
| **balanceTransaction** | Balances a transaction | This method is deprecated and will be removed in version 2.0.0 |
| **proveTransaction** | Proves a transaction | This method is deprecated and will be removed in version 2.0.0 |

## Getting the wallet state

To get the wallet state, call the `state()` API method, which will return a promise with the [DAppConnectorWalletState](interfaces/DAppConnectorWalletState.md) object as follows:

```ts
try {
  const state = await api.state();

  console.log('Wallet state', state);
} catch (error) {
  console.log('an error occurred', error);
}
```

## Balancing and proving a transaction

To balance and prove a transaction, begin by creating a transaction in your DApp. You can [follow the guide on how to create a transaction here](docs/develop/guides/wallet-dev-guide.mdx#working-with-transactions).

This method accepts the following properties:

| Name | Data type | Required? |
|---|---|---|
| **transaction** | Transaction  | Yes |
| **newCoins** | CoinInfo[] | No |

Below, you'll find an example of how to balance and prove a transaction:

```ts
try {
  // assuming we have a transaction at hand here
  const transaction;

  const balancedAndProvenTransaction = await api.balanceAndProveTransaction(transaction);
} catch (error) {
  console.log('an error occurred', error);
}
```

## Submitting a transaction

With the balanced and proven transaction from above, you can now submit it.

The `submitTransaction()` method accepts the following parameters:

| Name | Data type | Required? |
|---|---|---|
| **transaction** | Transaction  | Yes |

Below, you'll find an example of how to submit a transaction:

```ts
try {
  const submittedTransaction = await api.submitTransaction(balancedAndProvenTransaction);
} catch (error) {
  console.log('an error occurred', error);
}
```

## Examples
In this section, you'll find examples demonstrating how to fully utilize the DApp connector API.

### Submitting a transaction

This example demonstrates how to authorize and submit a transaction from a DApp's perspective using the DApp connector API.

```ts
try {
  const api = await window.midnight.{walletName}.enable();

  // assuming this is a transaction we've already created
  // [link to create transaction docs is in the "Balancing and proving a transaction" section]
  const transaction;

  const balancedAndProvenTransaction = await api.balanceAndProveTransaction(transaction);

  const submittedTx = await api.submitTransaction(balancedAndProvenTransaction);

  console.log(submittedTx);
} catch (error) {
  console.log('an error occurred', error);
}
```
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/AuthorizedMint.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / AuthorizedMint

# Class: AuthorizedMint

A request to mint a coin, authorized by the mint's recipient

## Constructors

### new AuthorizedMint()

```ts
private new AuthorizedMint(): AuthorizedMint
```

#### Returns

[`AuthorizedMint`](AuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### erase\_proof()

```ts
erase_proof(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): AuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`AuthorizedMint`](AuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractCall.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractCall

# Class: ContractCall

A single contract call segment

## Constructors

### new ContractCall()

```ts
private new ContractCall(): ContractCall
```

#### Returns

[`ContractCall`](ContractCall.md)

## Properties

### address

```ts
readonly address: string;
```

The address being called

***

### communicationCommitment

```ts
readonly communicationCommitment: string;
```

The communication commitment of this call

***

### entryPoint

```ts
readonly entryPoint: string | Uint8Array;
```

The entry point being called

***

### fallibleTranscript

```ts
readonly fallibleTranscript: undefined | Transcript<AlignedValue>;
```

The fallible execution stage transcript

***

### guaranteedTranscript

```ts
readonly guaranteedTranscript: undefined | Transcript<AlignedValue>;
```

The guaranteed execution stage transcript

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractCallPrototype.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractCallPrototype

# Class: ContractCallPrototype

A [ContractCall](ContractCall.md) still being assembled

## Constructors

### new ContractCallPrototype(address, entry_point, op, guaranteed_public_transcript, fallible_public_transcript, private_transcript_outputs, input, output, communication_commitment_rand, key_location)

```ts
new ContractCallPrototype(
   address, 
   entry_point, 
   op, 
   guaranteed_public_transcript, 
   fallible_public_transcript, 
   private_transcript_outputs, 
   input, 
   output, 
   communication_commitment_rand, 
   key_location): ContractCallPrototype
```

#### Parameters

• **address**: `string`

The address being called

• **entry\_point**: `string` \| `Uint8Array`

The entry point being called

• **op**: [`ContractOperation`](ContractOperation.md)

The operation expected at this entry point

• **guaranteed\_public\_transcript**: `undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>

The guaranteed transcript computed
for this call

• **fallible\_public\_transcript**: `undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>

The fallible transcript computed for
this call

• **private\_transcript\_outputs**: [`AlignedValue`](../type-aliases/AlignedValue.md)[]

The private transcript recorded for
this call

• **input**: [`AlignedValue`](../type-aliases/AlignedValue.md)

The input(s) provided to this call

• **output**: [`AlignedValue`](../type-aliases/AlignedValue.md)

The output(s) computed from this call

• **communication\_commitment\_rand**: `string`

The communication randomness used
for this call

• **key\_location**: `string`

An identifier for how the key for this call may be
looked up

#### Returns

[`ContractCallPrototype`](ContractCallPrototype.md)

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractCallsPrototype.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractCallsPrototype

# Class: ContractCallsPrototype

An atomic collection of [ContractAction](../type-aliases/ContractAction.md)s, which may interact
with each other

## Constructors

### new ContractCallsPrototype()

```ts
new ContractCallsPrototype(): ContractCallsPrototype
```

#### Returns

[`ContractCallsPrototype`](ContractCallsPrototype.md)

## Methods

### addCall()

```ts
addCall(call): ContractCallsPrototype
```

#### Parameters

• **call**: [`ContractCallPrototype`](ContractCallPrototype.md)

#### Returns

[`ContractCallsPrototype`](ContractCallsPrototype.md)

***

### addDeploy()

```ts
addDeploy(deploy): ContractCallsPrototype
```

#### Parameters

• **deploy**: [`ContractDeploy`](ContractDeploy.md)

#### Returns

[`ContractCallsPrototype`](ContractCallsPrototype.md)

***

### addMaintenanceUpdate()

```ts
addMaintenanceUpdate(upd): ContractCallsPrototype
```

#### Parameters

• **upd**: [`MaintenanceUpdate`](MaintenanceUpdate.md)

#### Returns

[`ContractCallsPrototype`](ContractCallsPrototype.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractDeploy.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractDeploy

# Class: ContractDeploy

A contract deployment segment, instructing the creation of a new contract
address, if not already present

## Constructors

### new ContractDeploy(initial_state)

```ts
new ContractDeploy(initial_state): ContractDeploy
```

Creates a deployment for an arbitrary contract state

The deployment and its address are randomised.

#### Parameters

• **initial\_state**: [`ContractState`](ContractState.md)

#### Returns

[`ContractDeploy`](ContractDeploy.md)

## Properties

### address

```ts
readonly address: string;
```

The address this deployment will attempt to create

***

### initialState

```ts
readonly initialState: ContractState;
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractMaintenanceAuthority.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractMaintenanceAuthority

# Class: ContractMaintenanceAuthority

A committee permitted to make changes to this contract. If a threshold of
the public keys in this committee sign off, they can change the rules of
this contract, or recompile it for a new version.

If the threshold is greater than the number of committee members, it is
impossible for them to sign anything.

## Constructors

### new ContractMaintenanceAuthority(committee, threshold, counter)

```ts
new ContractMaintenanceAuthority(
   committee, 
   threshold, 
   counter?): ContractMaintenanceAuthority
```

Constructs a new authority from its components

#### Parameters

• **committee**: `string`[]

• **threshold**: `number`

• **counter?**: `bigint`

#### Returns

[`ContractMaintenanceAuthority`](ContractMaintenanceAuthority.md)

## Properties

### committee

```ts
readonly committee: string[];
```

The committee public keys

***

### counter

```ts
readonly counter: bigint;
```

The replay protection counter

***

### threshold

```ts
readonly threshold: number;
```

How many keys must sign rule changes

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractState`](ContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractOperation.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractOperation

# Class: ContractOperation

An individual operation, or entry point of a contract, consisting primarily
of a ZK verifier keys, potentially for different versions of the proving
system.

Only the latest available version is exposed to this API.

Note that the serialized form of the key is checked on initialization

## Constructors

### new ContractOperation()

```ts
new ContractOperation(): ContractOperation
```

#### Returns

[`ContractOperation`](ContractOperation.md)

## Properties

### verifierKey

```ts
verifierKey: Uint8Array;
```

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractOperation
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractOperation`](ContractOperation.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractOperationVersion.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractOperationVersion

# Class: ContractOperationVersion

The version associated with a [ContractOperation](ContractOperation.md)

## Constructors

### new ContractOperationVersion(version)

```ts
new ContractOperationVersion(version): ContractOperationVersion
```

#### Parameters

• **version**: `"v1"`

#### Returns

[`ContractOperationVersion`](ContractOperationVersion.md)

## Properties

### version

```ts
readonly version: "v1";
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractOperationVersionedVerifierKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractOperationVersionedVerifierKey

# Class: ContractOperationVersionedVerifierKey

A versioned verifier key to be associated with a [ContractOperation](ContractOperation.md).

## Constructors

### new ContractOperationVersionedVerifierKey(version, rawVk)

```ts
new ContractOperationVersionedVerifierKey(version, rawVk): ContractOperationVersionedVerifierKey
```

#### Parameters

• **version**: `"v1"`

• **rawVk**: `Uint8Array`

#### Returns

[`ContractOperationVersionedVerifierKey`](ContractOperationVersionedVerifierKey.md)

## Properties

### rawVk

```ts
readonly rawVk: Uint8Array;
```

***

### version

```ts
readonly version: "v1";
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ContractState.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractState

# Class: ContractState

The state of a contract, consisting primarily of the [data](ContractState.md#data) accessible
directly to the contract, and the map of [ContractOperation](ContractOperation.md)s that can
be called on it, the keys of which can be accessed with [operations](ContractState.md#operations),
and the individual operations can be read with [operation](ContractState.md#operation) and written
to with [setOperation](ContractState.md#setoperation).

## Constructors

### new ContractState()

```ts
new ContractState(): ContractState
```

Creates a blank contract state

#### Returns

[`ContractState`](ContractState.md)

## Properties

### data

```ts
data: StateValue;
```

The current value of the primary state of the contract

***

### maintenanceAuthority

```ts
maintenanceAuthority: ContractMaintenanceAuthority;
```

The maintenance authority associated with this contract

## Methods

### operation()

```ts
operation(operation): undefined | ContractOperation
```

Get the operation at a specific entry point name

#### Parameters

• **operation**: `string` \| `Uint8Array`

#### Returns

`undefined` \| [`ContractOperation`](ContractOperation.md)

***

### operations()

```ts
operations(): (string | Uint8Array)[]
```

Return a list of the entry points currently registered on this contract

#### Returns

(`string` \| `Uint8Array`)[]

***

### query()

```ts
query(query, cost_model): GatherResult[]
```

Runs a series of operations against the current state, and returns the
results

#### Parameters

• **query**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`GatherResult`](../type-aliases/GatherResult.md)[]

***

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### setOperation()

```ts
setOperation(operation, value): void
```

Set a specific entry point name to contain a given operation

#### Parameters

• **operation**: `string` \| `Uint8Array`

• **value**: [`ContractOperation`](ContractOperation.md)

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractState`](ContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/CostModel.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CostModel

# Class: CostModel

A cost model for calculating transaction fees

## Constructors

### new CostModel()

```ts
private new CostModel(): CostModel
```

#### Returns

[`CostModel`](CostModel.md)

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### dummyCostModel()

```ts
static dummyCostModel(): CostModel
```

A cost model for use in non-critical contexts

#### Returns

[`CostModel`](CostModel.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/EncryptionSecretKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / EncryptionSecretKey

# Class: EncryptionSecretKey

Holds the encryption secret key of a user, which may be used to determine if
a given offer contains outputs addressed to this user

## Constructors

### new EncryptionSecretKey()

```ts
private new EncryptionSecretKey(): EncryptionSecretKey
```

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)

## Methods

### test()

```ts
test(offer): boolean
```

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

`boolean`

***

### yesIKnowTheSecurityImplicationsOfThis\_serialize()

```ts
yesIKnowTheSecurityImplicationsOfThis_serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### deserialize()

```ts
static deserialize(raw, netid): EncryptionSecretKey
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/Input.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Input

# Class: Input

A shielded transaction input

## Constructors

### new Input()

```ts
private new Input(): Input
```

#### Returns

[`Input`](Input.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Input
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Input`](Input.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/LedgerParameters.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / LedgerParameters

# Class: LedgerParameters

Parameters used by the Midnight ledger, including transaction fees and
bounds

## Constructors

### new LedgerParameters()

```ts
private new LedgerParameters(): LedgerParameters
```

#### Returns

[`LedgerParameters`](LedgerParameters.md)

## Properties

### transactionCostModel

```ts
readonly transactionCostModel: TransactionCostModel;
```

The cost model used for transaction fees contained in these parameters

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): LedgerParameters
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`LedgerParameters`](LedgerParameters.md)

***

### dummyParameters()

```ts
static dummyParameters(): LedgerParameters
```

A dummy set of testing parameters

#### Returns

[`LedgerParameters`](LedgerParameters.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/LedgerState.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / LedgerState

# Class: LedgerState

The state of the Midnight ledger

## Constructors

### new LedgerState(zswap)

```ts
new LedgerState(zswap): LedgerState
```

Initializes from a Zswap state, with an empty contract set

#### Parameters

• **zswap**: [`ZswapChainState`](ZswapChainState.md)

#### Returns

[`LedgerState`](LedgerState.md)

## Properties

### unmintedNativeTokenSupply

```ts
readonly unmintedNativeTokenSupply: bigint;
```

The remaining unminted supply of native tokens.

***

### zswap

```ts
readonly zswap: ZswapChainState;
```

The Zswap part of the ledger state

## Methods

### apply()

```ts
apply(transaction, context): [LedgerState, TransactionResult]
```

Applies a [ProofErasedTransaction](ProofErasedTransaction.md)

#### Parameters

• **transaction**: [`ProofErasedTransaction`](ProofErasedTransaction.md)

• **context**: [`TransactionContext`](TransactionContext.md)

#### Returns

[[`LedgerState`](LedgerState.md), [`TransactionResult`](TransactionResult.md)]

***

### applySystemTx()

```ts
applySystemTx(transaction): LedgerState
```

Applies a system transaction to this ledger state.

#### Parameters

• **transaction**: [`SystemTransaction`](SystemTransaction.md)

#### Returns

[`LedgerState`](LedgerState.md)

***

### index()

```ts
index(address): undefined | ContractState
```

Indexes into the contract state map with a given contract address

#### Parameters

• **address**: `string`

#### Returns

`undefined` \| [`ContractState`](ContractState.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### treasuryBalance()

```ts
treasuryBalance(token_type): bigint
```

Retrieves the balance of the treasury for a specific token type.

#### Parameters

• **token\_type**: `string`

#### Returns

`bigint`

***

### unclaimedMints()

```ts
unclaimedMints(recipient, token_type): bigint
```

How much in minting rewards a recipient, for a specific token type, is
owed and can claim.

#### Parameters

• **recipient**: `string`

• **token\_type**: `string`

#### Returns

`bigint`

***

### updateIndex()

```ts
updateIndex(address, context): LedgerState
```

Sets the state of a given contract address from a [QueryContext](QueryContext.md)

#### Parameters

• **address**: `string`

• **context**: [`QueryContext`](QueryContext.md)

#### Returns

[`LedgerState`](LedgerState.md)

***

### blank()

```ts
static blank(): LedgerState
```

A fully blank state

#### Returns

[`LedgerState`](LedgerState.md)

***

### deserialize()

```ts
static deserialize(raw, netid): LedgerState
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`LedgerState`](LedgerState.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/LocalState.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / LocalState

# Class: LocalState

The local state of a user/wallet, consisting of their secret key, and a set
of unspent coins.

It also keeps track of coins that are in-flight, either expecting to spend
or expecting to receive, and a local copy of the global coin commitment
Merkle tree to generate proofs against.

## Constructors

### new LocalState()

```ts
new LocalState(): LocalState
```

Creates a new state with a randomly sampled secret key

#### Returns

[`LocalState`](LocalState.md)

## Properties

### coinPublicKey

```ts
readonly coinPublicKey: string;
```

The coin public key of this wallet

***

### coins

```ts
readonly coins: Set<QualifiedCoinInfo>;
```

The set of *spendable* coins of this wallet

***

### encryptionPublicKey

```ts
readonly encryptionPublicKey: string;
```

The encryption public key of this wallet

***

### firstFree

```ts
readonly firstFree: bigint;
```

The first free index in the internal coin commitments Merkle tree.
This may be used to identify which merkle tree updates are necessary.

***

### pendingOutputs

```ts
readonly pendingOutputs: Map<string, CoinInfo>;
```

The outputs that this wallet is expecting to receive in the future

***

### pendingSpends

```ts
readonly pendingSpends: Map<string, QualifiedCoinInfo>;
```

The spends that this wallet is expecting to be finalized on-chain in the
future

## Methods

### apply()

```ts
apply(offer): LocalState
```

Locally applies an offer to the current state, returning the updated state

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyCollapsedUpdate()

```ts
applyCollapsedUpdate(update): LocalState
```

Applies a collapsed Merkle tree update to the current local state, fast
forwarding through the indices included in it, if it is a correct update.

The general flow for usage if Alice is in state A, and wants to ask Bob how to reach the new state B, is:
 - Find where she left off – what's her firstFree?
 - Find out where she's going – ask for Bob's firstFree.
 - Find what contents she does care about – ask Bob for the filtered
   entries she want to include proper in her tree.
 - In order, of Merkle tree indicies:
   - Insert (with `apply` offers Alice cares about).
   - Skip (with this method) sections Alice does not care about, obtaining
     the collapsed update covering the gap from Bob.
Note that `firstFree` is not included in the tree itself, and both ends of
updates *are* included.

#### Parameters

• **update**: [`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyFailed()

```ts
applyFailed(offer): LocalState
```

Locally marks an offer as failed, allowing inputs used in it to be
spendable once more.

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyFailedProofErased()

```ts
applyFailedProofErased(offer): LocalState
```

Locally marks an proof-erased offer as failed, allowing inputs used in it
to be spendable once more.

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyProofErased()

```ts
applyProofErased(offer): LocalState
```

Locally applies a proof-erased offer to the current state, returning the
updated state

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyProofErasedTx()

```ts
applyProofErasedTx(tx, res): LocalState
```

Locally applies a proof-erased transaction to the current state, returning
the updated state

#### Parameters

• **tx**: [`ProofErasedTransaction`](ProofErasedTransaction.md)

• **res**: `"success"` \| `"partialSuccess"` \| `"failure"`

The result type of applying this transaction against the
ledger state

#### Returns

[`LocalState`](LocalState.md)

***

### applySystemTx()

```ts
applySystemTx(tx): LocalState
```

Locally applies a system transaction to the current state, returning the
updated state

#### Parameters

• **tx**: [`SystemTransaction`](SystemTransaction.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyTx()

```ts
applyTx(tx, res): LocalState
```

Locally applies a transaction to the current state, returning the updated
state

#### Parameters

• **tx**: [`Transaction`](Transaction.md)

• **res**: `"success"` \| `"partialSuccess"` \| `"failure"`

The result type of applying this transaction against the
ledger state

#### Returns

[`LocalState`](LocalState.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### spend()

```ts
spend(coin): [LocalState, UnprovenInput]
```

Initiates a new spend of a specific coin, outputting the corresponding
[UnprovenInput](UnprovenInput.md), and the updated state marking this coin as
in-flight.

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

#### Returns

[[`LocalState`](LocalState.md), [`UnprovenInput`](UnprovenInput.md)]

***

### spendFromOutput()

```ts
spendFromOutput(coin, output): [LocalState, UnprovenTransient]
```

Initiates a new spend of a new-yet-received output, outputting the
corresponding [UnprovenTransient](UnprovenTransient.md), and the updated state marking
this coin as in-flight.

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

#### Returns

[[`LocalState`](LocalState.md), [`UnprovenTransient`](UnprovenTransient.md)]

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### watchFor()

```ts
watchFor(coin): LocalState
```

Adds a coin to the list of coins that are expected to be received

This should be used if an output is creating a coin for this wallet, which
does not contain a ciphertext to detect it. In this case, the wallet must
know the commitment ahead of time to notice the receipt.

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

#### Returns

[`LocalState`](LocalState.md)

***

### yesIKnowTheSecurityImplicationsOfThis\_encryptionSecretKey()

```ts
yesIKnowTheSecurityImplicationsOfThis_encryptionSecretKey(): EncryptionSecretKey
```

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)

***

### deserialize()

```ts
static deserialize(raw, netid): LocalState
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`LocalState`](LocalState.md)

***

### fromSeed()

```ts
static fromSeed(seed): LocalState
```

Creates a new state from a predefined random seed (which can act as a
recovery phrase)

#### Parameters

• **seed**: `Uint8Array`

#### Returns

[`LocalState`](LocalState.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/MaintenanceUpdate.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / MaintenanceUpdate

# Class: MaintenanceUpdate

A contract maintenance update, updating associated operations, or
changing the maintenance authority.

## Constructors

### new MaintenanceUpdate(address, updates, counter)

```ts
new MaintenanceUpdate(
   address, 
   updates, 
   counter): MaintenanceUpdate
```

#### Parameters

• **address**: `string`

• **updates**: [`SingleUpdate`](../type-aliases/SingleUpdate.md)[]

• **counter**: `bigint`

#### Returns

[`MaintenanceUpdate`](MaintenanceUpdate.md)

## Properties

### address

```ts
readonly address: string;
```

The address this deployment will attempt to create

***

### counter

```ts
readonly counter: bigint;
```

The counter this update is valid against

***

### dataToSign

```ts
readonly dataToSign: Uint8Array;
```

The raw data any valid signature must be over to approve this update.

***

### signatures

```ts
readonly signatures: [bigint, string][];
```

The signatures on this update

***

### updates

```ts
readonly updates: SingleUpdate[];
```

The updates to carry out

## Methods

### addSignature()

```ts
addSignature(idx, signature): MaintenanceUpdate
```

Adds a new signature to this update

#### Parameters

• **idx**: `bigint`

• **signature**: `string`

#### Returns

[`MaintenanceUpdate`](MaintenanceUpdate.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/MerkleTreeCollapsedUpdate.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / MerkleTreeCollapsedUpdate

# Class: MerkleTreeCollapsedUpdate

A compact delta on the coin commitments Merkle tree, used to keep local
spending trees in sync with the global state without requiring receiving all
transactions.

## Constructors

### new MerkleTreeCollapsedUpdate(state, start, end)

```ts
new MerkleTreeCollapsedUpdate(
   state, 
   start, 
   end): MerkleTreeCollapsedUpdate
```

Create a new compact update from a non-compact state, and inclusive
`start` and `end` indices

#### Parameters

• **state**: [`ZswapChainState`](ZswapChainState.md)

• **start**: `bigint`

• **end**: `bigint`

#### Returns

[`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)

#### Throws

If the indices are out-of-bounds for the state, or `end < start`

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): MerkleTreeCollapsedUpdate
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/Offer.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Offer

# Class: Offer

A full Zswap offer; the zswap part of a transaction

Consists of sets of [Input](Input.md)s, [Output](Output.md)s, and [Transient](Transient.md)s,
as well as a [deltas](Offer.md#deltas) vector of the transaction value

## Constructors

### new Offer()

```ts
private new Offer(): Offer
```

#### Returns

[`Offer`](Offer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: Input[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: Output[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: Transient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): Offer
```

Combine this offer with another

#### Parameters

• **other**: [`Offer`](Offer.md)

#### Returns

[`Offer`](Offer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Offer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Offer`](Offer.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/Output.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Output

# Class: Output

A shielded transaction output

## Constructors

### new Output()

```ts
private new Output(): Output
```

#### Returns

[`Output`](Output.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Output
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Output`](Output.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/PreTranscript.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / PreTranscript

# Class: PreTranscript

A transcript prior to partitioning, consisting of the context to run it in, the program that
will make up the transcript, and optionally a communication commitment to bind calls together.

## Constructors

### new PreTranscript(context, program, comm_comm)

```ts
new PreTranscript(
   context, 
   program, 
   comm_comm?): PreTranscript
```

#### Parameters

• **context**: [`QueryContext`](QueryContext.md)

• **program**: [`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

• **comm\_comm?**: `string`

#### Returns

[`PreTranscript`](PreTranscript.md)

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedAuthorizedMint.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedAuthorizedMint

# Class: ProofErasedAuthorizedMint

A request to mint a coin, authorized by the mint's recipient, with the
authorizing proof having been erased

## Constructors

### new ProofErasedAuthorizedMint()

```ts
private new ProofErasedAuthorizedMint(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedAuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedInput.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedInput

# Class: ProofErasedInput

A [Input](Input.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedInput()

```ts
private new ProofErasedInput(): ProofErasedInput
```

#### Returns

[`ProofErasedInput`](ProofErasedInput.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedInput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedInput`](ProofErasedInput.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedOffer.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedOffer

# Class: ProofErasedOffer

An [Offer](Offer.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedOffer()

```ts
private new ProofErasedOffer(): ProofErasedOffer
```

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: ProofErasedInput[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: ProofErasedOutput[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: ProofErasedTransient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): ProofErasedOffer
```

#### Parameters

• **other**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedOffer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedOutput.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedOutput

# Class: ProofErasedOutput

An [Output](Output.md) with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedOutput()

```ts
private new ProofErasedOutput(): ProofErasedOutput
```

#### Returns

[`ProofErasedOutput`](ProofErasedOutput.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedOutput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedOutput`](ProofErasedOutput.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedTransaction.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedTransaction

# Class: ProofErasedTransaction

[Transaction](Transaction.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedTransaction()

```ts
private new ProofErasedTransaction(): ProofErasedTransaction
```

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

## Properties

### contractCalls

```ts
readonly contractCalls: ContractAction[];
```

The contract interactions contained in this transaction

***

### fallibleCoins

```ts
readonly fallibleCoins: undefined | ProofErasedOffer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | ProofErasedOffer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | ProofErasedAuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### fees()

```ts
fees(params): bigint
```

The cost of this transaction, in the atomic unit of the base token

#### Parameters

• **params**: [`LedgerParameters`](LedgerParameters.md)

#### Returns

`bigint`

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### imbalances()

```ts
imbalances(guaranteed, fees?): Map<string, bigint>
```

For given fees, and a given section (guaranteed/fallible), what the
surplus or deficit of this transaction in any token type is.

#### Parameters

• **guaranteed**: `boolean`

• **fees?**: `bigint`

#### Returns

`Map`\<`string`, `bigint`\>

***

### merge()

```ts
merge(other): ProofErasedTransaction
```

Merges this transaction with another

#### Parameters

• **other**: [`ProofErasedTransaction`](ProofErasedTransaction.md)

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### wellFormed()

```ts
wellFormed(ref_state, strictness): void
```

Tests well-formedness criteria, optionally including transaction balancing

For obvious reasons, doesn't check proofs

#### Parameters

• **ref\_state**: [`LedgerState`](LedgerState.md)

• **strictness**: [`WellFormedStrictness`](WellFormedStrictness.md)

#### Returns

`void`

#### Throws

If the transaction is not well-formed for any reason

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedTransaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ProofErasedTransient.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ProofErasedTransient

# Class: ProofErasedTransient

A [Transient](Transient.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedTransient()

```ts
private new ProofErasedTransient(): ProofErasedTransient
```

#### Returns

[`ProofErasedTransient`](ProofErasedTransient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedTransient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedTransient`](ProofErasedTransient.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/QueryContext.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / QueryContext

# Class: QueryContext

Provides the information needed to fully process a transaction, including
information about the rest of the transaction, and the state of the chain at
the time of execution.

## Constructors

### new QueryContext(state, address)

```ts
new QueryContext(state, address): QueryContext
```

Construct a basic context from a contract's address and current state
value

#### Parameters

• **state**: [`StateValue`](StateValue.md)

• **address**: `string`

#### Returns

[`QueryContext`](QueryContext.md)

## Properties

### address

```ts
readonly address: string;
```

The address of the contract

***

### block

```ts
block: BlockContext;
```

The block-level information accessible to the contract

***

### comIndicies

```ts
readonly comIndicies: Map<string, bigint>;
```

The commitment indices map accessible to the contract, primarily via
[qualify](QueryContext.md#qualify)

***

### effects

```ts
effects: Effects;
```

The effects that occurred during execution against this context, should
match those declared in a [Transcript](../type-aliases/Transcript.md)

***

### state

```ts
readonly state: StateValue;
```

The current contract state retained in the context

## Methods

### insertCommitment()

```ts
insertCommitment(comm, index): QueryContext
```

Register a given coin commitment as being accessible at a specific index,
for use when receiving coins in-contract, and needing to record their
index to later spend them

#### Parameters

• **comm**: `string`

• **index**: `bigint`

#### Returns

[`QueryContext`](QueryContext.md)

***

### ~~intoTranscript()~~

```ts
intoTranscript(program, cost_model): [undefined | Transcript<AlignedValue>, undefined | Transcript<AlignedValue>]
```

Finalizes a sequence of operations against their initial context,
resulting in a guaranteed and fallible [Transcript](../type-aliases/Transcript.md), optimally
allocated, and heuristically covered for gas fees.

#### Parameters

• **program**: [`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>, `undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>]

#### Deprecated

Please use the ledger's `partitionTranscripts` instead.

***

### qualify()

`Internal`

```ts
qualify(coin): undefined | Value
```

Internal counterpart to [insertCommitment](QueryContext.md#insertcommitment); upgrades an encoded
[CoinInfo](../type-aliases/CoinInfo.md) to an encoded [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) using the
inserted commitments

#### Parameters

• **coin**: [`Value`](../type-aliases/Value.md)

#### Returns

`undefined` \| [`Value`](../type-aliases/Value.md)

***

### query()

```ts
query(
   ops, 
   cost_model, 
   gas_limit?): QueryResults
```

Runs a sequence of operations in gather mode, returning the results of the
gather.

#### Parameters

• **ops**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

• **gas\_limit?**: `bigint`

#### Returns

[`QueryResults`](QueryResults.md)

***

### runTranscript()

```ts
runTranscript(transcript, cost_model): QueryContext
```

Runs a transcript in verifying mode against the current query context,
outputting a new query context, with the [state](QueryContext.md#state) and [effects](QueryContext.md#effects)
from after the execution.

#### Parameters

• **transcript**: [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`QueryContext`](QueryContext.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/QueryResults.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / QueryResults

# Class: QueryResults

The results of making a query against a specific state or context

## Constructors

### new QueryResults()

```ts
private new QueryResults(): QueryResults
```

#### Returns

[`QueryResults`](QueryResults.md)

## Properties

### context

```ts
readonly context: QueryContext;
```

The context state after executing the query. This can be used to execute
further queries

***

### events

```ts
readonly events: GatherResult[];
```

Any events/results that occurred during or from the query

***

### gasCost

```ts
readonly gasCost: bigint;
```

The measured cost of executing the query

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ReplaceAuthority.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ReplaceAuthority

# Class: ReplaceAuthority

An update instruction to replace the current contract maintenance authority
with a new one.

## Constructors

### new ReplaceAuthority(authority)

```ts
new ReplaceAuthority(authority): ReplaceAuthority
```

#### Parameters

• **authority**: [`ContractMaintenanceAuthority`](ContractMaintenanceAuthority.md)

#### Returns

[`ReplaceAuthority`](ReplaceAuthority.md)

## Properties

### authority

```ts
readonly authority: ContractMaintenanceAuthority;
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/StateBoundedMerkleTree.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / StateBoundedMerkleTree

# Class: StateBoundedMerkleTree

Represents a fixed-depth Merkle tree storing hashed data, whose preimages
are unknown

## Constructors

### new StateBoundedMerkleTree(height)

```ts
new StateBoundedMerkleTree(height): StateBoundedMerkleTree
```

Create a blank tree with the given height

#### Parameters

• **height**: `number`

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

## Properties

### height

```ts
readonly height: number;
```

## Methods

### collapse()

`Internal`

```ts
collapse(start, end): StateBoundedMerkleTree
```

Erases all but necessary hashes between, and inclusive of, `start` and
`end` inidices

#### Parameters

• **start**: `bigint`

• **end**: `bigint`

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Throws

If the indices are out-of-bounds for the tree, or `end < start`

***

### findPathForLeaf()

`Internal`

```ts
findPathForLeaf(leaf): AlignedValue
```

Internal implementation of the finding path primitive

#### Parameters

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the leaf is not in the tree

***

### pathForLeaf()

`Internal`

```ts
pathForLeaf(index, leaf): AlignedValue
```

Internal implementation of the path construction primitive

#### Parameters

• **index**: `bigint`

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the index is out-of-bounds for the tree

***

### root()

`Internal`

```ts
root(): Value
```

Internal implementation of the merkle tree root primitive

#### Returns

[`Value`](../type-aliases/Value.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### update()

```ts
update(index, leaf): StateBoundedMerkleTree
```

Inserts a value into the Merkle tree, returning the updated tree

#### Parameters

• **index**: `bigint`

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Throws

If the index is out-of-bounds for the tree
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/StateMap.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / StateMap

# Class: StateMap

Represents a key-value map, where keys are [AlignedValue](../type-aliases/AlignedValue.md)s, and values
are [StateValue](StateValue.md)s.

## Constructors

### new StateMap()

```ts
new StateMap(): StateMap
```

#### Returns

[`StateMap`](StateMap.md)

## Methods

### get()

```ts
get(key): undefined | StateValue
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### insert()

```ts
insert(key, value): StateMap
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **value**: [`StateValue`](StateValue.md)

#### Returns

[`StateMap`](StateMap.md)

***

### keys()

```ts
keys(): AlignedValue[]
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)[]

***

### remove()

```ts
remove(key): StateMap
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateMap`](StateMap.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/StateValue.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / StateValue

# Class: StateValue

Represents the core of a contract's state, and recursively represents each
of its components.

There are different *classes* of state values:
- `null`
- Cells of [AlignedValue](../type-aliases/AlignedValue.md)s
- Maps from [AlignedValue](../type-aliases/AlignedValue.md)s to state values
- Bounded Merkle trees containing [AlignedValue](../type-aliases/AlignedValue.md) leaves
- Short (\<= 15 element) arrays of state values

State values are *immutable*, any operations that mutate states will return
a new state instead.

## Constructors

### new StateValue()

```ts
private new StateValue(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)

## Methods

### arrayPush()

```ts
arrayPush(value): StateValue
```

#### Parameters

• **value**: [`StateValue`](StateValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### asArray()

```ts
asArray(): undefined | StateValue[]
```

#### Returns

`undefined` \| [`StateValue`](StateValue.md)[]

***

### asBoundedMerkleTree()

```ts
asBoundedMerkleTree(): undefined | StateBoundedMerkleTree
```

#### Returns

`undefined` \| [`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

***

### asCell()

```ts
asCell(): AlignedValue
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

***

### asMap()

```ts
asMap(): undefined | StateMap
```

#### Returns

`undefined` \| [`StateMap`](StateMap.md)

***

### encode()

`Internal`

```ts
encode(): EncodedStateValue
```

#### Returns

[`EncodedStateValue`](../type-aliases/EncodedStateValue.md)

***

### logSize()

```ts
logSize(): number
```

#### Returns

`number`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### type()

```ts
type(): 
  | "map"
  | "null"
  | "cell"
  | "array"
  | "boundedMerkleTree"
```

#### Returns

  \| `"map"`
  \| `"null"`
  \| `"cell"`
  \| `"array"`
  \| `"boundedMerkleTree"`

***

### decode()

`Internal`

```ts
static decode(value): StateValue
```

#### Parameters

• **value**: [`EncodedStateValue`](../type-aliases/EncodedStateValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newArray()

```ts
static newArray(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)

***

### newBoundedMerkleTree()

```ts
static newBoundedMerkleTree(tree): StateValue
```

#### Parameters

• **tree**: [`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newCell()

```ts
static newCell(value): StateValue
```

#### Parameters

• **value**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newMap()

```ts
static newMap(map): StateValue
```

#### Parameters

• **map**: [`StateMap`](StateMap.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newNull()

```ts
static newNull(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/SystemTransaction.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / SystemTransaction

# Class: SystemTransaction

A priviledged transaction issued by the system.

## Constructors

### new SystemTransaction()

```ts
private new SystemTransaction(): SystemTransaction
```

#### Returns

[`SystemTransaction`](SystemTransaction.md)

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Transaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transaction`](Transaction.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/Transaction.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Transaction

# Class: Transaction

A Midnight transaction, consisting a section of [ContractAction](../type-aliases/ContractAction.md)s, and a guaranteed and fallible [Offer](Offer.md).

The guaranteed section are run first, and fee payment is taken during this
part. If it succeeds, the fallible section is also run, and atomically
rolled back if it fails.

## Constructors

### new Transaction()

```ts
private new Transaction(): Transaction
```

#### Returns

[`Transaction`](Transaction.md)

## Properties

### contractCalls

```ts
readonly contractCalls: ContractAction[];
```

The contract interactions contained in this transaction

***

### fallibleCoins

```ts
readonly fallibleCoins: undefined | Offer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | Offer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | AuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### eraseProofs()

```ts
eraseProofs(): ProofErasedTransaction
```

Erases the proofs contained in this transaction

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

***

### fees()

```ts
fees(params): bigint
```

The cost of this transaction, in the atomic unit of the base token

#### Parameters

• **params**: [`LedgerParameters`](LedgerParameters.md)

#### Returns

`bigint`

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### imbalances()

```ts
imbalances(guaranteed, fees?): Map<string, bigint>
```

For given fees, and a given section (guaranteed/fallible), what the
surplus or deficit of this transaction in any token type is.

#### Parameters

• **guaranteed**: `boolean`

• **fees?**: `bigint`

#### Returns

`Map`\<`string`, `bigint`\>

***

### merge()

```ts
merge(other): Transaction
```

Merges this transaction with another

#### Parameters

• **other**: [`Transaction`](Transaction.md)

#### Returns

[`Transaction`](Transaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### transactionHash()

```ts
transactionHash(): string
```

Returns the hash associated with this transaction. Due to the ability to
merge transactions, this should not be used to watch for a specific
transaction.

#### Returns

`string`

***

### wellFormed()

```ts
wellFormed(ref_state, strictness): void
```

Tests well-formedness criteria, optionally including transaction balancing

#### Parameters

• **ref\_state**: [`LedgerState`](LedgerState.md)

• **strictness**: [`WellFormedStrictness`](WellFormedStrictness.md)

#### Returns

`void`

#### Throws

If the transaction is not well-formed for any reason

***

### deserialize()

```ts
static deserialize(raw, netid): Transaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transaction`](Transaction.md)

***

### fromUnproven()

```ts
static fromUnproven(prove, unproven): Promise<Transaction>
```

Type hint that you should use an external proving function, for instance
via the proof server.

#### Parameters

• **prove**

• **unproven**: [`UnprovenTransaction`](UnprovenTransaction.md)

#### Returns

`Promise`\<[`Transaction`](Transaction.md)\>
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/TransactionContext.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TransactionContext

# Class: TransactionContext

The context against which a transaction is run.

## Constructors

### new TransactionContext(ref_state, block_context, whitelist)

```ts
new TransactionContext(
   ref_state, 
   block_context, 
   whitelist?): TransactionContext
```

#### Parameters

• **ref\_state**: [`LedgerState`](LedgerState.md)

A past ledger state that is used as a reference point
for 'static' data.

• **block\_context**: [`BlockContext`](../type-aliases/BlockContext.md)

Information about the block this transaction is, or
will be, contained in.

• **whitelist?**: `Set`\<`string`\>

A list of contracts that are being tracked, or
`undefined` to track all contracts.

#### Returns

[`TransactionContext`](TransactionContext.md)

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/TransactionCostModel.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TransactionCostModel

# Class: TransactionCostModel

## Constructors

### new TransactionCostModel()

```ts
private new TransactionCostModel(): TransactionCostModel
```

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)

## Properties

### inputFeeOverhead

```ts
readonly inputFeeOverhead: bigint;
```

The increase in fees to expect from adding a new input to a transaction

***

### outputFeeOverhead

```ts
readonly outputFeeOverhead: bigint;
```

The increase in fees to expect from adding a new output to a transaction

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): TransactionCostModel
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)

***

### dummyTransactionCostModel()

```ts
static dummyTransactionCostModel(): TransactionCostModel
```

A dummy cost model, for use in testing

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/TransactionResult.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TransactionResult

# Class: TransactionResult

The result status of applying a transaction.
Includes an error message if the transaction failed, or partially failed.

## Constructors

### new TransactionResult()

```ts
private new TransactionResult(): TransactionResult
```

#### Returns

[`TransactionResult`](TransactionResult.md)

## Properties

### error?

```ts
optional readonly error: string;
```

***

### type

```ts
readonly type: "success" | "partialSuccess" | "failure";
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/Transient.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Transient

# Class: Transient

A shielded "transient"; an output that is immediately spent within the same
transaction

## Constructors

### new Transient()

```ts
private new Transient(): Transient
```

#### Returns

[`Transient`](Transient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Transient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transient`](Transient.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenAuthorizedMint.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenAuthorizedMint

# Class: UnprovenAuthorizedMint

A request to mint a coin, authorized by the mint's recipient, without the
proof for the authorization being generated

## Constructors

### new UnprovenAuthorizedMint()

```ts
private new UnprovenAuthorizedMint(): UnprovenAuthorizedMint
```

#### Returns

[`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### erase\_proof()

```ts
erase_proof(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenAuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenInput.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenInput

# Class: UnprovenInput

A [Input](Input.md), before being proven

All "shielded" information in the input can still be extracted at this
stage!

## Constructors

### new UnprovenInput()

```ts
private new UnprovenInput(): UnprovenInput
```

#### Returns

[`UnprovenInput`](UnprovenInput.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenInput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenInput`](UnprovenInput.md)

***

### newContractOwned()

```ts
static newContractOwned(
   coin, 
   contract, 
   state): UnprovenInput
```

Creates a new input, spending a specific coin from a smart contract,
against a state which contains this coin.

Note that inputs created in this way *also* need to be authorized by the
contract

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **contract**: `string`

• **state**: [`ZswapChainState`](ZswapChainState.md)

#### Returns

[`UnprovenInput`](UnprovenInput.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenOffer.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenOffer

# Class: UnprovenOffer

A [Offer](Offer.md), prior to being proven

All "shielded" information in the offer can still be extracted at this
stage!

## Constructors

### new UnprovenOffer()

```ts
new UnprovenOffer(): UnprovenOffer
```

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: UnprovenInput[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: UnprovenOutput[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: UnprovenTransient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): UnprovenOffer
```

Combine this offer with another

#### Parameters

• **other**: [`UnprovenOffer`](UnprovenOffer.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenOffer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromInput()

```ts
static fromInput(
   input, 
   type_, 
   value): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenInput](UnprovenInput.md) and its value
vector

#### Parameters

• **input**: [`UnprovenInput`](UnprovenInput.md)

• **type\_**: `string`

• **value**: `bigint`

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromOutput()

```ts
static fromOutput(
   output, 
   type_, 
   value): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenOutput](UnprovenOutput.md) and its value
vector

#### Parameters

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

• **type\_**: `string`

• **value**: `bigint`

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromTransient()

```ts
static fromTransient(transient): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenTransient](UnprovenTransient.md)

#### Parameters

• **transient**: [`UnprovenTransient`](UnprovenTransient.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenOutput.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenOutput

# Class: UnprovenOutput

An [Output](Output.md) before being proven

All "shielded" information in the output can still be extracted at this
stage!

## Constructors

### new UnprovenOutput()

```ts
private new UnprovenOutput(): UnprovenOutput
```

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenOutput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

***

### new()

```ts
static new(
   coin, 
   target_cpk, 
   target_epk?): UnprovenOutput
```

Creates a new output, targeted to a user's coin public key.

Optionally the output contains a ciphertext encrypted to the user's
encryption public key, which may be omitted *only* if the [CoinInfo](../type-aliases/CoinInfo.md)
is transferred to the recipient another way

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

• **target\_cpk**: `string`

• **target\_epk?**: `string`

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

***

### newContractOwned()

```ts
static newContractOwned(coin, contract): UnprovenOutput
```

Creates a new output, targeted to a smart contract

A contract must *also* explicitly receive a coin created in this way for
the output to be valid

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

• **contract**: `string`

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenTransaction.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenTransaction

# Class: UnprovenTransaction

[Transaction](Transaction.md), prior to being proven

All "shielded" information in the transaction can still be extracted at this
stage!

## Constructors

### new UnprovenTransaction(guaranteed, fallible, calls)

```ts
new UnprovenTransaction(
   guaranteed, 
   fallible?, 
   calls?): UnprovenTransaction
```

Creates the transaction from guaranteed/fallible [UnprovenOffer](UnprovenOffer.md)s,
and a [ContractCallsPrototype](ContractCallsPrototype.md).

#### Parameters

• **guaranteed**: [`UnprovenOffer`](UnprovenOffer.md)

• **fallible?**: [`UnprovenOffer`](UnprovenOffer.md)

• **calls?**: [`ContractCallsPrototype`](ContractCallsPrototype.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

## Properties

### contractCalls

```ts
readonly contractCalls: ContractAction[];
```

The contract interactions contained in this transaction

***

### fallibleCoins

```ts
readonly fallibleCoins: undefined | UnprovenOffer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | UnprovenOffer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | UnprovenAuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### eraseProofs()

```ts
eraseProofs(): ProofErasedTransaction
```

Erases the proofs contained in this transaction

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### imbalances()

```ts
imbalances(guaranteed, fees?): Map<string, bigint>
```

For given fees, and a given section (guaranteed/fallible), what the
surplus or deficit of this transaction in any token type is.

#### Parameters

• **guaranteed**: `boolean`

• **fees?**: `bigint`

#### Returns

`Map`\<`string`, `bigint`\>

***

### merge()

```ts
merge(other): UnprovenTransaction
```

Merges this transaction with another

#### Parameters

• **other**: [`UnprovenTransaction`](UnprovenTransaction.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenTransaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

***

### fromMint()

```ts
static fromMint(mint): UnprovenTransaction
```

Creates a minting claim transaction, the funds claimed must have been
legitimately minted previously.

#### Parameters

• **mint**: [`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/UnprovenTransient.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / UnprovenTransient

# Class: UnprovenTransient

A [Transient](Transient.md), before being proven

All "shielded" information in the transient can still be extracted at this
stage!

## Constructors

### new UnprovenTransient()

```ts
private new UnprovenTransient(): UnprovenTransient
```

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenTransient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)

***

### newFromContractOwnedOutput()

```ts
static newFromContractOwnedOutput(coin, output): UnprovenTransient
```

Creates a new contract-owned transient, from a given output and its coin.

The [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) should have an `mt_index` of `0`

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/VerifierKeyInsert.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / VerifierKeyInsert

# Class: VerifierKeyInsert

An update instruction to insert a verifier key at a specific operation and
version.

## Constructors

### new VerifierKeyInsert(operation, vk)

```ts
new VerifierKeyInsert(operation, vk): VerifierKeyInsert
```

#### Parameters

• **operation**: `string` \| `Uint8Array`

• **vk**: [`ContractOperationVersionedVerifierKey`](ContractOperationVersionedVerifierKey.md)

#### Returns

[`VerifierKeyInsert`](VerifierKeyInsert.md)

## Properties

### operation

```ts
readonly operation: string | Uint8Array;
```

***

### vk

```ts
readonly vk: ContractOperationVersionedVerifierKey;
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/VerifierKeyRemove.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / VerifierKeyRemove

# Class: VerifierKeyRemove

An update instruction to remove a verifier key of a specific operation and
version.

## Constructors

### new VerifierKeyRemove(operation, version)

```ts
new VerifierKeyRemove(operation, version): VerifierKeyRemove
```

#### Parameters

• **operation**: `string` \| `Uint8Array`

• **version**: [`ContractOperationVersion`](ContractOperationVersion.md)

#### Returns

[`VerifierKeyRemove`](VerifierKeyRemove.md)

## Properties

### operation

```ts
readonly operation: string | Uint8Array;
```

***

### version

```ts
readonly version: ContractOperationVersion;
```

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/VmResults.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / VmResults

# Class: VmResults

Represents the results of a VM call

## Constructors

### new VmResults()

```ts
private new VmResults(): VmResults
```

#### Returns

[`VmResults`](VmResults.md)

## Properties

### events

```ts
readonly events: GatherResult[];
```

The events that got emitted by this VM invocation

***

### gasCost

```ts
readonly gasCost: bigint;
```

The computed gas cost of running this VM invocation

***

### stack

```ts
readonly stack: VmStack;
```

The VM stack at the end of the VM invocation

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/VmStack.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / VmStack

# Class: VmStack

Represents the state of the VM's stack at a specific point. The stack is an
array of [StateValue](StateValue.md)s, each of which is also annotated with whether
it is "strong" or "weak"; that is, whether it is permitted to be stored
on-chain or not.

## Constructors

### new VmStack()

```ts
new VmStack(): VmStack
```

#### Returns

[`VmStack`](VmStack.md)

## Methods

### get()

```ts
get(idx): undefined | StateValue
```

#### Parameters

• **idx**: `number`

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### isStrong()

```ts
isStrong(idx): undefined | boolean
```

#### Parameters

• **idx**: `number`

#### Returns

`undefined` \| `boolean`

***

### length()

```ts
length(): number
```

#### Returns

`number`

***

### push()

```ts
push(value, is_strong): void
```

#### Parameters

• **value**: [`StateValue`](StateValue.md)

• **is\_strong**: `boolean`

#### Returns

`void`

***

### removeLast()

```ts
removeLast(): void
```

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/WellFormedStrictness.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / WellFormedStrictness

# Class: WellFormedStrictness

Strictness criteria for evaluating transaction well-formedness, used for
disabling parts of transaction validation for testing.

## Constructors

### new WellFormedStrictness()

```ts
new WellFormedStrictness(): WellFormedStrictness
```

#### Returns

[`WellFormedStrictness`](WellFormedStrictness.md)

## Properties

### enforceBalancing

```ts
enforceBalancing: boolean;
```

Whether to require the transaction to have a non-negative balance

***

### verifyContractProofs

```ts
verifyContractProofs: boolean;
```

Whether to validate contract proofs in the transaction

***

### verifyNativeProofs

```ts
verifyNativeProofs: boolean;
```

Whether to validate Midnight-native (non-contract) proofs in the transaction
</file>

<file path="docs/develop/reference/midnight-api/ledger/classes/ZswapChainState.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ZswapChainState

# Class: ZswapChainState

The on-chain state of Zswap, consisting of a Merkle tree of coin
commitments, a set of nullifiers, an index into the Merkle tree, and a set
of valid past Merkle tree roots

## Constructors

### new ZswapChainState()

```ts
new ZswapChainState(): ZswapChainState
```

#### Returns

[`ZswapChainState`](ZswapChainState.md)

## Properties

### firstFree

```ts
readonly firstFree: bigint;
```

The first free index in the coin commitment tree

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### tryApply()

```ts
tryApply(offer, whitelist?): [ZswapChainState, Map<string, bigint>]
```

Try to apply an [Offer](Offer.md) to the state, returning the updated state
and a map on newly inserted coin commitments to their inserted indices.

#### Parameters

• **offer**: [`Offer`](Offer.md)

• **whitelist?**: `Set`\<`string`\>

A set of contract addresses that are of interest. If
set, *only* these addresses are tracked, and all other information is
discarded.

#### Returns

[[`ZswapChainState`](ZswapChainState.md), `Map`\<`string`, `bigint`\>]

***

### tryApplyProofErased()

```ts
tryApplyProofErased(offer, whitelist?): [ZswapChainState, Map<string, bigint>]
```

[tryApply](ZswapChainState.md#tryapply) for [ProofErasedOffer](ProofErasedOffer.md)s

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

• **whitelist?**: `Set`\<`string`\>

#### Returns

[[`ZswapChainState`](ZswapChainState.md), `Map`\<`string`, `bigint`\>]

***

### deserialize()

```ts
static deserialize(raw, netid): ZswapChainState
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ZswapChainState`](ZswapChainState.md)

***

### deserializeFromLedgerState()

```ts
static deserializeFromLedgerState(raw, netid): ZswapChainState
```

Given a whole ledger serialized state, deserialize only the Zswap portion

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ZswapChainState`](ZswapChainState.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/enumerations/NetworkId.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / NetworkId

# Enumeration: NetworkId

The network currently being targeted

## Enumeration Members

### DevNet

```ts
DevNet: 1;
```

A developer network, not guaranteed to be persistent

***

### MainNet

```ts
MainNet: 3;
```

The Midnight mainnet

***

### TestNet

```ts
TestNet: 2;
```

A persistent testnet

***

### Undeployed

```ts
Undeployed: 0;
```

A local test network
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/bigIntModFr.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / bigIntModFr

# Function: bigIntModFr()

```ts
bigIntModFr(x): bigint
```

Takes a bigint modulus the proof systems scalar field

## Parameters

• **x**: `bigint`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/bigIntToValue.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / bigIntToValue

# Function: bigIntToValue()

`Internal`

```ts
bigIntToValue(x): Value
```

Internal conversion between bigints and their field-aligned binary
representation

## Parameters

• **x**: `bigint`

## Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/checkProofData.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / checkProofData

# Function: checkProofData()

`Internal`

```ts
checkProofData(
   zkir, 
   input, 
   output, 
   public_transcript, 
   private_transcript_outputs): void
```

Internal implementation of proof dry runs.

## Parameters

• **zkir**: `string`

• **input**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **output**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **public\_transcript**: [`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

• **private\_transcript\_outputs**: [`AlignedValue`](../type-aliases/AlignedValue.md)[]

## Returns

`void`

## Throws

If the proof would not hold
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/coinCommitment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / coinCommitment

# Function: coinCommitment()

`Internal`

```ts
coinCommitment(coin, recipient): AlignedValue
```

Internal implementation of the coin commitment primitive.

## Parameters

• **coin**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **recipient**: [`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/communicationCommitment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / communicationCommitment

# Function: communicationCommitment()

```ts
communicationCommitment(
   input, 
   output, 
   rand): CommunicationCommitment
```

Computes the communication commitment corresponding to an input/output pair and randomness.

## Parameters

• **input**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **output**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **rand**: `string`

## Returns

[`CommunicationCommitment`](../type-aliases/CommunicationCommitment.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/communicationCommitmentRandomness.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / communicationCommitmentRandomness

# Function: communicationCommitmentRandomness()

```ts
communicationCommitmentRandomness(): CommunicationCommitmentRand
```

Samples a new [CommunicationCommitmentRand](../type-aliases/CommunicationCommitmentRand.md) uniformly

## Returns

[`CommunicationCommitmentRand`](../type-aliases/CommunicationCommitmentRand.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/createCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / createCoinInfo

# Function: createCoinInfo()

```ts
createCoinInfo(type_, value): CoinInfo
```

Creates a new [CoinInfo](../type-aliases/CoinInfo.md), sampling a uniform nonce

## Parameters

• **type\_**: `string`

• **value**: `bigint`

## Returns

[`CoinInfo`](../type-aliases/CoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/decodeCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / decodeCoinInfo

# Function: decodeCoinInfo()

```ts
decodeCoinInfo(coin): CoinInfo
```

Decode a [CoinInfo](../type-aliases/CoinInfo.md) from Compact's `CoinInfo` TypeScript representation

## Parameters

• **coin**

• **coin\.color**: `Uint8Array`

• **coin\.nonce**: `Uint8Array`

• **coin\.value**: `bigint`

## Returns

[`CoinInfo`](../type-aliases/CoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/decodeCoinPublicKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / decodeCoinPublicKey

# Function: decodeCoinPublicKey()

```ts
decodeCoinPublicKey(pk): CoinPublicKey
```

Decode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) from a `Uint8Array` originating from Compact's
`CoinPublicKey` type

## Parameters

• **pk**: `Uint8Array`

## Returns

[`CoinPublicKey`](../type-aliases/CoinPublicKey.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/decodeContractAddress.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / decodeContractAddress

# Function: decodeContractAddress()

```ts
decodeContractAddress(addr): ContractAddress
```

Decode a [ContractAddress](../type-aliases/ContractAddress.md) from a `Uint8Array` originating from
Compact's `ContractAddress` type

## Parameters

• **addr**: `Uint8Array`

## Returns

[`ContractAddress`](../type-aliases/ContractAddress.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/decodeQualifiedCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / decodeQualifiedCoinInfo

# Function: decodeQualifiedCoinInfo()

```ts
decodeQualifiedCoinInfo(coin): QualifiedCoinInfo
```

Decode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) from Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

• **coin**

• **coin\.color**: `Uint8Array`

• **coin\.mt\_index**: `bigint`

• **coin\.nonce**: `Uint8Array`

• **coin\.value**: `bigint`

## Returns

[`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/decodeTokenType.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / decodeTokenType

# Function: decodeTokenType()

```ts
decodeTokenType(tt): TokenType
```

Decode a [TokenType](../type-aliases/TokenType.md) from a `Uint8Array` originating from Compact's
`TokenType` type

## Parameters

• **tt**: `Uint8Array`

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/degradeToTransient.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / degradeToTransient

# Function: degradeToTransient()

`Internal`

```ts
degradeToTransient(persistent): Value
```

Internal implementation of the degrade to transient primitive

## Parameters

• **persistent**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If persistent does not encode a 32-byte bytestring
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/dummyContractAddress.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / dummyContractAddress

# Function: dummyContractAddress()

```ts
dummyContractAddress(): string
```

A sample contract address, guaranteed to be the same for a given network ID
for use in testing

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/ecAdd.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ecAdd

# Function: ecAdd()

`Internal`

```ts
ecAdd(a, b): Value
```

Internal implementation of the elliptic curve addition primitive

## Parameters

• **a**: [`Value`](../type-aliases/Value.md)

• **b**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If either input does not encode an elliptic curve point
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/ecMul.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ecMul

# Function: ecMul()

`Internal`

```ts
ecMul(a, b): Value
```

Internal implementation of the elliptic curve multiplication primitive

## Parameters

• **a**: [`Value`](../type-aliases/Value.md)

• **b**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If a does not encode an elliptic curve point or b
does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/ecMulGenerator.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ecMulGenerator

# Function: ecMulGenerator()

`Internal`

```ts
ecMulGenerator(val): Value
```

Internal implementation of the elliptic curve generator multiplication
primitive

## Parameters

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

if val does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/encodeCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / encodeCoinInfo

# Function: encodeCoinInfo()

```ts
encodeCoinInfo(coin): {
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

Encode a [CoinInfo](../type-aliases/CoinInfo.md) into a Compact's `CoinInfo` TypeScript
representation

## Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/encodeCoinPublicKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / encodeCoinPublicKey

# Function: encodeCoinPublicKey()

```ts
encodeCoinPublicKey(pk): Uint8Array
```

Encode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) into a `Uint8Array` for use in Compact's
`CoinPublicKey` type

## Parameters

• **pk**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/encodeContractAddress.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / encodeContractAddress

# Function: encodeContractAddress()

```ts
encodeContractAddress(addr): Uint8Array
```

Encode a [ContractAddress](../type-aliases/ContractAddress.md) into a `Uint8Array` for use in Compact's
`ContractAddress` type

## Parameters

• **addr**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/encodeQualifiedCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / encodeQualifiedCoinInfo

# Function: encodeQualifiedCoinInfo()

```ts
encodeQualifiedCoinInfo(coin): {
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
}
```

Encode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) into a Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### mt\_index

```ts
mt_index: bigint;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/encodeTokenType.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / encodeTokenType

# Function: encodeTokenType()

```ts
encodeTokenType(tt): Uint8Array
```

Encode a [TokenType](../type-aliases/TokenType.md) into a `Uint8Array` for use in Compact's
`TokenType` type

## Parameters

• **tt**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/hashToCurve.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / hashToCurve

# Function: hashToCurve()

`Internal`

```ts
hashToCurve(align, val): Value
```

Internal implementation of the hash to curve primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/leafHash.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / leafHash

# Function: leafHash()

`Internal`

```ts
leafHash(value): AlignedValue
```

Internal implementation of the Merkle tree leaf hash primitive.

## Parameters

• **value**: [`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/maxAlignedSize.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / maxAlignedSize

# Function: maxAlignedSize()

`Internal`

```ts
maxAlignedSize(alignment): bigint
```

Internal implementation of the max aligned size primitive.

## Parameters

• **alignment**: [`Alignment`](../type-aliases/Alignment.md)

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/maxField.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / maxField

# Function: maxField()

```ts
maxField(): bigint
```

Returns the maximum representable value in the proof systems scalar field
(that is, 1 less than the prime modulus)

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/nativeToken.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / nativeToken

# Function: nativeToken()

```ts
nativeToken(): TokenType
```

The base/system token type

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/partitionTranscripts.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / partitionTranscripts

# Function: partitionTranscripts()

```ts
partitionTranscripts(calls, params): [Transcript<AlignedValue> | undefined, Transcript<AlignedValue> | undefined][]
```

Finalizes a set of programs against their initial contexts,
resulting in guaranteed and fallible [Transcript](../type-aliases/Transcript.md)s, optimally
allocated, and heuristically covered for gas fees.

## Parameters

• **calls**: [`PreTranscript`](../classes/PreTranscript.md)[]

• **params**: [`LedgerParameters`](../classes/LedgerParameters.md)

## Returns

[[`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\> \| `undefined`, [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\> \| `undefined`][]
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/persistentCommit.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / persistentCommit

# Function: persistentCommit()

`Internal`

```ts
persistentCommit(
   align, 
   val, 
   opening): Value
```

Internal implementation of the persistent commitment primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

• **opening**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align,
opening does not encode a 32-byte bytestring, or any component has a
compress alignment
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/persistentHash.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / persistentHash

# Function: persistentHash()

`Internal`

```ts
persistentHash(align, val): Value
```

Internal implementation of the persistent hash primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align, or any
component has a compress alignment
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/runProgram.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / runProgram

# Function: runProgram()

```ts
runProgram(
   initial, 
   ops, 
   cost_model, 
   gas_limit?): VmResults
```

Runs a VM program against an initial stack, with an optional gas limit

## Parameters

• **initial**: [`VmStack`](../classes/VmStack.md)

• **ops**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](../classes/CostModel.md)

• **gas\_limit?**: `bigint`

## Returns

[`VmResults`](../classes/VmResults.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/sampleCoinPublicKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / sampleCoinPublicKey

# Function: sampleCoinPublicKey()

```ts
sampleCoinPublicKey(): CoinPublicKey
```

Samples a dummy user coin public key, for use in testing

## Returns

[`CoinPublicKey`](../type-aliases/CoinPublicKey.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/sampleContractAddress.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / sampleContractAddress

# Function: sampleContractAddress()

```ts
sampleContractAddress(): ContractAddress
```

Samples a uniform contract address, for use in testing

## Returns

[`ContractAddress`](../type-aliases/ContractAddress.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/sampleSigningKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / sampleSigningKey

# Function: sampleSigningKey()

```ts
sampleSigningKey(): SigningKey
```

Randomly samples a [SigningKey](../type-aliases/SigningKey.md).

## Returns

[`SigningKey`](../type-aliases/SigningKey.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/sampleTokenType.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / sampleTokenType

# Function: sampleTokenType()

```ts
sampleTokenType(): TokenType
```

Samples a uniform token type, for use in testing

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/signatureVerifyingKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / signatureVerifyingKey

# Function: signatureVerifyingKey()

```ts
signatureVerifyingKey(sk): SignatureVerifyingKey
```

Returns the verifying key for a given signing key

## Parameters

• **sk**: `string`

## Returns

[`SignatureVerifyingKey`](../type-aliases/SignatureVerifyingKey.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/signData.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / signData

# Function: signData()

```ts
signData(key, data): Signature
```

Signs arbitrary data with the given signing key.

WARNING: Do not expose access to this function for valuable keys for data
that is not strictly controlled!

## Parameters

• **key**: `string`

• **data**: `Uint8Array`

## Returns

[`Signature`](../type-aliases/Signature.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/tokenType.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / tokenType

# Function: tokenType()

```ts
tokenType(domain_sep, contract): TokenType
```

Derives the [TokenType](../type-aliases/TokenType.md) associated with a particular
[DomainSeperator](../type-aliases/DomainSeperator.md) and contract.

## Parameters

• **domain\_sep**: `Uint8Array`

• **contract**: `string`

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/transientCommit.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / transientCommit

# Function: transientCommit()

`Internal`

```ts
transientCommit(
   align, 
   val, 
   opening): Value
```

Internal implementation of the transient commitment primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

• **opening**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align, or
opening does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/transientHash.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / transientHash

# Function: transientHash()

`Internal`

```ts
transientHash(align, val): Value
```

Internal implementation of the transient hash primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/upgradeFromTransient.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / upgradeFromTransient

# Function: upgradeFromTransient()

`Internal`

```ts
upgradeFromTransient(transient): Value
```

Internal implementation of the upgrade from transient primitive

## Parameters

• **transient**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If transient does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/valueToBigInt.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / valueToBigInt

# Function: valueToBigInt()

`Internal`

```ts
valueToBigInt(x): bigint
```

Internal conversion between field-aligned binary values and bigints within
the scalar field

## Parameters

• **x**: [`Value`](../type-aliases/Value.md)

## Returns

`bigint`

## Throws

If the value does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/ledger/functions/verifySignature.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / verifySignature

# Function: verifySignature()

```ts
verifySignature(
   vk, 
   data, 
   signature): boolean
```

Verifies if a signature is correct

## Parameters

• **vk**: `string`

• **data**: `Uint8Array`

• **signature**: `string`

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/AlignedValue.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / AlignedValue

# Type alias: AlignedValue

```ts
type AlignedValue: {
  alignment: Alignment;
  value: Value;
};
```

An onchain data value, in field-aligned binary format, annotated with its
alignment.

## Type declaration

### alignment

```ts
alignment: Alignment;
```

### value

```ts
value: Value;
```
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Alignment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Alignment

# Type alias: Alignment

```ts
type Alignment: AlignmentSegment[];
```

The alignment of an onchain field-aligned binary data value.
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/AlignmentAtom.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / AlignmentAtom

# Type alias: AlignmentAtom

```ts
type AlignmentAtom: {
  tag: "compress";
  } | {
  tag: "field";
  } | {
  length: number;
  tag: "bytes";
};
```

A atom in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/AlignmentSegment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / AlignmentSegment

# Type alias: AlignmentSegment

```ts
type AlignmentSegment: {
  tag: "option";
  value: Alignment[];
  } | {
  tag: "atom";
  value: AlignmentAtom;
};
```

A segment in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/BlockContext.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / BlockContext

# Type alias: BlockContext

```ts
type BlockContext: {
  blockHash: string;
  secondsSinceEpoch: bigint;
  secondsSinceEpochErr: number;
};
```

The context information about a block available inside the VM

## Type declaration

### blockHash

```ts
blockHash: string;
```

The hash of the block prior to this transaction, as a hex-encoded string

### secondsSinceEpoch

```ts
secondsSinceEpoch: bigint;
```

The seconds since the UNIX epoch that have elapsed

### secondsSinceEpochErr

```ts
secondsSinceEpochErr: number;
```

The maximum error on secondsSinceEpoch that should occur, as a
positive seconds value
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/CoinCommitment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CoinCommitment

# Type alias: CoinCommitment

```ts
type CoinCommitment: string;
```

A Zswap coin commitment, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/CoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CoinInfo

# Type alias: CoinInfo

```ts
type CoinInfo: {
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to create a new coin, alongside details about the
recipient

## Type declaration

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/CoinPublicKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CoinPublicKey

# Type alias: CoinPublicKey

```ts
type CoinPublicKey: string;
```

A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
string
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/CommunicationCommitment.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CommunicationCommitment

# Type alias: CommunicationCommitment

```ts
type CommunicationCommitment: string;
```

A hex-encoded commitment of data shared between two contracts in a call
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/CommunicationCommitmentRand.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / CommunicationCommitmentRand

# Type alias: CommunicationCommitmentRand

```ts
type CommunicationCommitmentRand: string;
```

The hex-encoded randomness to [CommunicationCommitment](CommunicationCommitment.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/ContractAction.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractAction

# Type alias: ContractAction

```ts
type ContractAction: ContractCall | ContractDeploy | MaintenanceUpdate;
```

An interactions with a contract
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/ContractAddress.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / ContractAddress

# Type alias: ContractAddress

```ts
type ContractAddress: string;
```

A contract address, as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/DomainSeperator.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / DomainSeperator

# Type alias: DomainSeperator

```ts
type DomainSeperator: Uint8Array;
```

A token domain seperator, the pre-stage of `TokenType`, as 32-byte bytearray
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Effects.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Effects

# Type alias: Effects

```ts
type Effects: {
  claimedContractCalls: [bigint, ContractAddress, string, Fr][];
  claimedNullifiers: Nullifier[];
  claimedReceives: CoinCommitment[];
  claimedSpends: CoinCommitment[];
  mints: Map<string, bigint>;
};
```

The contract-external effects of a transcript.

## Type declaration

### claimedContractCalls

```ts
claimedContractCalls: [bigint, ContractAddress, string, Fr][];
```

The contracts called from this contract. The values are, in order:

- The sequence number of this call
- The contract being called
- The entry point being called
- The communications commitment

### claimedNullifiers

```ts
claimedNullifiers: Nullifier[];
```

The nullifiers (spends) this contract call requires

### claimedReceives

```ts
claimedReceives: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
received

### claimedSpends

```ts
claimedSpends: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
sent

### mints

```ts
mints: Map<string, bigint>;
```

The tokens minted in this call, as a map from hex-encoded 256-bit domain
separators to non-negative 64-bit integers.
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/EncodedStateValue.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / EncodedStateValue

# Type alias: EncodedStateValue

```ts
type EncodedStateValue: 
  | {
  tag: "null";
  }
  | {
  content: EncodedStateValue;
  tag: "cell";
  }
  | {
  content: Map<AlignedValue, EncodedStateValue>;
  tag: "map";
  }
  | {
  content: EncodedStateValue[];
  tag: "array";
  }
  | {
  content: [number, Map<bigint, [Uint8Array, undefined]>];
  tag: "boundedMerkleTree";
};
```

An alternative encoding of [StateValue](../classes/StateValue.md) for use in [Op](Op.md) for
technical reasons
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/EncPublicKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / EncPublicKey

# Type alias: EncPublicKey

```ts
type EncPublicKey: string;
```

An encryption public key, used to inform users of new coins sent to them
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Fr.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Fr

# Type alias: Fr

```ts
type Fr: Uint8Array;
```

An internal encoding of a value of the proof systems scalar field
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/GatherResult.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / GatherResult

# Type alias: GatherResult

```ts
type GatherResult: {
  content: AlignedValue;
  tag: "read";
  } | {
  content: EncodedStateValue;
  tag: "log";
};
```

An individual result of observing the results of a non-verifying VM program
execution
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Key.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Key

# Type alias: Key

```ts
type Key: {
  tag: "value";
  value: AlignedValue;
  } | {
  tag: "stack";
};
```

A key used to index into an array or map in the onchain VM
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Nonce.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Nonce

# Type alias: Nonce

```ts
type Nonce: string;
```

A Zswap nonce, as a hex-encoded 256-bit string
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Nullifier.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Nullifier

# Type alias: Nullifier

```ts
type Nullifier: string;
```

A Zswap nullifier, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Op.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Op

# Type alias: Op\<R\>

```ts
type Op<R>: 
  | {
  noop: {
     n: number;
  };
  }
  | "lt"
  | "eq"
  | "type"
  | "size"
  | "new"
  | "and"
  | "or"
  | "neg"
  | "log"
  | "root"
  | "pop"
  | {
  popeq: {
     cached: boolean;
     result: R;
  };
  }
  | {
  addi: {
     immediate: number;
  };
  }
  | {
  subi: {
     immediate: number;
  };
  }
  | {
  push: {
     storage: boolean;
     value: EncodedStateValue;
  };
  }
  | {
  branch: {
     skip: number;
  };
  }
  | {
  jmp: {
     skip: number;
  };
  }
  | "add"
  | "sub"
  | {
  concat: {
     cached: boolean;
     n: number;
  };
  }
  | "member"
  | {
  rem: {
     cached: boolean;
  };
  }
  | {
  dup: {
     n: number;
  };
  }
  | {
  swap: {
     n: number;
  };
  }
  | {
  idx: {
     cached: boolean;
     path: Key[];
     pushPath: boolean;
  };
  }
  | {
  ins: {
     cached: boolean;
     n: number;
  };
  }
  | "ckpt";
```

An individual operation in the onchain VM

## Type parameters

• **R**

`null` or [AlignedValue](AlignedValue.md), for gathering and verifying
mode respectively
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/QualifiedCoinInfo.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / QualifiedCoinInfo

# Type alias: QualifiedCoinInfo

```ts
type QualifiedCoinInfo: {
  mt_index: bigint;
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to spend an existing coin, alongside authorization of
the owner

## Type declaration

### mt\_index

```ts
mt_index: bigint;
```

The coin's location in the chain's Merkle tree of coin commitments

Bounded to be a non-negative 64-bit integer

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Signature.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Signature

# Type alias: Signature

```ts
type Signature: string;
```

A hex-encoded signature BIP-340 signature, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/SignatureVerifyingKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / SignatureVerifyingKey

# Type alias: SignatureVerifyingKey

```ts
type SignatureVerifyingKey: string;
```

A hex-encoded signature BIP-340 verifying key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/SigningKey.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / SigningKey

# Type alias: SigningKey

```ts
type SigningKey: string;
```

A hex-encoded signature BIP-340 signing key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/SingleUpdate.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / SingleUpdate

# Type alias: SingleUpdate

```ts
type SingleUpdate: ReplaceAuthority | VerifierKeyRemove | VerifierKeyInsert;
```

A single update instruction in a [MaintenanceUpdate](../classes/MaintenanceUpdate.md).
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/TokenType.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TokenType

# Type alias: TokenType

```ts
type TokenType: string;
```

A token type (or color), as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/TransactionHash.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TransactionHash

# Type alias: TransactionHash

```ts
type TransactionHash: string;
```

The hash of a transaction, as a hex-encoded 256-bit bytestring
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/TransactionId.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / TransactionId

# Type alias: TransactionId

```ts
type TransactionId: string;
```

A transaction identifier, used to index merged transactions
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Transcript.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Transcript

# Type alias: Transcript\<R\>

```ts
type Transcript<R>: {
  effects: Effects;
  gas: bigint;
  program: Op<R>[];
};
```

A transcript of operations, to be recorded in a transaction

## Type parameters

• **R**

## Type declaration

### effects

```ts
effects: Effects;
```

The effects of the transcript, which are checked before execution, and
must match those constructed by program

### gas

```ts
gas: bigint;
```

The execution budget for this transcript, which program must not
exceed

### program

```ts
program: Op<R>[];
```

The sequence of operations that this transcript captured
</file>

<file path="docs/develop/reference/midnight-api/ledger/type-aliases/Value.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/ledger v3.0.2](../README.md) / Value

# Type alias: Value

```ts
type Value: Uint8Array[];
```

An onchain data value, in field-aligned binary format.
</file>

<file path="docs/develop/reference/midnight-api/ledger/globals.md">
**@midnight-ntwrk/ledger v3.0.2** • [Readme](README.md) \| API

***

# @midnight-ntwrk/ledger v3.0.2

## Enumerations

- [NetworkId](enumerations/NetworkId.md)

## Classes

- [AuthorizedMint](classes/AuthorizedMint.md)
- [ContractCall](classes/ContractCall.md)
- [ContractCallPrototype](classes/ContractCallPrototype.md)
- [ContractCallsPrototype](classes/ContractCallsPrototype.md)
- [ContractDeploy](classes/ContractDeploy.md)
- [ContractMaintenanceAuthority](classes/ContractMaintenanceAuthority.md)
- [ContractOperation](classes/ContractOperation.md)
- [ContractOperationVersion](classes/ContractOperationVersion.md)
- [ContractOperationVersionedVerifierKey](classes/ContractOperationVersionedVerifierKey.md)
- [ContractState](classes/ContractState.md)
- [CostModel](classes/CostModel.md)
- [EncryptionSecretKey](classes/EncryptionSecretKey.md)
- [Input](classes/Input.md)
- [LedgerParameters](classes/LedgerParameters.md)
- [LedgerState](classes/LedgerState.md)
- [LocalState](classes/LocalState.md)
- [MaintenanceUpdate](classes/MaintenanceUpdate.md)
- [MerkleTreeCollapsedUpdate](classes/MerkleTreeCollapsedUpdate.md)
- [Offer](classes/Offer.md)
- [Output](classes/Output.md)
- [PreTranscript](classes/PreTranscript.md)
- [ProofErasedAuthorizedMint](classes/ProofErasedAuthorizedMint.md)
- [ProofErasedInput](classes/ProofErasedInput.md)
- [ProofErasedOffer](classes/ProofErasedOffer.md)
- [ProofErasedOutput](classes/ProofErasedOutput.md)
- [ProofErasedTransaction](classes/ProofErasedTransaction.md)
- [ProofErasedTransient](classes/ProofErasedTransient.md)
- [QueryContext](classes/QueryContext.md)
- [QueryResults](classes/QueryResults.md)
- [ReplaceAuthority](classes/ReplaceAuthority.md)
- [StateBoundedMerkleTree](classes/StateBoundedMerkleTree.md)
- [StateMap](classes/StateMap.md)
- [StateValue](classes/StateValue.md)
- [SystemTransaction](classes/SystemTransaction.md)
- [Transaction](classes/Transaction.md)
- [TransactionContext](classes/TransactionContext.md)
- [TransactionCostModel](classes/TransactionCostModel.md)
- [TransactionResult](classes/TransactionResult.md)
- [Transient](classes/Transient.md)
- [UnprovenAuthorizedMint](classes/UnprovenAuthorizedMint.md)
- [UnprovenInput](classes/UnprovenInput.md)
- [UnprovenOffer](classes/UnprovenOffer.md)
- [UnprovenOutput](classes/UnprovenOutput.md)
- [UnprovenTransaction](classes/UnprovenTransaction.md)
- [UnprovenTransient](classes/UnprovenTransient.md)
- [VerifierKeyInsert](classes/VerifierKeyInsert.md)
- [VerifierKeyRemove](classes/VerifierKeyRemove.md)
- [VmResults](classes/VmResults.md)
- [VmStack](classes/VmStack.md)
- [WellFormedStrictness](classes/WellFormedStrictness.md)
- [ZswapChainState](classes/ZswapChainState.md)

## Type Aliases

- [AlignedValue](type-aliases/AlignedValue.md)
- [Alignment](type-aliases/Alignment.md)
- [AlignmentAtom](type-aliases/AlignmentAtom.md)
- [AlignmentSegment](type-aliases/AlignmentSegment.md)
- [BlockContext](type-aliases/BlockContext.md)
- [CoinCommitment](type-aliases/CoinCommitment.md)
- [CoinInfo](type-aliases/CoinInfo.md)
- [CoinPublicKey](type-aliases/CoinPublicKey.md)
- [CommunicationCommitment](type-aliases/CommunicationCommitment.md)
- [CommunicationCommitmentRand](type-aliases/CommunicationCommitmentRand.md)
- [ContractAction](type-aliases/ContractAction.md)
- [ContractAddress](type-aliases/ContractAddress.md)
- [DomainSeperator](type-aliases/DomainSeperator.md)
- [Effects](type-aliases/Effects.md)
- [EncPublicKey](type-aliases/EncPublicKey.md)
- [EncodedStateValue](type-aliases/EncodedStateValue.md)
- [Fr](type-aliases/Fr.md)
- [GatherResult](type-aliases/GatherResult.md)
- [Key](type-aliases/Key.md)
- [Nonce](type-aliases/Nonce.md)
- [Nullifier](type-aliases/Nullifier.md)
- [Op](type-aliases/Op.md)
- [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md)
- [Signature](type-aliases/Signature.md)
- [SignatureVerifyingKey](type-aliases/SignatureVerifyingKey.md)
- [SigningKey](type-aliases/SigningKey.md)
- [SingleUpdate](type-aliases/SingleUpdate.md)
- [TokenType](type-aliases/TokenType.md)
- [TransactionHash](type-aliases/TransactionHash.md)
- [TransactionId](type-aliases/TransactionId.md)
- [Transcript](type-aliases/Transcript.md)
- [Value](type-aliases/Value.md)

## Functions

- [bigIntModFr](functions/bigIntModFr.md)
- [bigIntToValue](functions/bigIntToValue.md)
- [checkProofData](functions/checkProofData.md)
- [coinCommitment](functions/coinCommitment.md)
- [communicationCommitment](functions/communicationCommitment.md)
- [communicationCommitmentRandomness](functions/communicationCommitmentRandomness.md)
- [createCoinInfo](functions/createCoinInfo.md)
- [decodeCoinInfo](functions/decodeCoinInfo.md)
- [decodeCoinPublicKey](functions/decodeCoinPublicKey.md)
- [decodeContractAddress](functions/decodeContractAddress.md)
- [decodeQualifiedCoinInfo](functions/decodeQualifiedCoinInfo.md)
- [decodeTokenType](functions/decodeTokenType.md)
- [degradeToTransient](functions/degradeToTransient.md)
- [dummyContractAddress](functions/dummyContractAddress.md)
- [ecAdd](functions/ecAdd.md)
- [ecMul](functions/ecMul.md)
- [ecMulGenerator](functions/ecMulGenerator.md)
- [encodeCoinInfo](functions/encodeCoinInfo.md)
- [encodeCoinPublicKey](functions/encodeCoinPublicKey.md)
- [encodeContractAddress](functions/encodeContractAddress.md)
- [encodeQualifiedCoinInfo](functions/encodeQualifiedCoinInfo.md)
- [encodeTokenType](functions/encodeTokenType.md)
- [hashToCurve](functions/hashToCurve.md)
- [leafHash](functions/leafHash.md)
- [maxAlignedSize](functions/maxAlignedSize.md)
- [maxField](functions/maxField.md)
- [nativeToken](functions/nativeToken.md)
- [partitionTranscripts](functions/partitionTranscripts.md)
- [persistentCommit](functions/persistentCommit.md)
- [persistentHash](functions/persistentHash.md)
- [runProgram](functions/runProgram.md)
- [sampleCoinPublicKey](functions/sampleCoinPublicKey.md)
- [sampleContractAddress](functions/sampleContractAddress.md)
- [sampleSigningKey](functions/sampleSigningKey.md)
- [sampleTokenType](functions/sampleTokenType.md)
- [signData](functions/signData.md)
- [signatureVerifyingKey](functions/signatureVerifyingKey.md)
- [tokenType](functions/tokenType.md)
- [transientCommit](functions/transientCommit.md)
- [transientHash](functions/transientHash.md)
- [upgradeFromTransient](functions/upgradeFromTransient.md)
- [valueToBigInt](functions/valueToBigInt.md)
- [verifySignature](functions/verifySignature.md)
</file>

<file path="docs/develop/reference/midnight-api/ledger/README.md">
# Ledger API

**@midnight-ntwrk/ledger v3.0.2** • Readme \| [API](globals.md)

***

# Ledger TypeScript API

This document outlines the flow of transaction assembly and usage with the
ledger TS API.

## Network ID

Prior to any interaction, setNetworkId should be used to set the [NetworkId](enumerations/NetworkId.md) to target the correct network.

## Proof stages

Most transaction components will be in one of three stages: `X`, `UnprovenX`,
or `ProofErasedX`. The `UnprovenX` stage is _always_ the first one. It is
possible to transition to the `X` stage by proving an `UnprovenTransaction`
through the proof server. For testing, and where proofs aren't necessary, the
`ProofErasedX` stage is used, which can be reached via `eraseProof[s]` from the
other two stages.

## Transaction structure

A [Transaction](classes/Transaction.md) runs in two phases: a _guaranteed_ phase, handling fee payments
and fast-to-verify operations, and a _fallible_ phase, handling operations
which may fail atomically, separately from the guaranteed phase. It therefore
contains:

* A "guaranteed" [Offer](classes/Offer.md)
* Optionally, a "fallible" [Offer](classes/Offer.md)
* Optionally, a sequence of [ContractCall](classes/ContractCall.md)s or [ContractDeploy](classes/ContractDeploy.md)s.

It also contains additional cryptographic glue that will be omitted in this
document.

### Zswap

A Zswap [Offer](classes/Offer.md) consists of:
* A set of [Input](classes/Input.md)s, burning coins.
* A set of [Output](classes/Output.md)s, creating coins.
* A set of [Transient](classes/Transient.md)s, indicating a coin that is created and burnt in
  the same transaction.
* A mapping from [TokenType](type-aliases/TokenType.md)s to offer balance, positive when there are more
  inputs than outputs and vice versa.

[Input](classes/Input.md)s can be created either from a [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) and a contract
address, if the coin is contract-owned, or from a [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) and a
ZswapLocalState, if it is user-owned. Similarly, [Output](classes/Output.md)s can be created
from a [CoinInfo](type-aliases/CoinInfo.md) and a contract address for contract-owned coins, or from a
[CoinInfo](type-aliases/CoinInfo.md) and a user's public key(s), if it is user-owned. A [Transient](classes/Transient.md)
is created similarly to a [Input](classes/Input.md), but directly converts an existing
[Output](classes/Output.md).

A [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) is a [CoinInfo](type-aliases/CoinInfo.md) with an index into the Merkle tree of
coin commitments that can be used to find the relevant coin to spend, while a
[CoinInfo](type-aliases/CoinInfo.md) consists of a coins [TokenType](type-aliases/TokenType.md), value, and a nonce.

### Calls

A [ContractDeploy](classes/ContractDeploy.md) consists of an initial contract state, and a nonce.

A [ContractCall](classes/ContractCall.md) consists of a contract's address, the entry point used on this
contract, a guaranteed and a fallible public oracle transcript, a communication
commitment, and a proof. [ContractCall](classes/ContractCall.md)s are constructed via
[ContractCallPrototype](classes/ContractCallPrototype.md)s, which consist of the following raw pieces of data:
* The contract address
* The contract's entry point
* The contract operation expected (that is, the verifier key and transcript
  shape expected to be at this contract address and entry point)
* The guaranteed transcript (as produced by the generated JS code)
* The fallible transcript (as produced by the generated JS code)
* The outputs of the private oracle calls (As a FAB [AlignedValue](type-aliases/AlignedValue.md)s)
* The input(s) to the call, concatenated together (As a FAB [AlignedValue](type-aliases/AlignedValue.md))
* The output(s) to the call, concatenated together (As a FAB [AlignedValue](type-aliases/AlignedValue.md))
* The communications commitment randomness (As a hex-encoded field element string)
* A unique identifier for the ZK circuit used (used by the proof server to index for the prover key)

NOTE: currently the JS code only generates a single transcript. We probably
just want a canonical way to split this into guaranteed/fallible?

A ContractCalls object is assembed, and [ContractCallPrototype](classes/ContractCallPrototype.md)s /
[ContractDeploy](classes/ContractDeploy.md)s are added to this directly. This can then be inserted into an
[UnprovenTransaction](classes/UnprovenTransaction.md).

## State Structure

The [LedgerState](classes/LedgerState.md) is the primary entry point for Midnight's ledger state,
and it consists of a [ZswapChainState](classes/ZswapChainState.md), as well as a mapping from [ContractAddress](type-aliases/ContractAddress.md)es to [ContractState](classes/ContractState.md)s. States are immutable, and
applying transactions always produce new outputs states.
</file>

<file path="docs/develop/reference/midnight-api/midnight-indexer/README.md">
# Midnight Indexer API Documentation v1

The Midnight Indexer API exposes a GraphQL API that enables clients to query and subscribe to blockchain data—blocks, transactions, contracts, and wallet-related events—indexed from the Midnight blockchain. These capabilities facilitate both historical lookups and real-time monitoring.

**Disclaimer:**  
The examples provided here are illustrative and may need updating if the API changes. Always consider [midnight-indexer-api-schema](https://github.com/midnightntwrk/midnight-indexer/blob/main/indexer-api/graphql/schema-v1.graphql) as the primary source of truth. Adjust queries as necessary to match the latest schema.

## GraphQL Schema

The GraphQL schema is defined in [midnight-indexer-api-schema](https://github.com/midnightntwrk/midnight-indexer/blob/main/indexer-api/graphql/schema-v1.graphql). It specifies all queries, mutations, subscriptions, and their types, including arguments and return structures.

## Overview of Operations

- **Queries**: Fetch blocks, transactions, and contract actions.  
  Examples:
    - Retrieve the latest block or a specific block by hash or height.
    - Look up transactions by their hash or identifier.
    - Inspect the current state of a contract action at a given block or transaction offset.

- **Mutations**: Manage wallet sessions.
    - `connect(viewingKey: ViewingKey!)`: Creates a session associated with a viewing key.
    - `disconnect(sessionId: HexEncoded!)`: Ends a previously established session.

- **Subscriptions**: Receive real-time updates.
    - `blocks`: Stream newly indexed blocks.
    - `contractActions(address, offset)`: Stream contract actions.
    - `wallet(sessionId, ...)`: Stream wallet updates, including relevant transactions and optional progress updates.

## API Endpoints

**HTTP (Queries & Mutations):**
```
POST https://<host>:<port>/api/v1/graphql
Content-Type: application/json
```

**WebSocket (Subscriptions):**
```
wss://<host>:<port>/api/v1/graphql/ws
Sec-WebSocket-Protocol: graphql-transport-ws
```

## Core Scalars

- `HexEncoded`: Hex-encoded bytes (for hashes, addresses, session IDs).
- `ViewingKey`: A viewing key in hex or Bech32 format for wallet sessions.
- `ApplyStage`: Enumerated stages of transaction application. This scalar represents the outcome of transaction processing on the chain ("Success", "PartialSuccess" or "Failure").
- `Unit`: An empty return type for mutations that do not return data.

## Example Queries and Mutations

**Note:** These are examples only. Refer to the schema file to confirm exact field names and structures.

### block(offset: BlockOffset): Block

**Parameters** (BlockOffset is a oneOf):
- `hash: HexEncoded` – The block hash.
- `height: Int` – The block height (number).

If no offset is provided, the latest block is returned.

**Example:**

Query by height:

```graphql
query {
  block(offset: { height: 3 }) {
    hash
    height
    protocolVersion
    timestamp
    parent {
      hash
    }
    transactions {
      hash
      applyStage
    }
  }
}
```

### transactions(offset: TransactionOffset!): [Transaction!]!

Fetch transactions by hash or by identifier using a TransactionOffset object. The offset must include either a hash or an identifier, but not both. Returns an array since a hash may map to multiple related actions.

**Example:**

```graphql
query {
  transactions(offset: { hash: "3031323..." }) {
    hash
    protocolVersion
    merkleTreeRoot
    block {
      height
      hash
    }
    identifiers
    raw
    contractActions {
      __typename
      ... on ContractDeploy {
        address
        state
        chainState
      }
      ... on ContractCall {
        address
        state
        entryPoint
        chainState
      }
      ... on ContractUpdate {
        address
        state
        chainState
      }
    }
  }
}
```

### contractAction(address: HexEncoded!, offset: ContractActionOffset): ContractAction

Retrieve the latest known contract action at a given offset (by block or transaction). If no offset is provided, returns the latest state.

**Example (latest):**

```graphql
query {
  contractAction(address: "3031323...") {
    __typename
    address
    state
    chainState
  }
}
```

**Example (by block height):**

```graphql
query {
  contractAction(
    address: "3031323...", 
    offset: { blockOffset: { height: 10 } }
  ) {
    __typename
    address
    state
    chainState
  }
}
```

## Contract Action Types

All ContractAction types (ContractDeploy, ContractCall, ContractUpdate) implement the ContractAction interface with these common fields:
- `address`: The contract address (HexEncoded)
- `state`: The contract state (HexEncoded)
- `chainState`: The chain state at this action (HexEncoded)
- `transaction`: The transaction that contains this action

Contract actions can be one of three types:
- **ContractDeploy**: Initial contract deployment
- **ContractCall**: Invocation of a contract's entry point
- **ContractUpdate**: State update to an existing contract

Each type implements the ContractAction interface but may have additional fields. For example, ContractCall includes an `entryPoint` field and a reference to its associated `deploy`.

## Mutations

Mutations allow the client to connect a wallet (establishing a session) and disconnect it.

### connect(viewingKey: ViewingKey!): HexEncoded!

Establishes a session for a given wallet viewing key in **either** bech32m or hex format. Returns the session ID.

**Viewing Key Format Support**
- **Bech32m** (preferred): A base-32 encoded format with a human-readable prefix, e.g., `mn_shield-esk_dev1...`
- **Hex** (fallback): A hex-encoded string representing the key bytes.

**Example:**

```graphql
mutation {
  # Provide the bech32m format:
  connect(viewingKey: "mn_shield-esk1abcdef...") 
}
```

**Response:**
```json
{
  "data": {
    "connect": "sessionIdHere"
  }
}
```

### disconnect(sessionId: HexEncoded!): Unit!

Ends an existing session.

**Example:**

Use this `sessionId` for wallet subscriptions.

When done:
```graphql
mutation {
  disconnect(sessionId: "sessionIdHere")
}
```

## Subscriptions: Real-time Updates

Subscriptions use a WebSocket connection following the [GraphQL over WebSocket](https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md) protocol. After connecting and sending a `connection_init` message, the client can start subscription operations.

### Blocks Subscription

`blocks(offset: BlockOffset): Block!`

Subscribe to new blocks. The `offset` parameter lets you start receiving from a given block (by height or hash). If omitted, starts from the latest block.

**Example:**

```json
{
  "id": "1",
  "type": "start",
  "payload": {
    "query": "subscription { blocks(offset: { height: 10 }) { hash height timestamp transactions { hash } } }"
  }
}
```

When a new block is indexed, the client receives a `next` message.

### Contracts Subscription

`contractActions(address: HexEncoded!, offset: BlockOffset): ContractAction!`

Subscribes to contract actions for a particular address. New contract actions (calls, updates) are pushed as they occur.

**Example:**

```json
{
  "id": "2",
  "type": "start",
  "payload": {
    "query": "subscription { contractActions(address:\"3031323...\", offset: { height: 1 }) { __typename address state } }"
  }
}
```

### Wallet Subscription

`wallet(sessionId: HexEncoded!, index: Int, sendProgressUpdates: Boolean): WalletSyncEvent!`

Subscribes to wallet updates. This includes relevant transactions and possibly Merkle tree updates, as well as `ProgressUpdate` events if `sendProgressUpdates` is set to `true`, which is also the default. The `index` parameter can be used to resume from a certain point.

Adjust `index` and `offset` arguments as needed.

**Example:**

```json
{
  "id": "3",
  "type": "start",
  "payload": {
    "query": "subscription { wallet(sessionId: \"1CYq6ZsLmn\", index: 100) { __typename ... on ViewingUpdate { index update { __typename ... on RelevantTransaction { transaction { hash } } } } ... on ProgressUpdate { highestIndex highestRelevantIndex highestRelevantWalletIndex } } }"
  }
}
```

**Responses** may vary depending on what is happening in the chain:
- A `ViewingUpdate` with new relevant transactions or a collapsed Merkle tree update.
- A `ProgressUpdate` providing synchronization progress with fields like `highestIndex`, `highestRelevantIndex`, and `highestRelevantWalletIndex`.

## Query Limits Configuration

The server may apply limitations to queries (e.g. `max-depth`, `max-fields`, `timeout`, and complexity cost). Requests that violate these limits return errors indicating the reason (too many fields, too deep, too costly, or timed out).

**Example error:**

```json
{
  "data": null,
  "errors": [
    {
      "message": "Query has too many fields: 20. Max fields: 10."
    }
  ]
}
```

## Authentication

- Wallet subscription requires a `sessionId` from the `connect` mutation.

### Regenerating the Schema

If you modify the code defining the GraphQL schema, regenerate it:
```bash
just generate-indexer-api-schema
```
This ensures the schema file stays aligned with code changes.

## Conclusion

This document offers a few hand-picked examples and an overview of available operations. For the most accurate and comprehensive reference, consult the schema file. As the API evolves, remember to validate these examples against the schema and update them as needed.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/CallTxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxFailedError

# Class: CallTxFailedError

An error indicating that a call transaction was not successfully applied by the consensus node.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new CallTxFailedError**(`finalizedTxData`, `circuitId`): `CallTxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the call transaction that failed.

##### circuitId

`string`

The name of the circuit that was called to build the transaction.

#### Returns

`CallTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/ContractTypeError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractTypeError

# Class: ContractTypeError

The error that is thrown when there is a contract type mismatch between a given contract type,
and the initial state that is deployed at a given contract address.

## Remarks

This error is typically thrown during calls to [findDeployedContract](../functions/findDeployedContract.md) where the supplied contract
address represents a different type of contract to the contract type given.

## Extends

- `TypeError`

## Constructors

### Constructor

> **new ContractTypeError**(`contractState`, `circuitIds`): `ContractTypeError`

Initializes a new ContractTypeError.

#### Parameters

##### contractState

`ContractState`

The initial deployed contract state.

##### circuitIds

`string`[]

The circuits that are undefined, or have a verifier key mismatch with the
                  key present in `contractState`.

#### Returns

`ContractTypeError`

#### Overrides

`TypeError.constructor`

## Properties

### circuitIds

> `readonly` **circuitIds**: `string`[]

The circuits that are undefined, or have a verifier key mismatch with the
                  key present in `contractState`.

***

### contractState

> `readonly` **contractState**: `ContractState`

The initial deployed contract state.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/DeployTxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxFailedError

# Class: DeployTxFailedError

An error indicating that a deploy transaction was not successfully applied by the consensus node.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new DeployTxFailedError**(`finalizedTxData`): `DeployTxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the deployment transaction that failed.

#### Returns

`DeployTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/IncompleteCallTxPrivateStateConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / IncompleteCallTxPrivateStateConfig

# Class: IncompleteCallTxPrivateStateConfig

An error indicating that a private state ID was specified for a call transaction while a private
state provider was not. We want to let the user know so that they aren't under the impression the
private state of a contract was updated when it wasn't.

## Extends

- `Error`

## Constructors

### Constructor

> **new IncompleteCallTxPrivateStateConfig**(): `IncompleteCallTxPrivateStateConfig`

#### Returns

`IncompleteCallTxPrivateStateConfig`

#### Overrides

`Error.constructor`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/IncompleteFindContractPrivateStateConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / IncompleteFindContractPrivateStateConfig

# Class: IncompleteFindContractPrivateStateConfig

An error indicating that an initial private state was specified for a contract find while a
private state ID was not. We can't store the initial private state if we don't have a private state ID,
and we need to let the user know that.

## Extends

- `Error`

## Constructors

### Constructor

> **new IncompleteFindContractPrivateStateConfig**(): `IncompleteFindContractPrivateStateConfig`

#### Returns

`IncompleteFindContractPrivateStateConfig`

#### Overrides

`Error.constructor`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/InsertVerifierKeyTxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / InsertVerifierKeyTxFailedError

# Class: InsertVerifierKeyTxFailedError

An error indicating that a verifier key insertion transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new InsertVerifierKeyTxFailedError**(`finalizedTxData`): `InsertVerifierKeyTxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

#### Returns

`InsertVerifierKeyTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/RemoveVerifierKeyTxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / RemoveVerifierKeyTxFailedError

# Class: RemoveVerifierKeyTxFailedError

An error indicating that a verifier key removal transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new RemoveVerifierKeyTxFailedError**(`finalizedTxData`): `RemoveVerifierKeyTxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

#### Returns

`RemoveVerifierKeyTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/ReplaceMaintenanceAuthorityTxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ReplaceMaintenanceAuthorityTxFailedError

# Class: ReplaceMaintenanceAuthorityTxFailedError

An error indicating that a contract maintenance authority replacement transaction failed.

## Extends

- [`TxFailedError`](TxFailedError.md)

## Constructors

### Constructor

> **new ReplaceMaintenanceAuthorityTxFailedError**(`finalizedTxData`): `ReplaceMaintenanceAuthorityTxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

#### Returns

`ReplaceMaintenanceAuthorityTxFailedError`

#### Overrides

[`TxFailedError`](TxFailedError.md).[`constructor`](TxFailedError.md#constructor)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`circuitId`](TxFailedError.md#circuitid)

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

#### Inherited from

[`TxFailedError`](TxFailedError.md).[`finalizedTxData`](TxFailedError.md#finalizedtxdata)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/classes/TxFailedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / TxFailedError

# Class: TxFailedError

An error indicating that a transaction submitted to a consensus node failed.

## Extends

- `Error`

## Extended by

- [`CallTxFailedError`](CallTxFailedError.md)
- [`DeployTxFailedError`](DeployTxFailedError.md)
- [`ReplaceMaintenanceAuthorityTxFailedError`](ReplaceMaintenanceAuthorityTxFailedError.md)
- [`InsertVerifierKeyTxFailedError`](InsertVerifierKeyTxFailedError.md)
- [`RemoveVerifierKeyTxFailedError`](RemoveVerifierKeyTxFailedError.md)

## Constructors

### Constructor

> **new TxFailedError**(`finalizedTxData`, `circuitId`?): `TxFailedError`

#### Parameters

##### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.

##### circuitId?

`string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

#### Returns

`TxFailedError`

#### Overrides

`Error.constructor`

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `string`

The name of the circuit that was called to create the call
                 transaction that failed. Only defined if a call transaction
                 failed.

***

### finalizedTxData

> `readonly` **finalizedTxData**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The finalization data of the transaction that failed.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/call.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / call

# Function: call()

> **call**\<`C`, `ICK`\>(`options`): [`CallResult`](../type-aliases/CallResult.md)\<`C`, `ICK`\>

Calls a circuit in the given contract according to the given configuration.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### options

[`CallOptions`](../type-aliases/CallOptions.md)\<`C`, `ICK`\>

Configuration.

## Returns

[`CallResult`](../type-aliases/CallResult.md)\<`C`, `ICK`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/callContractConstructor.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / callContractConstructor

# Function: callContractConstructor()

> **callContractConstructor**\<`C`\>(`options`): [`ContractConstructorResult`](../type-aliases/ContractConstructorResult.md)\<`C`\>

Calls the constructor of the given contract according to the given configuration.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### options

[`ContractConstructorOptions`](../type-aliases/ContractConstructorOptions.md)\<`C`\>

Configuration.

## Returns

[`ContractConstructorResult`](../type-aliases/ContractConstructorResult.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCallTxOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCallTxOptions

# Function: createCallTxOptions()

> **createCallTxOptions**\<`C`, `ICK`\>(`contract`, `circuitId`, `contractAddress`, `privateStateId`, `args`): [`CallTxOptions`](../type-aliases/CallTxOptions.md)\<`C`, `ICK`\>

Creates a [CallTxOptions](../type-aliases/CallTxOptions.md) object from various data.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### contract

`C`

### circuitId

`ICK`

### contractAddress

`string`

### privateStateId

`undefined` | `string`

### args

[`CircuitParameters`](../../midnight-js-types/type-aliases/CircuitParameters.md)\<`C`, `ICK`\>

## Returns

[`CallTxOptions`](../type-aliases/CallTxOptions.md)\<`C`, `ICK`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitCallTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitCallTxInterface

# Function: createCircuitCallTxInterface()

> **createCircuitCallTxInterface**\<`C`\>(`providers`, `contract`, `contractAddress`, `privateStateId`): [`CircuitCallTxInterface`](../type-aliases/CircuitCallTxInterface.md)\<`C`\>

Creates a circuit call transaction interface for a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

The providers to use to build transactions.

### contract

`C`

The contract to use to execute circuits.

### contractAddress

`string`

The ledger address of the contract.

### privateStateId

The identifier of the state of the witnesses of the contract.

`undefined` | `string`

## Returns

[`CircuitCallTxInterface`](../type-aliases/CircuitCallTxInterface.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitMaintenanceTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitMaintenanceTxInterface

# Function: createCircuitMaintenanceTxInterface()

> **createCircuitMaintenanceTxInterface**\<`C`, `ICK`\>(`providers`, `circuitId`, `contractAddress`): [`CircuitMaintenanceTxInterface`](../type-aliases/CircuitMaintenanceTxInterface.md)

Creates a [CircuitMaintenanceTxInterface](../type-aliases/CircuitMaintenanceTxInterface.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, `ICK`\>

The providers to use to create and submit transactions.

### circuitId

`ICK`

The circuit ID the interface is for.

### contractAddress

`string`

The address of the deployed contract for which this
                       interface is being created.

## Returns

[`CircuitMaintenanceTxInterface`](../type-aliases/CircuitMaintenanceTxInterface.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createCircuitMaintenanceTxInterfaces.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createCircuitMaintenanceTxInterfaces

# Function: createCircuitMaintenanceTxInterfaces()

> **createCircuitMaintenanceTxInterfaces**\<`C`\>(`providers`, `contract`, `contractAddress`): [`CircuitMaintenanceTxInterfaces`](../type-aliases/CircuitMaintenanceTxInterfaces.md)\<`C`\>

Creates a [CircuitMaintenanceTxInterfaces](../type-aliases/CircuitMaintenanceTxInterfaces.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

The providers to use to build transactions.

### contract

`C`

The contract to use to execute circuits.

### contractAddress

`string`

The ledger address of the contract.

## Returns

[`CircuitMaintenanceTxInterfaces`](../type-aliases/CircuitMaintenanceTxInterfaces.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createContractMaintenanceTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createContractMaintenanceTxInterface

# Function: createContractMaintenanceTxInterface()

> **createContractMaintenanceTxInterface**(`providers`, `contractAddress`): [`ContractMaintenanceTxInterface`](../type-aliases/ContractMaintenanceTxInterface.md)

Creates a [ContractMaintenanceTxInterface](../type-aliases/ContractMaintenanceTxInterface.md).

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to build transactions.

### contractAddress

`string`

The ledger address of the contract.

## Returns

[`ContractMaintenanceTxInterface`](../type-aliases/ContractMaintenanceTxInterface.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenCallTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenCallTx

# Function: createUnprovenCallTx()

Calls a circuit using states fetched from the public data provider and private state
provider, then creates an unbalanced, unproven, unsubmitted, call transaction.

## Param

The providers to use to create the call transaction.

## Param

Configuration.

## Throws

IncompleteCallTxPrivateStateConfig If a `privateStateId` was given but a `privateStateProvider`
                                          was not. We assume that when a user gives a `privateStateId`,
                                          they want to update the private state store.

## Call Signature

> **createUnprovenCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`UnprovenCallTxProvidersBase`](../type-aliases/UnprovenCallTxProvidersBase.md)

#### options

[`CallOptionsWithArguments`](../type-aliases/CallOptionsWithArguments.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

## Call Signature

> **createUnprovenCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`UnprovenCallTxProvidersWithPrivateState`](../type-aliases/UnprovenCallTxProvidersWithPrivateState.md)\<`C`\>

#### options

[`CallTxOptionsWithPrivateStateId`](../type-aliases/CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenCallTxFromInitialStates.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenCallTxFromInitialStates

# Function: createUnprovenCallTxFromInitialStates()

Calls a circuit using the provided initial `states` and creates an unbalanced,
unproven, unsubmitted, call transaction.

## Param

Configuration.

## Call Signature

> **createUnprovenCallTxFromInitialStates**\<`C`, `ICK`\>(`options`, `walletCoinPublicKey`, `walletEncryptionPublicKey`): [`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### options

[`CallOptionsWithProviderDataDependencies`](../type-aliases/CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\>

#### walletCoinPublicKey

`string`

#### walletEncryptionPublicKey

`string`

### Returns

[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

## Call Signature

> **createUnprovenCallTxFromInitialStates**\<`C`, `ICK`\>(`options`, `walletCoinPublicKey`, `walletEncryptionPublicKey`): [`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### options

[`CallOptionsWithPrivateState`](../type-aliases/CallOptionsWithPrivateState.md)\<`C`, `ICK`\>

#### walletCoinPublicKey

`string`

#### walletEncryptionPublicKey

`string`

### Returns

[`UnsubmittedCallTxData`](../type-aliases/UnsubmittedCallTxData.md)\<`C`, `ICK`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenDeployTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenDeployTx

# Function: createUnprovenDeployTx()

Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
from the constructor results.

## Param

The providers to use to create the deploy transaction.

## Param

Configuration.

## Call Signature

> **createUnprovenDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

### Parameters

#### providers

[`UnprovenDeployTxProviders`](../type-aliases/UnprovenDeployTxProviders.md)\<`C`\>

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

## Call Signature

> **createUnprovenDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### providers

[`UnprovenDeployTxProviders`](../type-aliases/UnprovenDeployTxProviders.md)\<`C`\>

#### options

[`DeployTxOptionsWithPrivateState`](../type-aliases/DeployTxOptionsWithPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/createUnprovenDeployTxFromVerifierKeys.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / createUnprovenDeployTxFromVerifierKeys

# Function: createUnprovenDeployTxFromVerifierKeys()

Calls a contract constructor and creates an unbalanced, unproven, unsubmitted, deploy transaction
from the constructor results.

## Param

The verifier keys for the contract being deployed.

## Param

The Zswap coin public key of the current user.

## Param

Configuration.

## Call Signature

> **createUnprovenDeployTxFromVerifierKeys**\<`C`\>(`verifierKeys`, `coinPublicKey`, `options`, `encryptionPublicKey`): [`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

### Parameters

#### verifierKeys

\[[`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]

#### coinPublicKey

`string`

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

#### encryptionPublicKey

`string`

### Returns

[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

## Call Signature

> **createUnprovenDeployTxFromVerifierKeys**\<`C`\>(`verifierKeys`, `coinPublicKey`, `options`, `encryptionPublicKey`): [`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### verifierKeys

\[[`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]

#### coinPublicKey

`string`

#### options

[`DeployTxOptionsWithPrivateState`](../type-aliases/DeployTxOptionsWithPrivateState.md)\<`C`\>

#### encryptionPublicKey

`string`

### Returns

[`UnsubmittedDeployTxData`](../type-aliases/UnsubmittedDeployTxData.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/deployContract.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / deployContract

# Function: deployContract()

Creates and submits a contract deployment transaction. This function is the entry point for the transaction
construction workflow and is used to create a [DeployedContract](../type-aliases/DeployedContract.md) instance.

## Param

The providers used to manage the transaction lifecycle.

## Param

Configuration.

## Throws

DeployTxFailedError If the transaction is submitted successfully but produces an error
                            when executed by the node.

## Call Signature

> **deployContract**\<`C`\>(`providers`, `options`): `Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `unknown`\>

#### options

[`DeployContractOptionsBase`](../type-aliases/DeployContractOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

## Call Signature

> **deployContract**\<`C`\>(`providers`, `options`): `Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`DeployContractOptionsWithPrivateState`](../type-aliases/DeployContractOptionsWithPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`DeployedContract`](../type-aliases/DeployedContract.md)\<`C`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/findDeployedContract.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / findDeployedContract

# Function: findDeployedContract()

Creates an instance of [FoundContract](../type-aliases/FoundContract.md) given the address of a deployed contract and an
optional private state ID at which an existing private state is stored. When given, the current value
at the private state ID is used as the `initialPrivateState` value in the `finalizedDeployTxData`
property of the returned `FoundContract`.

## Param

The providers used to manage transaction lifecycles.

## Param

Configuration.

## Throws

Error Improper `privateStateId` and `initialPrivateState` configuration.

## Throws

Error No contract state could be found at `contractAddress`.

## Throws

TypeError Thrown if `contractAddress` is not correctly formatted as a contract address.

## Throws

ContractTypeError One or more circuits defined on `contract` are undefined on the contract
                          state found at `contractAddress`, or have mis-matched verifier keys.

## Throws

IncompleteFindContractPrivateStateConfig If an `initialPrivateState` is given but no
                                                 `privateStateId` is given to store it under.

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `unknown`\>

#### options

[`FindDeployedContractOptionsBase`](../type-aliases/FindDeployedContractOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`FindDeployedContractOptionsExistingPrivateState`](../type-aliases/FindDeployedContractOptionsExistingPrivateState.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

## Call Signature

> **findDeployedContract**\<`C`\>(`providers`, `options`): `Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`FindDeployedContractOptionsStorePrivateState`](../type-aliases/FindDeployedContractOptionsStorePrivateState.md)\<`C`\>

### Returns

`Promise`\<[`FoundContract`](../type-aliases/FoundContract.md)\<`C`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/getPublicStates.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / getPublicStates

# Function: getPublicStates()

> **getPublicStates**(`publicDataProvider`, `contractAddress`): `Promise`\<[`PublicContractStates`](../type-aliases/PublicContractStates.md)\>

Fetches only the public visible (Zswap and ledger) states of a contract.

## Parameters

### publicDataProvider

[`PublicDataProvider`](../../midnight-js-types/interfaces/PublicDataProvider.md)

The provider to use to fetch the public states (Zswap and ledger)
                          from the blockchain.

### contractAddress

`string`

The ledger address of the contract.

## Returns

`Promise`\<[`PublicContractStates`](../type-aliases/PublicContractStates.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/getStates.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / getStates

# Function: getStates()

> **getStates**\<`PS`\>(`publicDataProvider`, `privateStateProvider`, `contractAddress`, `privateStateId`): `Promise`\<[`ContractStates`](../type-aliases/ContractStates.md)\<`PS`\>\>

Retrieves the Zswap, ledger, and private states of the contract corresponding
to the given identifier using the given providers.

## Type Parameters

### PS

`PS`

## Parameters

### publicDataProvider

[`PublicDataProvider`](../../midnight-js-types/interfaces/PublicDataProvider.md)

The provider to use to fetch the public states (Zswap and ledger)
                          from the blockchain.

### privateStateProvider

[`PrivateStateProvider`](../../midnight-js-types/interfaces/PrivateStateProvider.md)\<`string`, `PS`\>

The provider to use to fetch the private state.

### contractAddress

`string`

The ledger address of the contract.

### privateStateId

`string`

The identifier for the private state of the contract.

## Returns

`Promise`\<[`ContractStates`](../type-aliases/ContractStates.md)\<`PS`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitCallTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitCallTx

# Function: submitCallTx()

Creates and submits a transaction for the invocation of a circuit on a given contract.

## Param

The providers used to manage the invocation lifecycle.

## Param

Configuration.

## Call Signature

> **submitCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`SubmitTxProviders`](../type-aliases/SubmitTxProviders.md)\<`C`, `ICK`\>

#### options

[`CallTxOptionsBase`](../type-aliases/CallTxOptionsBase.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

## Call Signature

> **submitCallTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

#### ICK

`ICK` *extends* `string`

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`CallTxOptionsWithPrivateStateId`](../type-aliases/CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

### Returns

`Promise`\<[`FinalizedCallTxData`](../type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitDeployTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitDeployTx

# Function: submitDeployTx()

Creates and submits a deploy transaction for the given contract.

## Param

The providers used to manage the deploy lifecycle.

## Param

Configuration.

## Call Signature

> **submitDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`undefined`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`undefined`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`, [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `unknown`\>

#### options

[`DeployTxOptionsBase`](../type-aliases/DeployTxOptionsBase.md)\<`C`\>

### Returns

`Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

## Call Signature

> **submitDeployTx**\<`C`\>(`providers`, `options`): `Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>

### Type Parameters

#### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### Parameters

#### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)\<`C`\>

#### options

[`DeployTxOptionsWithPrivateStateId`](../type-aliases/DeployTxOptionsWithPrivateStateId.md)\<`C`\>

### Returns

`Promise`\<[`FinalizedDeployTxData`](../type-aliases/FinalizedDeployTxData.md)\<`C`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitInsertVerifierKeyTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitInsertVerifierKeyTx

# Function: submitInsertVerifierKeyTx()

> **submitInsertVerifierKeyTx**(`providers`, `contractAddress`, `circuitId`, `newVk`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that adds a new verifier key to the
blockchain for the given circuit ID at the given contract address.

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract containing the circuit for which
                       the verifier key should be inserted.

### circuitId

`string`

The circuit for which the verifier key should be inserted.

### newVk

[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)

The new verifier key for the circuit.

## Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.

TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
      automatically rotated in this function. This likely involves storing key versions
      along with keys in ZKConfigProvider. By default, artifacts for the latest version
      would be fetched to build transactions.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitRemoveVerifierKeyTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitRemoveVerifierKeyTx

# Function: submitRemoveVerifierKeyTx()

> **submitRemoveVerifierKeyTx**(`providers`, `contractAddress`, `circuitId`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that removes the current verifier key stored
on the blockchain for the given circuit ID at the given contract address.

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract containing the circuit for which
                       the verifier key should be removed.

### circuitId

`string`

The circuit for which the verifier key should be removed.

## Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.

TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
      automatically rotated in this function. This likely involves storing key versions
      along with keys in ZKConfigProvider. By default, artifacts for the latest version
      would be fetched to build transactions.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitReplaceAuthorityTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitReplaceAuthorityTx

# Function: submitReplaceAuthorityTx()

> **submitReplaceAuthorityTx**(`providers`, `contractAddress`): (`newAuthority`) => `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that replaces the maintenance
authority stored on the blockchain for this contract. After the transaction is
finalized, the current signing key stored in the given private state provider
is overwritten with the given new authority key.

## Parameters

### providers

[`ContractProviders`](../type-aliases/ContractProviders.md)

The providers to use to manage the transaction lifecycle.

### contractAddress

`string`

The address of the contract for which the maintenance
                       authority should be updated.

TODO: There are at least three options we should support in the future:
      1. Replace authority and maintain key (current).
      2. Replace authority and do not maintain key.
      3. Add additional authorities and maintain original key.

## Returns

> (`newAuthority`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

### Parameters

#### newAuthority

`string`

The signing key of the new contract maintenance authority.

### Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

A promise that resolves with the finalized transaction data, or rejects if
         an error occurs along the way.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/submitTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / submitTx

# Function: submitTx()

> **submitTx**\<`C`, `ICK`\>(`providers`, `options`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Proves, balances, and submits an unproven deployment or call transaction using
the given providers, according to the given options.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`SubmitTxProviders`](../type-aliases/SubmitTxProviders.md)\<`C`, `ICK`\>

The providers used to manage the transaction lifecycle.

### options

[`SubmitTxOptions`](../type-aliases/SubmitTxOptions.md)\<`ICK`\>

Configuration.

## Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

A promise that resolves with the finalized transaction data for the invocation,
         or rejects if an error occurs along the way.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/verifierKeysEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / verifierKeysEqual

# Function: verifierKeysEqual()

> **verifierKeysEqual**(`a`, `b`): `boolean`

Checks that two verifier keys are equal. Does initial length check match for efficiency.

## Parameters

### a

`Uint8Array`

First verifier key.

### b

`Uint8Array`

Second verifier key.

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/verifyContractState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / verifyContractState

# Function: verifyContractState()

> **verifyContractState**(`verifierKeys`, `contractState`): `void`

Checks that the given `contractState` contains the given `verifierKeys`.

## Parameters

### verifierKeys

\[`string`, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]

The verifier keys the client has for the deployed contract we're checking.

### contractState

`ContractState`

The (typically already deployed) contract state containing verifier keys.

## Returns

`void`

## Throws

ContractTypeError When one or more of the local and deployed verifier keys do not match.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptions

# Type Alias: CallOptions\<C, ICK\>

> **CallOptions**\<`C`, `ICK`\> = [`CallOptionsWithProviderDataDependencies`](CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\> \| [`CallOptionsWithPrivateState`](CallOptionsWithPrivateState.md)\<`C`, `ICK`\>

Call options for a given contract and circuit.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsBase

# Type Alias: CallOptionsBase\<C, ICK\>

> **CallOptionsBase**\<`C`, `ICK`\> = `object`

Describes the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>

## Properties

### circuitId

> `readonly` **circuitId**: `ICK`

The identifier of the circuit to call.

***

### contract

> `readonly` **contract**: `C`

The contract defining the circuit to call.

***

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The address of the contract being executed.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsProviderDataDependencies.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsProviderDataDependencies

# Type Alias: CallOptionsProviderDataDependencies

> **CallOptionsProviderDataDependencies** = `object`

Data retrieved via providers that should be included in the call options.

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `CoinPublicKey`

The Zswap public key of the current user.

***

### initialContractState

> `readonly` **initialContractState**: `ContractState`

The initial public state of the contract to run the circuit against.

***

### initialZswapChainState

> `readonly` **initialZswapChainState**: `ZswapChainState`

The initial public Zswap state of the contract to run the circuit against.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithArguments.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithArguments

# Type Alias: CallOptionsWithArguments\<C, ICK\>

> **CallOptionsWithArguments**\<`C`, `ICK`\> = [`CircuitParameters`](../../midnight-js-types/type-aliases/CircuitParameters.md)\<`C`, `ICK`\> *extends* \[\] ? [`CallOptionsBase`](CallOptionsBase.md)\<`C`, `ICK`\> : [`CallOptionsBase`](CallOptionsBase.md)\<`C`, `ICK`\> & `object`

Conditional type that optionally adds the inferred circuit argument types to
the options for a circuit call.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithPrivateState

# Type Alias: CallOptionsWithPrivateState\<C, ICK\>

> **CallOptionsWithPrivateState**\<`C`, `ICK`\> = [`CallOptionsWithProviderDataDependencies`](CallOptionsWithProviderDataDependencies.md)\<`C`, `ICK`\> & `object`

Call options for contracts with private state.

## Type declaration

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state to run the circuit against.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallOptionsWithProviderDataDependencies.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallOptionsWithProviderDataDependencies

# Type Alias: CallOptionsWithProviderDataDependencies\<C, ICK\>

> **CallOptionsWithProviderDataDependencies**\<`C`, `ICK`\> = [`CallOptionsWithArguments`](CallOptionsWithArguments.md)\<`C`, `ICK`\> & [`CallOptionsProviderDataDependencies`](CallOptionsProviderDataDependencies.md)

Call options with circuit arguments and data

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResult.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResult

# Type Alias: CallResult\<C, ICK\>

> **CallResult**\<`C`, `ICK`\> = `object`

Contains all information resulting from circuit execution.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>

## Properties

### private

> `readonly` **private**: [`CallResultPrivate`](CallResultPrivate.md)\<`C`, `ICK`\>

The private/sensitive data produced by the circuit execution.

***

### public

> `readonly` **public**: [`CallResultPublic`](CallResultPublic.md)

The public/non-sensitive data produced by the circuit execution.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResultPrivate.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResultPrivate

# Type Alias: CallResultPrivate\<C, ICK\>

> **CallResultPrivate**\<`C`, `ICK`\> = `object`

The private (sensitive) portions of the call result.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>

## Properties

### input

> `readonly` **input**: `AlignedValue`

ZK representation of the circuit arguments.

***

### nextPrivateState

> `readonly` **nextPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state resulting from executing the circuit.

***

### nextZswapLocalState

> `readonly` **nextZswapLocalState**: `ZswapLocalState`

The Zswap local state resulting from executing the circuit.

***

### output

> `readonly` **output**: `AlignedValue`

ZK representation of the circuit result.

***

### privateTranscriptOutputs

> `readonly` **privateTranscriptOutputs**: `AlignedValue`[]

ZK representation of the circuit witness call results.

***

### result

> `readonly` **result**: [`CircuitReturnType`](../../midnight-js-types/type-aliases/CircuitReturnType.md)\<`C`, `ICK`\>

The JS representation of the input to the circuit.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallResultPublic.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallResultPublic

# Type Alias: CallResultPublic

> **CallResultPublic** = `object`

The public portions of the call result.

## Properties

### nextContractState

> `readonly` **nextContractState**: `StateValue`

The public state resulting from executing the circuit.

***

### partitionedTranscript

> `readonly` **partitionedTranscript**: [`PartitionedTranscript`](PartitionedTranscript.md)

A [publicTranscript](#publictranscript) partitioned into guaranteed and fallible sections.
The guaranteed section of a public transcript must succeed for the corresponding
transaction to be considered valid. The fallible section of a public transcript
can fail without invalidating the transaction, as long as the guaranteed section succeeds.

***

### publicTranscript

> `readonly` **publicTranscript**: `Op`\<`AlignedValue`\>[]

The public transcript resulting from executing the circuit.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptions

# Type Alias: CallTxOptions\<C, ICK\>

> **CallTxOptions**\<`C`, `ICK`\> = [`CallTxOptionsBase`](CallTxOptionsBase.md)\<`C`, `ICK`\> \| [`CallTxOptionsWithPrivateStateId`](CallTxOptionsWithPrivateStateId.md)\<`C`, `ICK`\>

Call transaction configuration.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptionsBase

# Type Alias: CallTxOptionsBase\<C, ICK\>

> **CallTxOptionsBase**\<`C`, `ICK`\> = [`CallOptionsWithArguments`](CallOptionsWithArguments.md)\<`C`, `ICK`\>

Base type for configuration for a call transaction; identical to [CallOptionsWithArguments](CallOptionsWithArguments.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CallTxOptionsWithPrivateStateId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CallTxOptionsWithPrivateStateId

# Type Alias: CallTxOptionsWithPrivateStateId\<C, ICK\>

> **CallTxOptionsWithPrivateStateId**\<`C`, `ICK`\> = [`CallTxOptionsBase`](CallTxOptionsBase.md)\<`C`, `ICK`\> & `object`

Call transaction options with the private state ID to use to store the new private
state resulting from the circuit call. Since a private state should already be
stored at the given private state ID, we don't need an 'initialPrivateState' like
in [DeployTxOptionsWithPrivateState](DeployTxOptionsWithPrivateState.md).

## Type declaration

### privateStateId

> `readonly` **privateStateId**: [`PrivateStateId`](../../midnight-js-types/type-aliases/PrivateStateId.md)

The identifier for the private state of the contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitCallTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitCallTxInterface

# Type Alias: CircuitCallTxInterface\<C\>

> **CircuitCallTxInterface**\<`C`\> = `{ [ICK in ImpureCircuitId<C>]: (args: CircuitParameters<C, ICK>) => Promise<FinalizedCallTxData<C, ICK>> }`

A type that lifts each circuit defined in a contract to a function that builds
and submits a call transaction.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitMaintenanceTxInterface

# Type Alias: CircuitMaintenanceTxInterface

> **CircuitMaintenanceTxInterface** = `object`

An interface for creating maintenance transactions for a specific circuit defined in a
given contract.

## Methods

### insertVerifierKey()

> **insertVerifierKey**(`newVk`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that adds a new verifier key to the
blockchain for this circuit at this contract's address.

#### Parameters

##### newVk

[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)

The new verifier key to add for this circuit.

#### Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

***

### removeVerifierKey()

> **removeVerifierKey**(): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that removes the current verifier key stored
on the blockchain for this circuit at this contract's address.

#### Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterfaces.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / CircuitMaintenanceTxInterfaces

# Type Alias: CircuitMaintenanceTxInterfaces\<C\>

> **CircuitMaintenanceTxInterfaces**\<`C`\> = `{ [ICK in ImpureCircuitId<C>]: CircuitMaintenanceTxInterface }`

A set of maintenance transaction creation interfaces, one for each circuit defined in
a given contract, keyed by the circuit name.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptions

# Type Alias: ContractConstructorOptions\<C\>

> **ContractConstructorOptions**\<`C`\> = [`ContractConstructorOptionsWithProviderDataDependencies`](ContractConstructorOptionsWithProviderDataDependencies.md)\<`C`\> \| [`ContractConstructorOptionsWithPrivateState`](ContractConstructorOptionsWithPrivateState.md)\<`C`\>

Conditional type that optionally adds the inferred circuit argument types to
the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsBase

# Type Alias: ContractConstructorOptionsBase\<C\>

> **ContractConstructorOptionsBase**\<`C`\> = `object`

Describes the target of a circuit invocation.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### contract

> `readonly` **contract**: `C`

The contract defining the circuit to call.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsProviderDataDependencies.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsProviderDataDependencies

# Type Alias: ContractConstructorOptionsProviderDataDependencies

> **ContractConstructorOptionsProviderDataDependencies** = `object`

Data retrieved via providers that should be included in the constructor call options.

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `CoinPublicKey`

The current user's ZSwap public key.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithArguments.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithArguments

# Type Alias: ContractConstructorOptionsWithArguments\<C\>

> **ContractConstructorOptionsWithArguments**\<`C`\> = [`InitialStateParameters`](../../midnight-js-types/type-aliases/InitialStateParameters.md)\<`C`\> *extends* \[\] ? [`ContractConstructorOptionsBase`](ContractConstructorOptionsBase.md)\<`C`\> : [`ContractConstructorOptionsBase`](ContractConstructorOptionsBase.md)\<`C`\> & `object`

Conditional type that optionally adds the inferred contract constructor argument types
to the constructor options.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithPrivateState

# Type Alias: ContractConstructorOptionsWithPrivateState\<C\>

> **ContractConstructorOptionsWithPrivateState**\<`C`\> = [`ContractConstructorOptionsWithProviderDataDependencies`](ContractConstructorOptionsWithProviderDataDependencies.md)\<`C`\> & `object`

Conditional type that optionally adds the inferred circuit argument types to
the target of a circuit invocation.

## Type declaration

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state to run the circuit against.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorOptionsWithProviderDataDependencies.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorOptionsWithProviderDataDependencies

# Type Alias: ContractConstructorOptionsWithProviderDataDependencies\<C\>

> **ContractConstructorOptionsWithProviderDataDependencies**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & [`ContractConstructorOptionsProviderDataDependencies`](ContractConstructorOptionsProviderDataDependencies.md)

Contract constructor options including arguments and provider data.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractConstructorResult.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractConstructorResult

# Type Alias: ContractConstructorResult\<C\>

> **ContractConstructorResult**\<`C`\> = `object`

The updated states resulting from executing a contract constructor.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### nextContractState

> `readonly` **nextContractState**: `ContractState`

The public state resulting from executing the contract constructor.

***

### nextPrivateState

> `readonly` **nextPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state resulting from executing the contract constructor.

***

### nextZswapLocalState

> `readonly` **nextZswapLocalState**: `ZswapLocalState`

The Zswap local state resulting from executing the contract constructor.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractMaintenanceTxInterface.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractMaintenanceTxInterface

# Type Alias: ContractMaintenanceTxInterface

> **ContractMaintenanceTxInterface** = `object`

Interface for creating maintenance transactions for a contract that was
deployed.

## Methods

### replaceAuthority()

> **replaceAuthority**(`newAuthority`): `Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>

Constructs and submits a transaction that replaces the maintenance
authority stored on the blockchain for this contract.

#### Parameters

##### newAuthority

`string`

The new contract maintenance authority for this contract.

#### Returns

`Promise`\<[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractProviders.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractProviders

# Type Alias: ContractProviders\<C, ICK, PS\>

> **ContractProviders**\<`C`, `ICK`, `PS`\> = [`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<`ICK`, [`PrivateStateId`](../../midnight-js-types/type-aliases/PrivateStateId.md), `PS`\>

Convenience type for representing the set of providers necessary to use
a given contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md) = [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\> = [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>

### PS

`PS` = [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/ContractStates.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / ContractStates

# Type Alias: ContractStates\<PS\>

> **ContractStates**\<`PS`\> = [`PublicContractStates`](PublicContractStates.md) & `object`

Object containing the publicly visible states of a contract and the private
state of a contract.

## Type declaration

### privateState

> `readonly` **privateState**: `PS`

The private state of a contract.

## Type Parameters

### PS

`PS`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptions

# Type Alias: DeployContractOptions\<C\>

> **DeployContractOptions**\<`C`\> = [`DeployContractOptionsBase`](DeployContractOptionsBase.md)\<`C`\> \| [`DeployContractOptionsWithPrivateState`](DeployContractOptionsWithPrivateState.md)\<`C`\>

Configuration for [deployContract](../functions/deployContract.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptionsBase

# Type Alias: DeployContractOptionsBase\<C\>

> **DeployContractOptionsBase**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & `object`

Base type for configuration for [deployContract](../functions/deployContract.md); identical to
[ContractConstructorOptionsWithArguments](ContractConstructorOptionsWithArguments.md) except the `signingKey` is
now optional, since [deployContract](../functions/deployContract.md) will generate a fresh signing key
in the event that `signingKey` is undefined.

## Type declaration

### signingKey?

> `readonly` `optional` **signingKey**: `SigningKey`

The signing key to add as the to-be-deployed contract's maintenance authority.
If undefined, a new signing key is sampled and used as the CMA then stored
in the private state provider under the newly deployed contract's address.
Otherwise, the passed signing key is added as the CMA. The second case is
useful when you want to use the same CMA for two different contracts.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptionsWithPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployContractOptionsWithPrivateState

# Type Alias: DeployContractOptionsWithPrivateState\<C\>

> **DeployContractOptionsWithPrivateState**\<`C`\> = [`DeployContractOptionsBase`](DeployContractOptionsBase.md)\<`C`\> & `object`

[deployContract](../functions/deployContract.md) base options with information needed to store private states;
only used if the contract being deployed has a private state.

## Type declaration

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state to run the circuit against.

### privateStateId

> `readonly` **privateStateId**: [`PrivateStateId`](../../midnight-js-types/type-aliases/PrivateStateId.md)

An identifier for the private state of the contract being found.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployedContract.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployedContract

# Type Alias: DeployedContract\<C\>

> **DeployedContract**\<`C`\> = [`FoundContract`](FoundContract.md)\<`C`\> & `object`

Interface for a contract that has been deployed to the blockchain.

## Type declaration

### deployTxData

> `readonly` **deployTxData**: [`FinalizedDeployTxData`](FinalizedDeployTxData.md)\<`C`\>

Data resulting from the deployment transaction that created this contract. The information in a
deployTxData contains additional private information that does not
exist in [FoundContract.deployTxData](FoundContract.md#deploytxdata) because certain private data is only available to
the deployer of a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptions

# Type Alias: DeployTxOptions\<C\>

> **DeployTxOptions**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> \| [`DeployTxOptionsWithPrivateStateId`](DeployTxOptionsWithPrivateStateId.md)\<`C`\>

Configuration for creating deploy transactions.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsBase

# Type Alias: DeployTxOptionsBase\<C\>

> **DeployTxOptionsBase**\<`C`\> = [`ContractConstructorOptionsWithArguments`](ContractConstructorOptionsWithArguments.md)\<`C`\> & `object`

Base type for deploy transaction configuration.

## Type declaration

### signingKey

> `readonly` **signingKey**: `SigningKey`

The signing key to add as the to-be-deployed contract's maintenance authority.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsWithPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsWithPrivateState

# Type Alias: DeployTxOptionsWithPrivateState\<C\>

> **DeployTxOptionsWithPrivateState**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> & `object`

Configuration for creating deploy transactions for contracts with private state. This
configuration used as a base type for the [DeployTxOptionsWithPrivateStateId](DeployTxOptionsWithPrivateStateId.md) configuration.
It is also used directly as parameter to [createUnprovenDeployTx](../functions/createUnprovenDeployTx.md) which doesn't need
to save private state (and therefore doesn't need a private state ID) but does need to supply an
initial private state to run the contract constructor against.

## Type declaration

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The private state to run the contract constructor against.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployTxOptionsWithPrivateStateId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / DeployTxOptionsWithPrivateStateId

# Type Alias: DeployTxOptionsWithPrivateStateId\<C\>

> **DeployTxOptionsWithPrivateStateId**\<`C`\> = [`DeployTxOptionsWithPrivateState`](DeployTxOptionsWithPrivateState.md)\<`C`\> & `object`

Configuration for creating deploy transactions for contracts with private state. This
configuration is used when a deployment transaction is created and an initial private
state needs to be stored, as is the case in [submitDeployTx](../functions/submitDeployTx.md).

## Type declaration

### privateStateId

> `readonly` **privateStateId**: [`PrivateStateId`](../../midnight-js-types/type-aliases/PrivateStateId.md)

The identifier for the private state of the contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedCallTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedCallTxData

# Type Alias: FinalizedCallTxData\<C, ICK\>

> **FinalizedCallTxData**\<`C`, `ICK`\> = [`UnsubmittedCallTxData`](UnsubmittedCallTxData.md)\<`C`, `ICK`\> & `object`

Data for a submitted, finalized call transaction.

## Type declaration

### public

> `readonly` **public**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

Public data relevant to this call transaction.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedDeployTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedDeployTxData

# Type Alias: FinalizedDeployTxData\<C\>

> **FinalizedDeployTxData**\<`C`\> = [`UnsubmittedDeployTxData`](UnsubmittedDeployTxData.md)\<`C`\> & `object`

Data for a finalized deploy transaction submitted in this process.

## Type declaration

### public

> `readonly` **public**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The data of this transaction that is visible on the blockchain.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FinalizedDeployTxDataBase

# Type Alias: FinalizedDeployTxDataBase\<C\>

> **FinalizedDeployTxDataBase**\<`C`\> = [`UnsubmittedDeployTxDataBase`](UnsubmittedDeployTxDataBase.md)\<`C`\> & `object`

Data for a finalized deploy transaction submitted in this process.

## Type declaration

### public

> `readonly` **public**: [`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

The data of this transaction that is visible on the blockchain.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptions

# Type Alias: FindDeployedContractOptions\<C\>

> **FindDeployedContractOptions**\<`C`\> = [`FindDeployedContractOptionsBase`](FindDeployedContractOptionsBase.md)\<`C`\> \| [`FindDeployedContractOptionsExistingPrivateState`](FindDeployedContractOptionsExistingPrivateState.md)\<`C`\> \| [`FindDeployedContractOptionsStorePrivateState`](FindDeployedContractOptionsStorePrivateState.md)\<`C`\>

Configuration for [findDeployedContract](../functions/findDeployedContract.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsBase

# Type Alias: FindDeployedContractOptionsBase\<C\>

> **FindDeployedContractOptionsBase**\<`C`\> = `object`

Base type for the configuration options for [findDeployedContract](../functions/findDeployedContract.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### contract

> `readonly` **contract**: `C`

The contract to use to execute circuits.

***

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The address of a previously deployed contract.

***

### signingKey?

> `readonly` `optional` **signingKey**: `SigningKey`

The signing key to use to perform contract maintenance updates. If defined, the given signing
key is stored for this contract address. This is useful when someone has already added the given signing
key to the contract maintenance authority. If undefined, and there is an existing signing key for the
contract address locally, the existing signing key is kept. This is useful when the contract was
deployed locally. If undefined, and there is not an existing signing key for the contract address
locally, a fresh signing key is generated and stored for the contract address locally. This is
useful when you want to give a signing key to someone else to add you as a maintenance authority.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsExistingPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsExistingPrivateState

# Type Alias: FindDeployedContractOptionsExistingPrivateState\<C\>

> **FindDeployedContractOptionsExistingPrivateState**\<`C`\> = [`FindDeployedContractOptionsBase`](FindDeployedContractOptionsBase.md)\<`C`\> & `object`

[findDeployedContract](../functions/findDeployedContract.md) base configuration that includes an initial private
state to store and the private state ID at which to store it. Only used if
the intention is to overwrite the private state currently stored at the given
private state ID.

## Type declaration

### privateStateId

> `readonly` **privateStateId**: [`PrivateStateId`](../../midnight-js-types/type-aliases/PrivateStateId.md)

An identifier for the private state of the contract being found.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FindDeployedContractOptionsStorePrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FindDeployedContractOptionsStorePrivateState

# Type Alias: FindDeployedContractOptionsStorePrivateState\<C\>

> **FindDeployedContractOptionsStorePrivateState**\<`C`\> = [`FindDeployedContractOptionsExistingPrivateState`](FindDeployedContractOptionsExistingPrivateState.md)\<`C`\> & `object`

[findDeployedContract](../functions/findDeployedContract.md) configuration that includes an initial private
state to store and the private state ID at which to store it. Only used if
the intention is to overwrite the private state currently stored at the given
private state ID.

## Type declaration

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

For types of contract that make no use of private state and or witnesses that operate upon it, this
property may be `undefined`. Otherwise, the value provided via this property should be same initial
state that was used when calling [deployContract](../functions/deployContract.md).

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FoundContract.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / FoundContract

# Type Alias: FoundContract\<C\>

> **FoundContract**\<`C`\> = `object`

Base type for a deployed contract that has been found on the blockchain.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### callTx

> `readonly` **callTx**: [`CircuitCallTxInterface`](CircuitCallTxInterface.md)\<`C`\>

Interface for creating call transactions for a contract.

***

### circuitMaintenanceTx

> `readonly` **circuitMaintenanceTx**: [`CircuitMaintenanceTxInterfaces`](CircuitMaintenanceTxInterfaces.md)\<`C`\>

An interface for creating maintenance transactions for circuits defined in the
contract that was deployed.

***

### contractMaintenanceTx

> `readonly` **contractMaintenanceTx**: [`ContractMaintenanceTxInterface`](ContractMaintenanceTxInterface.md)

Interface for creating maintenance transactions for the contract that was
deployed.

***

### deployTxData

> `readonly` **deployTxData**: [`FinalizedDeployTxDataBase`](FinalizedDeployTxDataBase.md)\<`C`\>

Data for the finalized deploy transaction corresponding to this contract.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/PartitionedTranscript.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / PartitionedTranscript

# Type Alias: PartitionedTranscript

> **PartitionedTranscript** = \[`Transcript`\<`AlignedValue`\> \| `undefined`, `Transcript`\<`AlignedValue`\> \| `undefined`\]

Convenience type for result returned from partitionTranscripts.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/PublicContractStates.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / PublicContractStates

# Type Alias: PublicContractStates

> **PublicContractStates** = `object`

Object containing the publicly visible states of a contract.

## Properties

### contractState

> `readonly` **contractState**: `ContractState`

The (public) ledger state of a contract.

***

### zswapChainState

> `readonly` **zswapChainState**: `ZswapChainState`

The (public) Zswap chain state of a contract.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/SubmitTxOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / SubmitTxOptions

# Type Alias: SubmitTxOptions\<ICK\>

> **SubmitTxOptions**\<`ICK`\> = `object`

Configuration for [submitTx](../functions/submitTx.md).

## Type Parameters

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)

## Properties

### circuitId?

> `readonly` `optional` **circuitId**: `ICK`

A circuit identifier to use to fetch the ZK artifacts needed to prove the
transaction. Only defined if a call transaction is being submitted.

***

### newCoins?

> `readonly` `optional` **newCoins**: `CoinInfo`[]

Any new coins created during the construction of the transaction. Only defined
if the transaction being submitted is a call or deploy transaction.

***

### unprovenTx

> `readonly` **unprovenTx**: `UnprovenTransaction`

The transaction to prove, balance, and submit.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/SubmitTxProviders.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / SubmitTxProviders

# Type Alias: SubmitTxProviders\<C, ICK\>

> **SubmitTxProviders**\<`C`, `ICK`\> = `Omit`\<[`ContractProviders`](ContractProviders.md)\<`C`, `ICK`\>, `"privateStateProvider"`\>

Providers required to submit an unproven deployment transaction. Since [submitTx](../functions/submitTx.md) doesn't
manipulate private state, the private state provider can be omitted.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenCallTxProvidersBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenCallTxProvidersBase

# Type Alias: UnprovenCallTxProvidersBase

> **UnprovenCallTxProvidersBase** = `Pick`\<[`ContractProviders`](ContractProviders.md), `"publicDataProvider"` \| `"walletProvider"`\>

The minimum set of providers needed to create a call transaction, the ZK
artifact provider and a wallet. By defining this type, users can choose to
omit a private state provider if they're creating a call transaction for a
contract with no private state.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenCallTxProvidersWithPrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenCallTxProvidersWithPrivateState

# Type Alias: UnprovenCallTxProvidersWithPrivateState\<C\>

> **UnprovenCallTxProvidersWithPrivateState**\<`C`\> = [`UnprovenCallTxProvidersBase`](UnprovenCallTxProvidersBase.md) & `Pick`\<[`ContractProviders`](ContractProviders.md)\<`C`\>, `"privateStateProvider"`\>

Same providers as [UnprovenCallTxProvidersBase](UnprovenCallTxProvidersBase.md) with an additional private
state provider to store the new private state resulting from the circuit call -
only used when creating a call transaction for a contract with a private state.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenDeployTxOptions.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenDeployTxOptions

# Type Alias: UnprovenDeployTxOptions\<C\>

> **UnprovenDeployTxOptions**\<`C`\> = [`DeployTxOptionsBase`](DeployTxOptionsBase.md)\<`C`\> \| [`DeployTxOptionsWithPrivateState`](DeployTxOptionsWithPrivateState.md)\<`C`\>

Configuration for creating unproven deploy transactions.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnprovenDeployTxProviders.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnprovenDeployTxProviders

# Type Alias: UnprovenDeployTxProviders\<C\>

> **UnprovenDeployTxProviders**\<`C`\> = `Pick`\<[`ContractProviders`](ContractProviders.md)\<`C`\>, `"zkConfigProvider"` \| `"walletProvider"`\>

Providers needed to create an unproven deployment transactions, just the ZK artifact
provider and a wallet.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedCallTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedCallTxData

# Type Alias: UnsubmittedCallTxData\<C, ICK\>

> **UnsubmittedCallTxData**\<`C`, `ICK`\> = [`CallResult`](CallResult.md)\<`C`, `ICK`\> & `object`

Data for an unsubmitted call transaction.

## Type declaration

### private

> `readonly` **private**: [`UnsubmittedTxData`](UnsubmittedTxData.md)

Private data relevant to this call transaction.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

### ICK

`ICK` *extends* [`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxData

# Type Alias: UnsubmittedDeployTxData\<C\>

> **UnsubmittedDeployTxData**\<`C`\> = [`UnsubmittedDeployTxDataBase`](UnsubmittedDeployTxDataBase.md)\<`C`\> & `object`

Data for an unsubmitted deployment transaction.

## Type declaration

### private

> `readonly` **private**: [`UnsubmittedTxData`](UnsubmittedTxData.md) & `object`

The data of this transaction that is only visible on the user device.

#### Type declaration

##### initialZswapState

> `readonly` **initialZswapState**: `ZswapLocalState`

The Zswap state produced as a result of running the contract constructor. Useful for when
inputs or outputs are created in the contract constructor.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxDataBase.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxDataBase

# Type Alias: UnsubmittedDeployTxDataBase\<C\>

> **UnsubmittedDeployTxDataBase**\<`C`\> = `object`

Base type for data relevant to an unsubmitted deployment transaction.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### private

> `readonly` **private**: [`UnsubmittedDeployTxPrivateData`](UnsubmittedDeployTxPrivateData.md)\<`C`\>

The private data (data that will not be revealed upon tx submission) relevant to the deployment transaction.

***

### public

> `readonly` **public**: [`UnsubmittedDeployTxPublicData`](UnsubmittedDeployTxPublicData.md)

The public data (data that will be revealed upon tx submission) relevant to the deployment transaction.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxPrivateData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxPrivateData

# Type Alias: UnsubmittedDeployTxPrivateData\<C\>

> **UnsubmittedDeployTxPrivateData**\<`C`\> = `object`

Base type for private data relevant to an unsubmitted deployment transaction.

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)

## Properties

### initialPrivateState

> `readonly` **initialPrivateState**: [`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

The initial private state of the contract deployed to the blockchain. This
value is persisted if the transaction succeeds.

***

### signingKey

> `readonly` **signingKey**: `SigningKey`

The signing key that was added as the deployed contract's maintenance authority.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedDeployTxPublicData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedDeployTxPublicData

# Type Alias: UnsubmittedDeployTxPublicData

> **UnsubmittedDeployTxPublicData** = `object`

Base type for public data relevant to an unsubmitted deployment transaction.

## Properties

### contractAddress

> `readonly` **contractAddress**: `ContractAddress`

The ledger address of the contract that was deployed.

***

### initialContractState

> `readonly` **initialContractState**: `ContractState`

The initial public state of the contract deployed to the blockchain.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/UnsubmittedTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-contracts](../README.md) / UnsubmittedTxData

# Type Alias: UnsubmittedTxData

> **UnsubmittedTxData** = `object`

Data relevant to any unsubmitted transaction.

## Properties

### newCoins

> `readonly` **newCoins**: `CoinInfo`[]

New coins created during the construction of the transaction.

***

### unprovenTx

> `readonly` **unprovenTx**: `UnprovenTransaction`

The unproven ledger transaction produced.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-contracts

# @midnight-ntwrk/midnight-js-contracts

## Classes

- [CallTxFailedError](classes/CallTxFailedError.md)
- [ContractTypeError](classes/ContractTypeError.md)
- [DeployTxFailedError](classes/DeployTxFailedError.md)
- [IncompleteCallTxPrivateStateConfig](classes/IncompleteCallTxPrivateStateConfig.md)
- [IncompleteFindContractPrivateStateConfig](classes/IncompleteFindContractPrivateStateConfig.md)
- [InsertVerifierKeyTxFailedError](classes/InsertVerifierKeyTxFailedError.md)
- [RemoveVerifierKeyTxFailedError](classes/RemoveVerifierKeyTxFailedError.md)
- [ReplaceMaintenanceAuthorityTxFailedError](classes/ReplaceMaintenanceAuthorityTxFailedError.md)
- [TxFailedError](classes/TxFailedError.md)

## Type Aliases

- [CallOptions](type-aliases/CallOptions.md)
- [CallOptionsBase](type-aliases/CallOptionsBase.md)
- [CallOptionsProviderDataDependencies](type-aliases/CallOptionsProviderDataDependencies.md)
- [CallOptionsWithArguments](type-aliases/CallOptionsWithArguments.md)
- [CallOptionsWithPrivateState](type-aliases/CallOptionsWithPrivateState.md)
- [CallOptionsWithProviderDataDependencies](type-aliases/CallOptionsWithProviderDataDependencies.md)
- [CallResult](type-aliases/CallResult.md)
- [CallResultPrivate](type-aliases/CallResultPrivate.md)
- [CallResultPublic](type-aliases/CallResultPublic.md)
- [CallTxOptions](type-aliases/CallTxOptions.md)
- [CallTxOptionsBase](type-aliases/CallTxOptionsBase.md)
- [CallTxOptionsWithPrivateStateId](type-aliases/CallTxOptionsWithPrivateStateId.md)
- [CircuitCallTxInterface](type-aliases/CircuitCallTxInterface.md)
- [CircuitMaintenanceTxInterface](type-aliases/CircuitMaintenanceTxInterface.md)
- [CircuitMaintenanceTxInterfaces](type-aliases/CircuitMaintenanceTxInterfaces.md)
- [ContractConstructorOptions](type-aliases/ContractConstructorOptions.md)
- [ContractConstructorOptionsBase](type-aliases/ContractConstructorOptionsBase.md)
- [ContractConstructorOptionsProviderDataDependencies](type-aliases/ContractConstructorOptionsProviderDataDependencies.md)
- [ContractConstructorOptionsWithArguments](type-aliases/ContractConstructorOptionsWithArguments.md)
- [ContractConstructorOptionsWithPrivateState](type-aliases/ContractConstructorOptionsWithPrivateState.md)
- [ContractConstructorOptionsWithProviderDataDependencies](type-aliases/ContractConstructorOptionsWithProviderDataDependencies.md)
- [ContractConstructorResult](type-aliases/ContractConstructorResult.md)
- [ContractMaintenanceTxInterface](type-aliases/ContractMaintenanceTxInterface.md)
- [ContractProviders](type-aliases/ContractProviders.md)
- [ContractStates](type-aliases/ContractStates.md)
- [DeployContractOptions](type-aliases/DeployContractOptions.md)
- [DeployContractOptionsBase](type-aliases/DeployContractOptionsBase.md)
- [DeployContractOptionsWithPrivateState](type-aliases/DeployContractOptionsWithPrivateState.md)
- [DeployedContract](type-aliases/DeployedContract.md)
- [DeployTxOptions](type-aliases/DeployTxOptions.md)
- [DeployTxOptionsBase](type-aliases/DeployTxOptionsBase.md)
- [DeployTxOptionsWithPrivateState](type-aliases/DeployTxOptionsWithPrivateState.md)
- [DeployTxOptionsWithPrivateStateId](type-aliases/DeployTxOptionsWithPrivateStateId.md)
- [FinalizedCallTxData](type-aliases/FinalizedCallTxData.md)
- [FinalizedDeployTxData](type-aliases/FinalizedDeployTxData.md)
- [FinalizedDeployTxDataBase](type-aliases/FinalizedDeployTxDataBase.md)
- [FindDeployedContractOptions](type-aliases/FindDeployedContractOptions.md)
- [FindDeployedContractOptionsBase](type-aliases/FindDeployedContractOptionsBase.md)
- [FindDeployedContractOptionsExistingPrivateState](type-aliases/FindDeployedContractOptionsExistingPrivateState.md)
- [FindDeployedContractOptionsStorePrivateState](type-aliases/FindDeployedContractOptionsStorePrivateState.md)
- [FoundContract](type-aliases/FoundContract.md)
- [PartitionedTranscript](type-aliases/PartitionedTranscript.md)
- [PublicContractStates](type-aliases/PublicContractStates.md)
- [SubmitTxOptions](type-aliases/SubmitTxOptions.md)
- [SubmitTxProviders](type-aliases/SubmitTxProviders.md)
- [UnprovenCallTxProvidersBase](type-aliases/UnprovenCallTxProvidersBase.md)
- [UnprovenCallTxProvidersWithPrivateState](type-aliases/UnprovenCallTxProvidersWithPrivateState.md)
- [UnprovenDeployTxOptions](type-aliases/UnprovenDeployTxOptions.md)
- [UnprovenDeployTxProviders](type-aliases/UnprovenDeployTxProviders.md)
- [UnsubmittedCallTxData](type-aliases/UnsubmittedCallTxData.md)
- [UnsubmittedDeployTxData](type-aliases/UnsubmittedDeployTxData.md)
- [UnsubmittedDeployTxDataBase](type-aliases/UnsubmittedDeployTxDataBase.md)
- [UnsubmittedDeployTxPrivateData](type-aliases/UnsubmittedDeployTxPrivateData.md)
- [UnsubmittedDeployTxPublicData](type-aliases/UnsubmittedDeployTxPublicData.md)
- [UnsubmittedTxData](type-aliases/UnsubmittedTxData.md)

## Functions

- [call](functions/call.md)
- [callContractConstructor](functions/callContractConstructor.md)
- [createCallTxOptions](functions/createCallTxOptions.md)
- [createCircuitCallTxInterface](functions/createCircuitCallTxInterface.md)
- [createCircuitMaintenanceTxInterface](functions/createCircuitMaintenanceTxInterface.md)
- [createCircuitMaintenanceTxInterfaces](functions/createCircuitMaintenanceTxInterfaces.md)
- [createContractMaintenanceTxInterface](functions/createContractMaintenanceTxInterface.md)
- [createUnprovenCallTx](functions/createUnprovenCallTx.md)
- [createUnprovenCallTxFromInitialStates](functions/createUnprovenCallTxFromInitialStates.md)
- [createUnprovenDeployTx](functions/createUnprovenDeployTx.md)
- [createUnprovenDeployTxFromVerifierKeys](functions/createUnprovenDeployTxFromVerifierKeys.md)
- [deployContract](functions/deployContract.md)
- [findDeployedContract](functions/findDeployedContract.md)
- [getPublicStates](functions/getPublicStates.md)
- [getStates](functions/getStates.md)
- [submitCallTx](functions/submitCallTx.md)
- [submitDeployTx](functions/submitDeployTx.md)
- [submitInsertVerifierKeyTx](functions/submitInsertVerifierKeyTx.md)
- [submitRemoveVerifierKeyTx](functions/submitRemoveVerifierKeyTx.md)
- [submitReplaceAuthorityTx](functions/submitReplaceAuthorityTx.md)
- [submitTx](functions/submitTx.md)
- [verifierKeysEqual](functions/verifierKeysEqual.md)
- [verifyContractState](functions/verifyContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-fetch-zk-config-provider/classes/FetchZkConfigProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-fetch-zk-config-provider](../README.md) / FetchZkConfigProvider

# Class: FetchZkConfigProvider\<K\>

Retrieves ZK artifacts from a remote source.

## Extends

- [`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md)\<`K`\>

## Type Parameters

### K

`K` *extends* `string`

## Constructors

### Constructor

> **new FetchZkConfigProvider**\<`K`\>(`baseURL`, `fetchFunc`): `FetchZkConfigProvider`\<`K`\>

#### Parameters

##### baseURL

`string`

The endpoint to query for ZK artifacts.

##### fetchFunc

\{(`input`, `init`?): `Promise`\<`Response`\>; (`input`, `init`?): `Promise`\<`Response`\>; \}

The function to use to execute queries.

#### Returns

`FetchZkConfigProvider`\<`K`\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`constructor`](../../midnight-js-types/classes/ZKConfigProvider.md#constructor)

## Properties

### baseURL

> `readonly` **baseURL**: `string`

The endpoint to query for ZK artifacts.

## Methods

### get()

> **get**(`circuitId`): `Promise`\<[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>\>

#### Inherited from

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`get`](../../midnight-js-types/classes/ZKConfigProvider.md#get)

***

### getProverKey()

> **getProverKey**(`circuitId`): `Promise`\<[`ProverKey`](../../midnight-js-types/type-aliases/ProverKey.md)\>

Retrieves the prover key produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the prover key to retrieve.

#### Returns

`Promise`\<[`ProverKey`](../../midnight-js-types/type-aliases/ProverKey.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getProverKey`](../../midnight-js-types/classes/ZKConfigProvider.md#getproverkey)

***

### getVerifierKey()

> **getVerifierKey**(`circuitId`): `Promise`\<[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\>

Retrieves the verifier key produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the verifier key to retrieve.

#### Returns

`Promise`\<[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getVerifierKey`](../../midnight-js-types/classes/ZKConfigProvider.md#getverifierkey)

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]\>

Retrieves the verifier keys produced by `compactc` for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]\>

#### Inherited from

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getVerifierKeys`](../../midnight-js-types/classes/ZKConfigProvider.md#getverifierkeys)

***

### getZKIR()

> **getZKIR**(`circuitId`): `Promise`\<[`ZKIR`](../../midnight-js-types/type-aliases/ZKIR.md)\>

Retrieves the zero-knowledge intermediate representation produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the ZKIR to retrieve.

#### Returns

`Promise`\<[`ZKIR`](../../midnight-js-types/type-aliases/ZKIR.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getZKIR`](../../midnight-js-types/classes/ZKConfigProvider.md#getzkir)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-fetch-zk-config-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-fetch-zk-config-provider

# @midnight-ntwrk/midnight-js-fetch-zk-config-provider

## Classes

- [FetchZkConfigProvider](classes/FetchZkConfigProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/functions/httpClientProofProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / httpClientProofProvider

# Function: httpClientProofProvider()

> **httpClientProofProvider**\<`K`\>(`url`): [`ProofProvider`](../../midnight-js-types/interfaces/ProofProvider.md)\<`K`\>

Creates a [ProofProvider](../../midnight-js-types/interfaces/ProofProvider.md) by creating a client for a running proof server.
Allows for HTTP and HTTPS. The data passed to 'proveTx' are intended to be
secret, so usage of this function should be heavily scrutinized.

## Type Parameters

### K

`K` *extends* `string`

## Parameters

### url

`string`

The url of a running proof server.

## Returns

[`ProofProvider`](../../midnight-js-types/interfaces/ProofProvider.md)\<`K`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/functions/serializePayload.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / serializePayload

# Function: serializePayload()

> **serializePayload**\<`K`\>(`unprovenTx`, `zkConfig`?): `Promise`\<`ArrayBuffer`\>

Creates a serialized proving server payload from the given transaction and
ZK configuration.

## Type Parameters

### K

`K` *extends* `string`

## Parameters

### unprovenTx

`UnprovenTransaction`

The transaction being proven.

### zkConfig?

[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>

The ZK artifacts needed to prove the transaction. Undefined
                if a deployment transaction is being proven.

## Returns

`Promise`\<`ArrayBuffer`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/functions/serializeZKConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / serializeZKConfig

# Function: serializeZKConfig()

> **serializeZKConfig**\<`K`\>(`zkConfig`?): `Uint8Array`

Serializes a [ZKConfig](../../midnight-js-types/interfaces/ZKConfig.md) using Borsh format.

## Type Parameters

### K

`K` *extends* `string`

## Parameters

### zkConfig?

[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>

The configuration to serialize.

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/variables/DEFAULT_CONFIG.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-http-client-proof-provider](../README.md) / DEFAULT\_CONFIG

# Variable: DEFAULT\_CONFIG

> `const` **DEFAULT\_CONFIG**: `object`

The default configuration for the proof server client.

## Type declaration

### timeout

> **timeout**: `number` = `300000`

The default timeout for prove requests.

### zkConfig

> **zkConfig**: `undefined` = `undefined`

The default ZK configuration to use. It is overwritten with a proper ZK
configuration only if a call transaction is being proven.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-http-client-proof-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-http-client-proof-provider

# @midnight-ntwrk/midnight-js-http-client-proof-provider

## Variables

- [DEFAULT\_CONFIG](variables/DEFAULT_CONFIG.md)

## Functions

- [httpClientProofProvider](functions/httpClientProofProvider.md)
- [serializePayload](functions/serializePayload.md)
- [serializeZKConfig](functions/serializeZKConfig.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/classes/IndexerFormattedError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / IndexerFormattedError

# Class: IndexerFormattedError

An error describing the causes of error that occurred during server-side execution of
a query against the Indexer.

## Extends

- `Error`

## Constructors

### Constructor

> **new IndexerFormattedError**(`cause`): `IndexerFormattedError`

#### Parameters

##### cause

readonly `GraphQLFormattedError`[]

An array of GraphQL errors that occurred during the server-side execution.

#### Returns

`IndexerFormattedError`

#### Overrides

`Error.constructor`

## Properties

### cause

> `readonly` **cause**: readonly `GraphQLFormattedError`[]

An array of GraphQL errors that occurred during the server-side execution.

#### Inherited from

`Error.cause`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/functions/indexerPublicDataProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-indexer-public-data-provider](../README.md) / indexerPublicDataProvider

# Function: indexerPublicDataProvider()

> **indexerPublicDataProvider**(`queryURL`, `subscriptionURL`, `webSocketImpl`): [`PublicDataProvider`](../../midnight-js-types/interfaces/PublicDataProvider.md)

Constructs a [PublicDataProvider](../../midnight-js-types/interfaces/PublicDataProvider.md) based on an ApolloClient.

## Parameters

### queryURL

`string`

The URL of a GraphQL server query endpoint.

### subscriptionURL

`string`

The URL of a GraphQL server subscription (websocket) endpoint.

### webSocketImpl

*typeof* `WebSocket` = `ws.WebSocket`

An optional websocket implementation for the Apollo client to use.

TODO: Re-examine caching when 'ContractCall' and 'ContractDeploy' have transaction identifiers included.

## Returns

[`PublicDataProvider`](../../midnight-js-types/interfaces/PublicDataProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-indexer-public-data-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-indexer-public-data-provider

# @midnight-ntwrk/midnight-js-indexer-public-data-provider

## Classes

- [IndexerFormattedError](classes/IndexerFormattedError.md)

## Functions

- [indexerPublicDataProvider](functions/indexerPublicDataProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/functions/levelPrivateStateProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / levelPrivateStateProvider

# Function: levelPrivateStateProvider()

> **levelPrivateStateProvider**\<`PSI`, `PS`\>(`partialConfig`): [`PrivateStateProvider`](../../midnight-js-types/interfaces/PrivateStateProvider.md)\<`PSI`, `PS`\>

Constructs an instance of [PrivateStateProvider](../../midnight-js-types/interfaces/PrivateStateProvider.md) based on Level database.

## Type Parameters

### PSI

`PSI` *extends* `string`

### PS

`PS` = `any`

## Parameters

### partialConfig

`Partial`\<[`LevelPrivateStateProviderConfig`](../interfaces/LevelPrivateStateProviderConfig.md)\> = `{}`

Database configuration options.

## Returns

[`PrivateStateProvider`](../../midnight-js-types/interfaces/PrivateStateProvider.md)\<`PSI`, `PS`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/interfaces/LevelPrivateStateProviderConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / LevelPrivateStateProviderConfig

# Interface: LevelPrivateStateProviderConfig

Optional properties for the indexedDB based private state provider configuration.

## Properties

### midnightDbName

> `readonly` **midnightDbName**: `string`

The name of the LevelDB database used to store all Midnight related data.

***

### privateStateStoreName

> `readonly` **privateStateStoreName**: `string`

The name of the object store containing private states.

***

### signingKeyStoreName

> `readonly` **signingKeyStoreName**: `string`

The name of the object store containing signing keys.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/variables/DEFAULT_CONFIG.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-level-private-state-provider](../README.md) / DEFAULT\_CONFIG

# Variable: DEFAULT\_CONFIG

> `const` **DEFAULT\_CONFIG**: `object`

The default configuration for the level database.

## Type declaration

### midnightDbName

> **midnightDbName**: `string` = `MN_LDB_DEFAULT_DB_NAME`

The name of the database.

### privateStateStoreName

> **privateStateStoreName**: `string` = `MN_LDB_DEFAULT_PRIS_STORE_NAME`

The name of the "level" on which to store private state.

### signingKeyStoreName

> **signingKeyStoreName**: `string` = `MN_LDB_DEFAULT_KEY_STORE_NAME`

The name of the "level" on which to store signing keys.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-level-private-state-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-level-private-state-provider

# @midnight-ntwrk/midnight-js-level-private-state-provider

## Interfaces

- [LevelPrivateStateProviderConfig](interfaces/LevelPrivateStateProviderConfig.md)

## Variables

- [DEFAULT\_CONFIG](variables/DEFAULT_CONFIG.md)

## Functions

- [levelPrivateStateProvider](functions/levelPrivateStateProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-logger-provider/classes/LoggerProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-logger-provider](../README.md) / LoggerProvider

# Class: LoggerProvider

Implementation of LoggerProvider that returns a Logger instance.

## Constructors

### Constructor

> **new LoggerProvider**(`logger`): `LoggerProvider`

#### Parameters

##### logger

`Logger`

#### Returns

`LoggerProvider`

## Properties

### debug

> **debug**: `LogFn`

***

### error

> **error**: `LogFn`

***

### fatal

> **fatal**: `LogFn`

***

### info

> **info**: `LogFn`

***

### trace

> **trace**: `LogFn`

***

### warn

> **warn**: `LogFn`

## Methods

### isLevelEnabled()

> **isLevelEnabled**(`level`): `boolean`

#### Parameters

##### level

[`LogLevel`](../../midnight-js-types/enumerations/LogLevel.md)

#### Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-logger-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-logger-provider

# @midnight-ntwrk/midnight-js-logger-provider

## Classes

- [LoggerProvider](classes/LoggerProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/classes/NetworkIdTypeError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / NetworkIdTypeError

# Class: NetworkIdTypeError

An error indicating an unexpected network identifier.

## Extends

- `TypeError`

## Constructors

### Constructor

> **new NetworkIdTypeError**(`networkId`): `NetworkIdTypeError`

#### Parameters

##### networkId

`string`

A string representation of the invalid network identifier.

#### Returns

`NetworkIdTypeError`

#### Overrides

`TypeError.constructor`

## Properties

### networkId

> `readonly` **networkId**: `string`

A string representation of the invalid network identifier.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/enumerations/NetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / NetworkId

# Enumeration: NetworkId

A valid named Midnight network identifier.

## Enumeration Members

### DevNet

> **DevNet**: `"DevNet"`

Indicates the official Midnight developer network is being used.

***

### MainNet

> **MainNet**: `"MainNet"`

Indicates the official, main, Midnight network is being used.

***

### TestNet

> **TestNet**: `"TestNet"`

Indicates the official Midnight test network is being used.

***

### Undeployed

> **Undeployed**: `"Undeployed"`

Indicates a local test network is being used.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/getLedgerNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / getLedgerNetworkId

# Function: getLedgerNetworkId()

> **getLedgerNetworkId**(): `NetworkId`

Retrieves the currently set global network identifier as a ledger.NetworkId value.

## Returns

`NetworkId`

The currently set ledger.NetworkId.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/getNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / getNetworkId

# Function: getNetworkId()

> **getNetworkId**(): [`NetworkId`](../enumerations/NetworkId.md)

Retrieves the currently set global network identifier.

## Returns

[`NetworkId`](../enumerations/NetworkId.md)

The currently set [NetworkId](../enumerations/NetworkId.md).
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/getRuntimeNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / getRuntimeNetworkId

# Function: getRuntimeNetworkId()

> **getRuntimeNetworkId**(): `NetworkId`

Retrieves the currently set global network identifier as a runtime.NetworkId value.

## Returns

`NetworkId`

The currently set runtime.NetworkId.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/getZswapNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / getZswapNetworkId

# Function: getZswapNetworkId()

> **getZswapNetworkId**(): `NetworkId`

Retrieves the currently set global network identifier as a zswap.NetworkId value.

## Returns

`NetworkId`

The currently set zswap.NetworkId.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/networkIdToHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / networkIdToHex

# Function: networkIdToHex()

> **networkIdToHex**(`networkId`): `string`

Converts a network ID to hex representation. Used for debugging.

## Parameters

### networkId

[`NetworkId`](../enumerations/NetworkId.md)

The network ID to convert to hex.

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/setNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / setNetworkId

# Function: setNetworkId()

> **setNetworkId**(`id`): `void`

Sets the global network identifier.

## Parameters

### id

[`NetworkId`](../enumerations/NetworkId.md)

A valid [NetworkId](../enumerations/NetworkId.md) value.

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/functions/stringToNetworkId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-network-id](../README.md) / stringToNetworkId

# Function: stringToNetworkId()

> **stringToNetworkId**(`networkId`): `null` \| [`NetworkId`](../enumerations/NetworkId.md)

Converts a potential network ID into a [NetworkId](../enumerations/NetworkId.md). Returns null if the string is not
a valid network ID.

## Parameters

### networkId

`string`

The string to convert.

## Returns

`null` \| [`NetworkId`](../enumerations/NetworkId.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-network-id/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-network-id

# @midnight-ntwrk/midnight-js-network-id

## Enumerations

- [NetworkId](enumerations/NetworkId.md)

## Classes

- [NetworkIdTypeError](classes/NetworkIdTypeError.md)

## Functions

- [getLedgerNetworkId](functions/getLedgerNetworkId.md)
- [getNetworkId](functions/getNetworkId.md)
- [getRuntimeNetworkId](functions/getRuntimeNetworkId.md)
- [getZswapNetworkId](functions/getZswapNetworkId.md)
- [networkIdToHex](functions/networkIdToHex.md)
- [setNetworkId](functions/setNetworkId.md)
- [stringToNetworkId](functions/stringToNetworkId.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-node-zk-config-provider/classes/NodeZkConfigProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-node-zk-config-provider](../README.md) / NodeZkConfigProvider

# Class: NodeZkConfigProvider\<K\>

Implementation of [ZKConfigProvider](../../midnight-js-types/classes/ZKConfigProvider.md) that reads the keys and zkIR from the local filesystem.

## Extends

- [`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md)\<`K`\>

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Constructors

### Constructor

> **new NodeZkConfigProvider**\<`K`\>(`directory`): `NodeZkConfigProvider`\<`K`\>

#### Parameters

##### directory

`string`

The path to the base directory containing the key and ZKIR subdirectories.

#### Returns

`NodeZkConfigProvider`\<`K`\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`constructor`](../../midnight-js-types/classes/ZKConfigProvider.md#constructor)

## Properties

### directory

> `readonly` **directory**: `string`

The path to the base directory containing the key and ZKIR subdirectories.

## Methods

### get()

> **get**(`circuitId`): `Promise`\<[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<[`ZKConfig`](../../midnight-js-types/interfaces/ZKConfig.md)\<`K`\>\>

#### Inherited from

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`get`](../../midnight-js-types/classes/ZKConfigProvider.md#get)

***

### getProverKey()

> **getProverKey**(`circuitId`): `Promise`\<[`ProverKey`](../../midnight-js-types/type-aliases/ProverKey.md)\>

[ZKConfigProvider.getProverKey](../../midnight-js-types/classes/ZKConfigProvider.md#getproverkey)

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<[`ProverKey`](../../midnight-js-types/type-aliases/ProverKey.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getProverKey`](../../midnight-js-types/classes/ZKConfigProvider.md#getproverkey)

***

### getVerifierKey()

> **getVerifierKey**(`circuitId`): `Promise`\<[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\>

[ZKConfigProvider.getVerifierKey](../../midnight-js-types/classes/ZKConfigProvider.md#getverifierkey)

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<[`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getVerifierKey`](../../midnight-js-types/classes/ZKConfigProvider.md#getverifierkey)

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]\>

Retrieves the verifier keys produced by `compactc` for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, [`VerifierKey`](../../midnight-js-types/type-aliases/VerifierKey.md)\][]\>

#### Inherited from

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getVerifierKeys`](../../midnight-js-types/classes/ZKConfigProvider.md#getverifierkeys)

***

### getZKIR()

> **getZKIR**(`circuitId`): `Promise`\<[`ZKIR`](../../midnight-js-types/type-aliases/ZKIR.md)\>

[ZKConfigProvider.getZKIR](../../midnight-js-types/classes/ZKConfigProvider.md#getzkir)

#### Parameters

##### circuitId

`K`

#### Returns

`Promise`\<[`ZKIR`](../../midnight-js-types/type-aliases/ZKIR.md)\>

#### Overrides

[`ZKConfigProvider`](../../midnight-js-types/classes/ZKConfigProvider.md).[`getZKIR`](../../midnight-js-types/classes/ZKConfigProvider.md#getzkir)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-node-zk-config-provider/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-node-zk-config-provider

# @midnight-ntwrk/midnight-js-node-zk-config-provider

## Classes

- [NodeZkConfigProvider](classes/NodeZkConfigProvider.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/DevnetTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / DevnetTestEnvironment

# Class: DevnetTestEnvironment

Test environment configuration for the Midnight devnet network.
Provides URLs and endpoints for devnet services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new DevnetTestEnvironment**(`logger`): `DevnetTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`DevnetTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the devnet environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for devnet services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

`RemoteTestEnvironment.getEnvironmentConfiguration`

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/DynamicProofServerContainer.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / DynamicProofServerContainer

# Class: DynamicProofServerContainer

A proof server container that is started and stopped dynamically by the test
suite on random port.

## Implements

## Implements

- [`ProofServerContainer`](../interfaces/ProofServerContainer.md)

## Properties

### dockerEnv

> **dockerEnv**: `StartedDockerComposeEnvironment`

The Docker Compose environment running the container

## Methods

### getMappedPort()

> **getMappedPort**(): `number`

Gets the mapped port number for the container.

#### Returns

`number`

The mapped port number

***

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`getUrl`](../interfaces/ProofServerContainer.md#geturl)

***

### stop()

> **stop**(): `Promise`\<`void`\>

Stops the proof server container.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the container is stopped

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`stop`](../interfaces/ProofServerContainer.md#stop)

***

### start()

> `static` **start**(`logger`, `maybeUID`?, `maybeNetworkId`?): `Promise`\<`DynamicProofServerContainer`\>

Starts a new proof server container.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### maybeUID?

`string`

Optional unique identifier for the container

##### maybeNetworkId?

`string`

Optional network ID for the container

#### Returns

`Promise`\<`DynamicProofServerContainer`\>

A promise that resolves to the new container instance

#### Static
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/EnvVarRemoteTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / EnvVarRemoteTestEnvironment

# Class: EnvVarRemoteTestEnvironment

Test environment that configures services using environment variables.
Allows specifying custom endpoints through environment variables.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new EnvVarRemoteTestEnvironment**(`logger`): `EnvVarRemoteTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`EnvVarRemoteTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for environment services based on environment variables.
Required environment variables:
- MN_TEST_INDEXER: GraphQL API endpoint for the indexer
- MN_TEST_INDEXER_WS: WebSocket endpoint for the indexer
- MN_TEST_NODE: RPC endpoint for the blockchain node
Optional environment variables:
- MN_TEST_FAUCET: API endpoint for requesting test tokens

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing service URLs from environment variables

#### Throws

If any required environment variable is not set

#### Overrides

`RemoteTestEnvironment.getEnvironmentConfiguration`

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/FaucetClient.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / FaucetClient

# Class: FaucetClient

Client for interacting with the Midnight faucet service.
Provides functionality to request test tokens for wallet addresses.

## Constructors

### Constructor

> **new FaucetClient**(`faucetUrl`, `logger`): `FaucetClient`

Creates a new FaucetClient instance.

#### Parameters

##### faucetUrl

`string`

The URL of the faucet service endpoint

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`FaucetClient`

## Properties

### faucetUrl

> `readonly` **faucetUrl**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

Checks the health status of the faucet service.
Makes a GET request to the health endpoint of the faucet service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

A promise that resolves to the response of the health check or logs an error if the request fails

***

### requestTokens()

> **requestTokens**(`walletAddress`): `Promise`\<`void`\>

Requests test tokens from the faucet for a specified wallet address.
Makes a POST request to the faucet service with the wallet address.

#### Parameters

##### walletAddress

`string`

The address to receive the test tokens

#### Returns

`Promise`\<`void`\>

A promise that resolves when the request is complete

#### Throws

Will log but not throw if the request fails
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/GzipFile.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / GzipFile

# Class: GzipFile

A class for compressing and decompressing files using gzip.

## Constructors

### Constructor

> **new GzipFile**(`inputFile`, `outputFile`): `GzipFile`

Creates a new GzipFile instance.

#### Parameters

##### inputFile

`string`

The path to the input file to compress/decompress

##### outputFile

`string`

The path where the compressed file will be saved

#### Returns

`GzipFile`

## Properties

### inputFile

> **inputFile**: `string`

The path to the input file

***

### outputFile

> **outputFile**: `string`

The path to the output file

## Methods

### compress()

> **compress**(): `Promise`\<`void`\>

Compresses the input file using gzip compression.

#### Returns

`Promise`\<`void`\>

A promise that resolves when compression is complete

#### Throws

If there is an error during compression

***

### decompress()

> **decompress**(): `Promise`\<`string`\>

Decompresses the input gzip file and returns its contents as a string.

#### Returns

`Promise`\<`string`\>

A promise that resolves with the decompressed file contents as a string

#### Throws

If there is an error during decompression
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/IndexerClient.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / IndexerClient

# Class: IndexerClient

## Constructors

### Constructor

> **new IndexerClient**(`indexerUrl`, `logger`): `IndexerClient`

Creates an instance of IndexerClient.

#### Parameters

##### indexerUrl

`string`

The URL of the indexer service.

##### logger

`Logger`

The logger instance for logging information.

#### Returns

`IndexerClient`

## Properties

### indexerUrl

> `readonly` **indexerUrl**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

Checks the health status of the indexer service.
Makes a GET request to the status endpoint of the indexer service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/LocalTestConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / LocalTestConfiguration

# Class: LocalTestConfiguration

Configuration class for local test environment implementing EnvironmentConfiguration

## Implements

- [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

## Constructors

### Constructor

> **new LocalTestConfiguration**(`ports`): `LocalTestConfiguration`

Creates a new LocalTestConfiguration instance

#### Parameters

##### ports

[`ComponentPortsConfiguration`](../type-aliases/ComponentPortsConfiguration.md)

Object containing port numbers for each component

#### Returns

`LocalTestConfiguration`

## Properties

### faucet

> `readonly` **faucet**: `undefined` \| `string`

Optional URL for the faucet service to obtain test tokens

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`faucet`](../interfaces/EnvironmentConfiguration.md#faucet)

***

### indexer

> `readonly` **indexer**: `string`

URL of the indexer HTTP endpoint

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`indexer`](../interfaces/EnvironmentConfiguration.md#indexer)

***

### indexerWS

> `readonly` **indexerWS**: `string`

WebSocket URL for the indexer service

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`indexerWS`](../interfaces/EnvironmentConfiguration.md#indexerws)

***

### node

> `readonly` **node**: `string`

URL of the blockchain node

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`node`](../interfaces/EnvironmentConfiguration.md#node)

***

### proofServer

> `readonly` **proofServer**: `string`

URL of the proof generation server

#### Implementation of

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md).[`proofServer`](../interfaces/EnvironmentConfiguration.md#proofserver)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/LocalTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / LocalTestEnvironment

# Class: LocalTestEnvironment

Test environment for local development using Docker containers
Manages containers for node, indexer and proof server components

## Extends

- [`TestEnvironment`](TestEnvironment.md)

## Constructors

### Constructor

> **new LocalTestEnvironment**(`logger`): `LocalTestEnvironment`

Creates a new LocalTestEnvironment instance

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`LocalTestEnvironment`

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`constructor`](TestEnvironment.md#constructor)

## Properties

### dockerEnv

> **dockerEnv**: `StartedDockerComposeEnvironment`

***

### genesisMintWalletSeed

> `readonly` **genesisMintWalletSeed**: `string`[]

***

### MAX\_NUMBER\_OF\_WALLETS

> `readonly` `static` **MAX\_NUMBER\_OF\_WALLETS**: `4` = `4`

## Methods

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`getMidnightWalletProvider`](TestEnvironment.md#getmidnightwalletprovider)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment, closing walletProviders and stopping containers

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`shutdown`](TestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by creating and configuring Docker containers

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Throws

If trying to inject proof server container when starting new environment

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`start`](TestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

A promise that resolves to an array of started wallets

#### Throws

If requested amount exceeds maximum supported walletProviders

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`startMidnightWalletProviders`](TestEnvironment.md#startmidnightwalletproviders)

***

### startWithInjectedEnvironment()

> **startWithInjectedEnvironment**(`dockerEnv`, `ports`): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Instead of starting the test environment by building the docker containers
from the default configuration files in this package, start the test environment
by passing an existing StartedDockerComposeEnvironment along with the
ports for the containers in the environment.

#### Parameters

##### dockerEnv

`StartedDockerComposeEnvironment`

A started docker compose environment

##### ports

[`ComponentPortsConfiguration`](../type-aliases/ComponentPortsConfiguration.md)

The ports of the containers in the given environment

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/MidnightWalletProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / MidnightWalletProvider

# Class: MidnightWalletProvider

Provider class that implements wallet functionality for the Midnight network.
Handles transaction balancing, submission, and wallet state management.

## Implements

## Implements

## Implements

## Implements

- [`MidnightProvider`](../../midnight-js-types/interfaces/MidnightProvider.md)
- [`WalletProvider`](../../midnight-js-types/interfaces/WalletProvider.md)
- `Resource`

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `string`

Wallet public coin key

#### Implementation of

[`WalletProvider`](../../midnight-js-types/interfaces/WalletProvider.md).[`coinPublicKey`](../../midnight-js-types/interfaces/WalletProvider.md#coinpublickey)

***

### encryptionPublicKey

> `readonly` **encryptionPublicKey**: `string`

Wallet EncryptionPublicKey

#### Implementation of

[`WalletProvider`](../../midnight-js-types/interfaces/WalletProvider.md).[`encryptionPublicKey`](../../midnight-js-types/interfaces/WalletProvider.md#encryptionpublickey)

***

### env

> `readonly` **env**: [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

***

### logger

> **logger**: `Logger`

***

### wallet

> `readonly` **wallet**: [`MidnightWallet`](../type-aliases/MidnightWallet.md)

## Methods

### balanceTx()

> **balanceTx**(`tx`, `newCoins`): `Promise`\<[`BalancedTransaction`](../../midnight-js-types/type-aliases/BalancedTransaction.md)\>

Balances an unbalanced transaction by adding necessary inputs and change outputs.

#### Parameters

##### tx

[`UnbalancedTransaction`](../../midnight-js-types/type-aliases/UnbalancedTransaction.md)

The unbalanced transaction to balance

##### newCoins

`CoinInfo`[]

Array of new coins to include in the transaction

#### Returns

`Promise`\<[`BalancedTransaction`](../../midnight-js-types/type-aliases/BalancedTransaction.md)\>

A promise that resolves to the balanced transaction

#### Implementation of

[`WalletProvider`](../../midnight-js-types/interfaces/WalletProvider.md).[`balanceTx`](../../midnight-js-types/interfaces/WalletProvider.md#balancetx)

***

### close()

> **close**(): `Promise`\<`void`\>

Closes the wallet and releases resources.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the wallet is closed

#### Implementation of

`Resource.close`

***

### start()

> **start**(`waitForFundsInWallet`): `Promise`\<`void`\>

Starts the wallet and optionally waits for funds to be available.

#### Parameters

##### waitForFundsInWallet

`boolean` = `true`

Whether to wait for funds to be available (default: true)

#### Returns

`Promise`\<`void`\>

A promise that resolves when the wallet is started and funds are available if requested

#### Implementation of

`Resource.start`

***

### submitTx()

> **submitTx**(`tx`): `Promise`\<`string`\>

Submits a balanced transaction to the network.

#### Parameters

##### tx

[`BalancedTransaction`](../../midnight-js-types/type-aliases/BalancedTransaction.md)

The balanced transaction to submit

#### Returns

`Promise`\<`string`\>

A promise that resolves to the transaction hash

#### Implementation of

[`MidnightProvider`](../../midnight-js-types/interfaces/MidnightProvider.md).[`submitTx`](../../midnight-js-types/interfaces/MidnightProvider.md#submittx)

***

### build()

> `static` **build**(`logger`, `env`, `seed`?, `walletLogLevel`?): `Promise`\<`MidnightWalletProvider`\>

Creates a new MidnightWalletProvider instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### seed?

`string`

Optional seed for wallet generation. If not provided, a new random wallet will be created

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Optional log level for wallet operations

#### Returns

`Promise`\<`MidnightWalletProvider`\>

A promise that resolves to the new wallet provider

#### Static

***

### withWallet()

> `static` **withWallet**(`logger`, `env`, `wallet`): `Promise`\<`MidnightWalletProvider`\>

Creates a new MidnightWalletProvider instance using an existing wallet.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### wallet

[`MidnightWallet`](../type-aliases/MidnightWallet.md)

Existing wallet instance to use

#### Returns

`Promise`\<`MidnightWalletProvider`\>

A promise that resolves to the new wallet provider using the existing wallet

#### Static
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/NodeClient.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / NodeClient

# Class: NodeClient

Client for interacting with a Midnight node's JSON-RPC API

## Constructors

### Constructor

> **new NodeClient**(`nodeURL`, `logger`): `NodeClient`

Creates a new NodeClient instance

#### Parameters

##### nodeURL

`string`

URL of the Midnight node

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`NodeClient`

## Properties

### nodeURL

> `readonly` **nodeURL**: `string`

## Methods

### contractState()

> **contractState**(`contractAddress`): `Promise`\<`null` \| `ContractState`\>

Fetches the state of a contract

#### Parameters

##### contractAddress

`string`

Address of the contract

#### Returns

`Promise`\<`null` \| `ContractState`\>

Contract state or null if not found

***

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

Checks the health status of the node.
Makes a GET request to the health endpoint of the node.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.

***

### ledgerState()

> **ledgerState**(`blockHash`): `Promise`\<`LedgerState`\>

Fetches the ledger state at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`LedgerState`\>

Ledger state

***

### ledgerStateBlob()

> **ledgerStateBlob**(`blockHash`): `Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Fetches the raw ledger state blob at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`Uint8Array`\<`ArrayBufferLike`\>\>

Raw ledger state data

#### Throws

If no ledger state is found

***

### ledgerVersion()

> **ledgerVersion**(`blockHash`): `Promise`\<`string`\>

Fetches the ledger version at a given block

#### Parameters

##### blockHash

`string`

Hash of the block

#### Returns

`Promise`\<`string`\>

Ledger version

#### Throws

If no ledger version is found
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/ProofServerClient.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ProofServerClient

# Class: ProofServerClient

## Constructors

### Constructor

> **new ProofServerClient**(`proofServer`, `logger`): `ProofServerClient`

Creates an instance of ProofServerClient.

#### Parameters

##### proofServer

`string`

The URL of the proof server service.

##### logger

`Logger`

The logger instance for logging information.

#### Returns

`ProofServerClient`

## Properties

### proofServer

> `readonly` **proofServer**: `string`

## Methods

### health()

> **health**(): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

Checks the health status of the indexer service.
Makes a GET request to the status endpoint of the indexer service.

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

A promise that resolves to the response of the health check or logs an error if the request fails.

***

### proveTx()

> **proveTx**(`data`?, `config`?): `Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>

Proves a transaction by sending a POST request to the proof server.

#### Parameters

##### data?

`ArrayBuffer`

serialized transaction data

##### config?

`AxiosRequestConfig` = `...`

Axios request configuration

#### Returns

`Promise`\<`void` \| `AxiosResponse`\<`any`, `any`\>\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/QanetTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / QanetTestEnvironment

# Class: QanetTestEnvironment

Test environment configuration for the Midnight QA network.
Provides URLs and endpoints for QA network services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new QanetTestEnvironment**(`logger`): `QanetTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`QanetTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the QA network environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for QA network services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

`RemoteTestEnvironment.getEnvironmentConfiguration`

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/RemoteTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / RemoteTestEnvironment

# Class: `abstract` RemoteTestEnvironment

Base class for remote test environments that connect to external network services.
Provides functionality for managing walletProviders and a proof server container.

## Extends

- [`TestEnvironment`](TestEnvironment.md)

## Extended by

- [`QanetTestEnvironment`](QanetTestEnvironment.md)
- [`DevnetTestEnvironment`](DevnetTestEnvironment.md)
- [`TestnetTestEnvironment`](TestnetTestEnvironment.md)
- [`Testnet2TestEnvironment`](Testnet2TestEnvironment.md)
- [`EnvVarRemoteTestEnvironment`](EnvVarRemoteTestEnvironment.md)

## Constructors

### Constructor

> **new RemoteTestEnvironment**(`logger`): `RemoteTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`RemoteTestEnvironment`

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`constructor`](TestEnvironment.md#constructor)

## Methods

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`TestEnvironment`](TestEnvironment.md).[`getMidnightWalletProvider`](TestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`shutdown`](TestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`start`](TestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Overrides

[`TestEnvironment`](TestEnvironment.md).[`startMidnightWalletProviders`](TestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/StaticProofServerContainer.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / StaticProofServerContainer

# Class: StaticProofServerContainer

A proof server that is currently running on a specific port.
Used for connecting to an existing proof server instance.

## Implements

## Implements

- [`ProofServerContainer`](../interfaces/ProofServerContainer.md)

## Constructors

### Constructor

> **new StaticProofServerContainer**(`port`): `StaticProofServerContainer`

Creates a new StaticProofServerContainer instance.

#### Parameters

##### port

`number` = `6300`

The port number where the proof server is running (default: 6300)

#### Returns

`StaticProofServerContainer`

## Properties

### port

> **port**: `number`

The port number where the proof server is running

## Methods

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`getUrl`](../interfaces/ProofServerContainer.md#geturl)

***

### stop()

> **stop**(): `Promise`\<`void`\>

No-op stop method since this represents an external proof server.

#### Returns

`Promise`\<`void`\>

A resolved promise

#### Implementation of

[`ProofServerContainer`](../interfaces/ProofServerContainer.md).[`stop`](../interfaces/ProofServerContainer.md#stop)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/TestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / TestEnvironment

# Class: `abstract` TestEnvironment

Abstract base class for test environments.
Provides common functionality for managing test wallets and environments.

## Extended by

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)
- [`LocalTestEnvironment`](LocalTestEnvironment.md)

## Constructors

### Constructor

> **new TestEnvironment**(`logger`): `TestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`TestEnvironment`

## Methods

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

***

### shutdown()

> `abstract` **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment and cleans up resources.

#### Parameters

##### saveWalletState?

`boolean`

Optional flag to save the wallet state before shutdown

#### Returns

`Promise`\<`void`\>

A promise that resolves when shutdown is complete

***

### start()

> `abstract` **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Start the test environment.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

If defined, a container representing an already
                                 running proof server. If undefined, a proof server
                                 will be started automatically.

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

A promise that resolves to the environment configuration

***

### startMidnightWalletProviders()

> `abstract` **startMidnightWalletProviders**(`amount`?, `seeds`?): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Starts multiple wallet instances.

#### Parameters

##### amount?

`number`

Optional number of wallet instances to start

##### seeds?

`string`[]

Optional array of seeds for the wallets

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

A promise that resolves to an array of started wallets
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/Testnet2TestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / Testnet2TestEnvironment

# Class: Testnet2TestEnvironment

Test environment configuration for the Midnight testnet network.
Provides URLs and endpoints for testnet services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new Testnet2TestEnvironment**(`logger`): `Testnet2TestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`Testnet2TestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the testnet environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for testnet services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

`RemoteTestEnvironment.getEnvironmentConfiguration`

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/TestnetTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / TestnetTestEnvironment

# Class: TestnetTestEnvironment

Test environment configuration for the Midnight testnet network.
Provides URLs and endpoints for testnet services.

## Extends

- [`RemoteTestEnvironment`](RemoteTestEnvironment.md)

## Constructors

### Constructor

> **new TestnetTestEnvironment**(`logger`): `TestnetTestEnvironment`

Creates a new TestEnvironment instance.

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

#### Returns

`TestnetTestEnvironment`

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`constructor`](RemoteTestEnvironment.md#constructor)

## Methods

### getEnvironmentConfiguration()

> **getEnvironmentConfiguration**(): [`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Returns the configuration for the testnet environment services.

#### Returns

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Object containing URLs for testnet services:
- indexer: GraphQL API endpoint for the indexer
- indexerWS: WebSocket endpoint for the indexer
- node: RPC endpoint for the blockchain node
- faucet: API endpoint for requesting test tokens
- proofServer: URL for the proof generation server

#### Overrides

`RemoteTestEnvironment.getEnvironmentConfiguration`

***

### getMidnightWalletProvider()

> **getMidnightWalletProvider**(): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

Starts a single wallet instance.

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)\>

A promise that resolves to the started wallet

#### Throws

If no wallet could be started

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`getMidnightWalletProvider`](RemoteTestEnvironment.md#getmidnightwalletprovider)

***

### healthCheck()

> **healthCheck**(): `Promise`\<`void`\>

Performs a health check for the environment.
Checks the health of the node, indexer, and optionally the faucet services.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the health check is complete.

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`healthCheck`](RemoteTestEnvironment.md#healthcheck)

***

### shutdown()

> **shutdown**(`saveWalletState`?): `Promise`\<`void`\>

Shuts down the test environment by closing all walletProviders and stopping the proof server.

#### Parameters

##### saveWalletState?

`boolean`

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`shutdown`](RemoteTestEnvironment.md#shutdown)

***

### start()

> **start**(`maybeProofServerContainer`?): `Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

Starts the test environment by initializing the proof server and environment configuration.

#### Parameters

##### maybeProofServerContainer?

[`ProofServerContainer`](../interfaces/ProofServerContainer.md)

Optional proof server container to use instead of creating a new one

#### Returns

`Promise`\<[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)\>

The environment configuration

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`start`](RemoteTestEnvironment.md#start)

***

### startMidnightWalletProviders()

> **startMidnightWalletProviders**(`amount`, `seeds`): `Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Creates and starts the specified number of wallet providers.

#### Parameters

##### amount

`number` = `1`

##### seeds

`undefined` | `string`[]

#### Returns

`Promise`\<[`MidnightWalletProvider`](MidnightWalletProvider.md)[]\>

Array of started wallet providers

#### Inherited from

[`RemoteTestEnvironment`](RemoteTestEnvironment.md).[`startMidnightWalletProviders`](RemoteTestEnvironment.md#startmidnightwalletproviders)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/WalletFactory.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / WalletFactory

# Class: WalletFactory

## Constructors

### Constructor

> **new WalletFactory**(): `WalletFactory`

#### Returns

`WalletFactory`

## Methods

### build()

> `static` **build**(`env`, `walletLogLevel`?): `Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

Builds a wallet instance based on the provided environment configuration.

#### Parameters

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Optional log level for wallet operations

#### Returns

`Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

A promise that resolves to the new wallet instance

***

### buildFromEnvContext()

> `static` **buildFromEnvContext**(`env`, `seed`?, `walletLogLevel`?): `Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

Builds a wallet instance based on the provided environment configuration and optional seed.

#### Parameters

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### seed?

`string`

Optional seed for wallet generation. If not provided, a new random wallet will be created

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Optional log level for wallet operations

#### Returns

`Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

A promise that resolves to the new wallet instance

***

### buildFromSeed()

> `static` **buildFromSeed**(`env`, `seed`, `walletLogLevel`?): `Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

Builds a wallet instance from a seed based on the provided environment configuration.

#### Parameters

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### seed

`string`

Seed for wallet generation

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Optional log level for wallet operations

#### Returns

`Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

A promise that resolves to the new wallet instance

***

### buildFromSeedAndTryToRestoreState()

> `static` **buildFromSeedAndTryToRestoreState**(`env`, `seed`, `directoryPath`?, `filename`?, `walletLogLevel`?): `Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

Builds a wallet from a seed and attempts to restore its state from a saved file if available.

#### Parameters

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration containing indexer, node, and proof server details

##### seed

`string`

The seed to build the wallet from

##### directoryPath?

`string` = `DEFAULT_WALLET_STATE_DIRECTORY`

Directory path for wallet state file

##### filename?

`string` = `...`

Filename for wallet state file

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Log level for wallet operations

#### Returns

`Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

The built and initialized wallet

***

### restore()

> `static` **restore**(`env`, `serialized`, `seed`, `trimTxHistory`?, `walletLogLevel`?): `Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

Restores a wallet instance from a serialized state based on the provided environment configuration.

#### Parameters

##### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the wallet environment

##### serialized

`string`

Serialized wallet state

##### seed

`string`

##### trimTxHistory?

`boolean` = `true`

Optional flag to trim the transaction history during restoration

##### walletLogLevel?

`LogLevel` = `DEFAULT_WALLET_LOG_LEVEL`

Optional log level for wallet operations

#### Returns

`Promise`\<[`MidnightWallet`](../type-aliases/MidnightWallet.md)\>

A promise that resolves to the restored wallet instance
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/classes/WalletSaveStateProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / WalletSaveStateProvider

# Class: WalletSaveStateProvider

Provider class for saving and loading wallet state to/from compressed files

## Constructors

### Constructor

> **new WalletSaveStateProvider**(`logger`, `seed`, `directoryPath`?, `filename`?): `WalletSaveStateProvider`

Creates a new WalletSaveStateProvider instance

#### Parameters

##### logger

`Logger`

Logger instance for recording operations

##### seed

`string`

##### directoryPath?

`string` = `DEFAULT_WALLET_STATE_DIRECTORY`

Directory path for wallet state files

##### filename?

`string` = `...`

Filename for the wallet state file

#### Returns

`WalletSaveStateProvider`

## Properties

### directoryPath

> **directoryPath**: `string`

Absolute path to the directory containing wallet state files

***

### filePath

> **filePath**: `string`

Full path including filename for the wallet state file

***

### logger

> **logger**: `Logger`

Logger instance for recording operations

## Methods

### load()

> **load**(): `Promise`\<`string`\>

Loads and decompresses the wallet state from a file

#### Returns

`Promise`\<`string`\>

A promise that resolves with the decompressed wallet state as a string

#### Throws

If there is an error reading or decompressing the file

***

### save()

> **save**(`wallet`): `Promise`\<`void`\>

Saves the wallet state to a compressed file

#### Parameters

##### wallet

`Wallet`

The wallet instance to save state from

#### Returns

`Promise`\<`void`\>

A promise that resolves when the save is complete
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/createDefaultTestLogger.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / createDefaultTestLogger

# Function: createDefaultTestLogger()

> **createDefaultTestLogger**(): `Logger`\<`never`, `boolean`\>

## Returns

`Logger`\<`never`, `boolean`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/createLogger.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / createLogger

# Function: createLogger()

> **createLogger**(`fileName`, `dir`): `Logger`\<`never`, `boolean`\>

## Parameters

### fileName

`string`

### dir

`string` = `...`

## Returns

`Logger`\<`never`, `boolean`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/createOutputs.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / createOutputs

# Function: createOutputs()

> **createOutputs**(`address`, `amount`): [`TxOutput`](../type-aliases/TxOutput.md)[]

Creates transaction outputs for a given address and amount.

## Parameters

### address

`string`

The receiver's address

### amount

`bigint`

The amount to send

## Returns

[`TxOutput`](../type-aliases/TxOutput.md)[]

Array of transaction outputs
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/delay.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / delay

# Function: delay()

> **delay**(`ms`): `Promise`\<`unknown`\>

Creates a Promise that resolves after a specified delay.

## Parameters

### ms

`number`

The delay duration in milliseconds.

## Returns

`Promise`\<`unknown`\>

A Promise that resolves after the specified delay.

## Example

```ts
// Wait for 1 second
await delay(1000);
```
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectFoundAndDeployedStatesEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectFoundAndDeployedStatesEqual

# Function: expectFoundAndDeployedStatesEqual()

> **expectFoundAndDeployedStatesEqual**\<`C`\>(`providers`, `deployTxData`, `foundDeployTxData`, `privateStateId`?, `initialPrivateState`?): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### providers

[`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<[`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `string`, `unknown`\>

### deployTxData

[`FinalizedDeployTxData`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxData.md)\<`C`\>

### foundDeployTxData

[`FinalizedDeployTxDataBase`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md)\<`C`\>

### privateStateId?

`string`

### initialPrivateState?

[`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

## Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectFoundAndDeployedTxDataEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectFoundAndDeployedTxDataEqual

# Function: expectFoundAndDeployedTxDataEqual()

> **expectFoundAndDeployedTxDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### deployTxData

[`FinalizedDeployTxData`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxData.md)\<`C`\>

### foundDeployTxData

[`FinalizedDeployTxDataBase`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md)\<`C`\>

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectFoundAndDeployedTxPrivateDataEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectFoundAndDeployedTxPrivateDataEqual

# Function: expectFoundAndDeployedTxPrivateDataEqual()

> **expectFoundAndDeployedTxPrivateDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### deployTxData

[`FinalizedDeployTxData`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxData.md)\<`C`\>

### foundDeployTxData

[`FinalizedDeployTxDataBase`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md)\<`C`\>

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectFoundAndDeployedTxPublicDataEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectFoundAndDeployedTxPublicDataEqual

# Function: expectFoundAndDeployedTxPublicDataEqual()

> **expectFoundAndDeployedTxPublicDataEqual**\<`C`\>(`deployTxData`, `foundDeployTxData`): `void`

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### deployTxData

[`FinalizedDeployTxData`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxData.md)\<`C`\>

### foundDeployTxData

[`FinalizedDeployTxDataBase`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxDataBase.md)\<`C`\>

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectStatesEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectStatesEqual

# Function: expectStatesEqual()

> **expectStatesEqual**(`state1`, `state2`): `void`

Compares two wallet states for equality after normalization.

## Parameters

### state1

`WalletState`

First wallet state to compare

### state2

`WalletState`

Second wallet state to compare

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectSuccessfulCallTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectSuccessfulCallTx

# Function: expectSuccessfulCallTx()

> **expectSuccessfulCallTx**\<`C`, `ICK`\>(`providers`, `callTxData`, `callTxOptions`?, `nextPrivateState`?): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

### ICK

`ICK` *extends* `string`

## Parameters

### providers

[`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<[`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `string`, `unknown`\>

### callTxData

[`FinalizedCallTxData`](../../midnight-js-contracts/type-aliases/FinalizedCallTxData.md)\<`C`, `ICK`\>

### callTxOptions?

[`CallTxOptions`](../../midnight-js-contracts/type-aliases/CallTxOptions.md)\<`C`, `ICK`\>

### nextPrivateState?

[`PrivateState`](../../midnight-js-types/type-aliases/PrivateState.md)\<`C`\>

## Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectSuccessfulDeployTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectSuccessfulDeployTx

# Function: expectSuccessfulDeployTx()

> **expectSuccessfulDeployTx**\<`C`\>(`providers`, `deployTxData`, `deployTxOptions`?): `Promise`\<`void`\>

## Type Parameters

### C

`C` *extends* [`Contract`](../../midnight-js-types/interfaces/Contract.md)\<`any`, [`Witnesses`](../../midnight-js-types/type-aliases/Witnesses.md)\<`any`\>\>

## Parameters

### providers

[`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<[`ImpureCircuitId`](../../midnight-js-types/type-aliases/ImpureCircuitId.md)\<`C`\>, `string`, `unknown`\>

### deployTxData

[`FinalizedDeployTxData`](../../midnight-js-contracts/type-aliases/FinalizedDeployTxData.md)\<`C`\>

### deployTxOptions?

[`DeployContractOptions`](../../midnight-js-contracts/type-aliases/DeployContractOptions.md)\<`C`\> | [`DeployTxOptions`](../../midnight-js-contracts/type-aliases/DeployTxOptions.md)\<`C`\>

## Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/expectSuccessfulTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / expectSuccessfulTxData

# Function: expectSuccessfulTxData()

> **expectSuccessfulTxData**(`finalizedTxData`): `void`

## Parameters

### finalizedTxData

[`FinalizedTxData`](../../midnight-js-types/interfaces/FinalizedTxData.md)

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/extractHostnameAndPort.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / extractHostnameAndPort

# Function: extractHostnameAndPort()

> **extractHostnameAndPort**(`url`): `string`

## Parameters

### url

`string`

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/getContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / getContainersConfiguration

# Function: getContainersConfiguration()

> **getContainersConfiguration**(): [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

## Returns

[`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/getInitialState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / getInitialState

# Function: getInitialState()

> **getInitialState**(`wallet`): `Promise`\<`WalletState`\>

Gets the initial state of a wallet.

## Parameters

### wallet

`Wallet`

The wallet to get the state from

## Returns

`Promise`\<`WalletState`\>

The initial wallet state
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/getTestEnvironment.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / getTestEnvironment

# Function: getTestEnvironment()

> **getTestEnvironment**(`logger`): [`LocalTestEnvironment`](../classes/LocalTestEnvironment.md) \| [`QanetTestEnvironment`](../classes/QanetTestEnvironment.md) \| [`DevnetTestEnvironment`](../classes/DevnetTestEnvironment.md) \| [`TestnetTestEnvironment`](../classes/TestnetTestEnvironment.md) \| [`Testnet2TestEnvironment`](../classes/Testnet2TestEnvironment.md) \| [`EnvVarRemoteTestEnvironment`](../classes/EnvVarRemoteTestEnvironment.md)

Returns the appropriate test environment based on the MN_TEST_ENVIRONMENT variable.

## Parameters

### logger

`Logger`

The logger instance to be used by the test environment.

## Returns

[`LocalTestEnvironment`](../classes/LocalTestEnvironment.md) \| [`QanetTestEnvironment`](../classes/QanetTestEnvironment.md) \| [`DevnetTestEnvironment`](../classes/DevnetTestEnvironment.md) \| [`TestnetTestEnvironment`](../classes/TestnetTestEnvironment.md) \| [`Testnet2TestEnvironment`](../classes/Testnet2TestEnvironment.md) \| [`EnvVarRemoteTestEnvironment`](../classes/EnvVarRemoteTestEnvironment.md)

The selected test environment instance.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/getWalletStateFilename.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / getWalletStateFilename

# Function: getWalletStateFilename()

> **getWalletStateFilename**(`seed`): `string`

Generates a filename for the wallet state file based on environment and optional seed

## Parameters

### seed

`undefined` | `string`

## Returns

`string`

Generated filename for the wallet state
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/initializeMidnightProviders.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / initializeMidnightProviders

# Function: initializeMidnightProviders()

> **initializeMidnightProviders**\<`ICK`, `PS`\>(`midnightWalletProvider`, `environmentConfiguration`, `contractConfiguration`): [`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<`ICK`, `string`, `PS`\>

Configures and returns the required providers for a Midnight contract.

## Type Parameters

### ICK

`ICK` *extends* `string`

Type parameter for the input circuit key string

### PS

`PS`

Type parameter for the private state

## Parameters

### midnightWalletProvider

[`MidnightWalletProvider`](../classes/MidnightWalletProvider.md)

The midnightWalletProvider provider instance to use for transactions

### environmentConfiguration

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Configuration for the environment including indexer and proof server details

### contractConfiguration

[`ContractConfiguration`](../interfaces/ContractConfiguration.md)

Configuration specific to the contract including storage names and ZK config path

## Returns

[`MidnightProviders`](../../midnight-js-types/interfaces/MidnightProviders.md)\<`ICK`, `string`, `PS`\>

An object containing all configured providers:
  - privateStateProvider: For managing private contract state
  - publicDataProvider: For accessing public blockchain data
  - zkConfigProvider: For zero-knowledge proof configurations
  - proofProvider: For generating and verifying proofs
  - walletProvider: For midnightWalletProvider operations
  - midnightProvider: For Midnight-specific operations
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/inMemoryPrivateStateProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / inMemoryPrivateStateProvider

# Function: inMemoryPrivateStateProvider()

> **inMemoryPrivateStateProvider**\<`PSI`, `PS`\>(): [`PrivateStateProvider`](../../midnight-js-types/interfaces/PrivateStateProvider.md)\<`PSI`, `PS`\>

A simple in-memory implementation of private state provider. Makes it easy to capture and rewrite private state from deploy.

## Type Parameters

### PSI

`PSI` *extends* `string`

Type of the private state identifier.

### PS

`PS` *extends* `unknown`

Type of the private state.

## Returns

[`PrivateStateProvider`](../../midnight-js-types/interfaces/PrivateStateProvider.md)\<`PSI`, `PS`\>

An in-memory private state provider.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/normalizeWalletState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / normalizeWalletState

# Function: normalizeWalletState()

> **normalizeWalletState**(`state`): `object`

Normalizes a wallet state by removing transaction details and sync progress.

## Parameters

### state

`WalletState`

The wallet state to normalize

## Returns

`object`

Normalized wallet state
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/sendTransactionToAddress.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / sendTransactionToAddress

# Function: sendTransactionToAddress()

> **sendTransactionToAddress**(`walletWithFunds`, `address`, `outputValue`?): `Promise`\<`void`\>

Sends a transaction to a specific address.

## Parameters

### walletWithFunds

[`MidnightWallet`](../type-aliases/MidnightWallet.md)

The wallet to send funds from

### address

`string`

The recipient's address

### outputValue?

`bigint` = `100_000_000n`

The amount to send

## Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/sendTransactionToWallet.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / sendTransactionToWallet

# Function: sendTransactionToWallet()

> **sendTransactionToWallet**(`walletWithFunds`, `destination`): `Promise`\<`void`\>

Sends a transaction from one wallet to another.

## Parameters

### walletWithFunds

[`MidnightWallet`](../type-aliases/MidnightWallet.md)

The wallet to send funds from

### destination

[`MidnightWallet`](../type-aliases/MidnightWallet.md)

The destination wallet

## Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/setContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / setContainersConfiguration

# Function: setContainersConfiguration()

> **setContainersConfiguration**(`containersConfig`): `void`

## Parameters

### containersConfig

[`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)

## Returns

`void`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/stateValueEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / stateValueEqual

# Function: stateValueEqual()

> **stateValueEqual**(`a`, `b`): `boolean`

## Parameters

### a

`StateValue`

### b

`StateValue`

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/syncWallet.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / syncWallet

# Function: syncWallet()

> **syncWallet**(`wallet`, `throttleTime`?): `Promise`\<`bigint`\>

Synchronizes the wallet with the network and waits for a non-zero balance.

## Parameters

### wallet

`Wallet`

The wallet to synchronize

### throttleTime?

`number` = `3_000`

Throttle time in milliseconds

## Returns

`Promise`\<`bigint`\>

A promise that resolves to the wallet balance when sync is close enough and balance is non-zero
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/txsEqual.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / txsEqual

# Function: txsEqual()

> **txsEqual**(`a`, `b`): `boolean`

## Parameters

### a

`Transaction`

### b

`Transaction`

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForFinalizedBalance.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForFinalizedBalance

# Function: waitForFinalizedBalance()

> **waitForFinalizedBalance**(`wallet`, `throttleTime`?): `Promise`\<`WalletState`\>

Waits for all pending coins to be finalized.

## Parameters

### wallet

`Wallet`

The wallet to check for finalized balance

### throttleTime?

`number` = `5_000`

Throttle time in milliseconds

## Returns

`Promise`\<`WalletState`\>

The wallet state with no pending coins
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForFullSync.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForFullSync

# Function: waitForFullSync()

> **waitForFullSync**(`wallet`, `throttleTime`?): `Promise`\<`WalletState`\>

Waits for the wallet to fully synchronize with the network.

## Parameters

### wallet

`Wallet`

The wallet to wait for

### throttleTime?

`number` = `3_000`

Throttle time in milliseconds

## Returns

`Promise`\<`WalletState`\>

The synchronized wallet state
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForFunds.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForFunds

# Function: waitForFunds()

> **waitForFunds**(`wallet`, `env`, `fundFromFaucet`?): `Promise`\<`bigint`\>

Waits for funds to be available in the wallet.
If a faucet is configured, requests tokens from it.

## Parameters

### wallet

[`MidnightWallet`](../type-aliases/MidnightWallet.md)

The wallet to check for funds

### env

[`EnvironmentConfiguration`](../interfaces/EnvironmentConfiguration.md)

Environment configuration containing faucet details

### fundFromFaucet?

`boolean` = `false`

Whether to request tokens from the faucet

## Returns

`Promise`\<`bigint`\>

A promise that resolves to the wallet balance
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForPending.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForPending

# Function: waitForPending()

> **waitForPending**(`wallet`, `throttleTime`?): `Promise`\<`WalletState`\>

Waits for the wallet to have pending coins.

## Parameters

### wallet

`Wallet`

The wallet to check for pending coins

### throttleTime?

`number` = `1_000`

Throttle time in milliseconds

## Returns

`Promise`\<`WalletState`\>

The wallet state with pending coins
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForSyncProgressDefined.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForSyncProgressDefined

# Function: waitForSyncProgressDefined()

> **waitForSyncProgressDefined**(`wallet`, `throttleTime`?): `Promise`\<`WalletState`\>

Waits for the wallet's sync progress to be defined.

## Parameters

### wallet

`Wallet`

The wallet to wait for

### throttleTime?

`number` = `3_000`

Throttle time in milliseconds

## Returns

`Promise`\<`WalletState`\>

The wallet state with defined sync progress
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/waitForTxInHistory.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / waitForTxInHistory

# Function: waitForTxInHistory()

> **waitForTxInHistory**(`txId`, `wallet`, `delayTime`?): `Promise`\<`void`\>

Waits for a specific transaction ID to appear in the wallet's transaction history.

## Parameters

### txId

`string`

The transaction ID to wait for

### wallet

`Wallet`

The wallet to check

### delayTime?

`number` = `1_000`

Delay time in milliseconds

## Returns

`Promise`\<`void`\>

Resolves when the transaction is found in history
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/functions/walletStateWithoutHistoryAndCoins.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / walletStateWithoutHistoryAndCoins

# Function: walletStateWithoutHistoryAndCoins()

> **walletStateWithoutHistoryAndCoins**(`state`): `Partial`\<`WalletState`\>

Returns a wallet state object without transaction history and coin data.

## Parameters

### state

`WalletState`

The wallet state to filter

## Returns

`Partial`\<`WalletState`\>

Filtered wallet state
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/ContainerEndpoints.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ContainerEndpoints

# Interface: ContainerEndpoints

Network endpoint configuration for a container

## Properties

### name

> **name**: `string`

Name of the container

***

### port

> **port**: `number`

Port number the container listens on

***

### waitStrategy

> **waitStrategy**: `WaitStrategy`

TestContainers WaitStrategy to use for container start
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/ContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ContainersConfiguration

# Interface: ContainersConfiguration

Top-level configuration for all test containers

## Properties

### log

> **log**: [`LogConfiguration`](LogConfiguration.md)

Logging configuration

***

### proofServer

> **proofServer**: [`ProofServerContainerConfiguration`](ProofServerContainerConfiguration.md)

Proof server container configuration

***

### standalone

> **standalone**: [`StandaloneContainersConfiguration`](StandaloneContainersConfiguration.md)

Standalone mode containers configuration
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/ContractConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ContractConfiguration

# Interface: ContractConfiguration

Configuration interface for Midnight contracts.

## Properties

### privateStateStoreName

> `readonly` **privateStateStoreName**: `string`

Name of the store used for persisting private state data.
This is used as a base name - a signing key store will also be created with "-signing-keys" appended.

***

### zkConfigPath

> `readonly` **zkConfigPath**: `string`

File system path to the zero-knowledge proof configuration files.
This should point to the directory containing the circuit verification keys and other ZK artifacts.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/EnvironmentConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / EnvironmentConfiguration

# Interface: EnvironmentConfiguration

Configuration interface for the test environment services

## Properties

### faucet

> `readonly` **faucet**: `undefined` \| `string`

Optional URL for the faucet service to obtain test tokens

***

### indexer

> `readonly` **indexer**: `string`

URL of the indexer HTTP endpoint

***

### indexerWS

> `readonly` **indexerWS**: `string`

WebSocket URL for the indexer service

***

### node

> `readonly` **node**: `string`

URL of the blockchain node

***

### proofServer

> `readonly` **proofServer**: `string`

URL of the proof generation server
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/LogConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / LogConfiguration

# Interface: LogConfiguration

Configuration for test logging

## Properties

### fileName

> **fileName**: `string`

Name of the log file

***

### level

> **level**: `string`

Log level (e.g. 'info', 'debug', etc)

***

### path

> **path**: `string`

Directory path where log files will be written
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/ProofServerContainer.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ProofServerContainer

# Interface: ProofServerContainer

Interface representing a proof server container that can be started and stopped.

## Methods

### getUrl()

> **getUrl**(): `string`

Gets the URL where the proof server can be accessed.

#### Returns

`string`

The URL of the proof server

***

### stop()

> **stop**(): `Promise`\<`void`\>

Stops the proof server container.

#### Returns

`Promise`\<`void`\>

A promise that resolves when the container is stopped
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/ProofServerContainerConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ProofServerContainerConfiguration

# Interface: ProofServerContainerConfiguration

Configuration for a proof server container instance

## Properties

### container

> **container**: [`ContainerEndpoints`](ContainerEndpoints.md)

Network endpoint configuration for the container

***

### fileName

> **fileName**: `string`

Name of the container configuration file

***

### path

> **path**: `string`

Directory path where container configuration is located
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/StandaloneContainerNames.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / StandaloneContainerNames

# Interface: StandaloneContainerNames

Container endpoint configurations for standalone mode services

## Properties

### indexer

> **indexer**: [`ContainerEndpoints`](ContainerEndpoints.md)

Indexer service container configuration

***

### node

> **node**: [`ContainerEndpoints`](ContainerEndpoints.md)

Blockchain node container configuration

***

### proofServer

> **proofServer**: [`ContainerEndpoints`](ContainerEndpoints.md)

Proof server container configuration
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/interfaces/StandaloneContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / StandaloneContainersConfiguration

# Interface: StandaloneContainersConfiguration

Configuration for standalone mode containers

## Properties

### container

> **container**: [`StandaloneContainerNames`](StandaloneContainerNames.md)

Container endpoint configurations

***

### fileName

> **fileName**: `string`

Name of the container configuration file

***

### path

> **path**: `string`

Directory path where container configuration is located
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/type-aliases/ComponentPortsConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / ComponentPortsConfiguration

# Type Alias: ComponentPortsConfiguration

> **ComponentPortsConfiguration** = `object`

Configuration for component ports in the local test environment

## Properties

### indexer

> **indexer**: `number`

***

### node

> **node**: `number`

***

### proofServer

> **proofServer**: `number`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/type-aliases/MidnightWallet.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / MidnightWallet

# Type Alias: MidnightWallet

> **MidnightWallet** = `Wallet` & `Resource`

Represents a wallet that inherits from both Wallet and Resource.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/type-aliases/SerializedWalletState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / SerializedWalletState

# Type Alias: SerializedWalletState

> **SerializedWalletState** = `object`

Represents the serialized state of a wallet that can be saved to and loaded from storage.

## Properties

### networkId

> **networkId**: `string`

Identifier for the network this wallet state belongs to

***

### offset

> **offset**: `number`

The block height/offset up to which the wallet has been synced

***

### protocolVersion

> **protocolVersion**: `string`

Version of the protocol being used

***

### state

> **state**: `string`

Serialized wallet state data

***

### txHistory

> **txHistory**: `string`[]

Array of serialized transaction history entries
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/type-aliases/TxOutput.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / TxOutput

# Type Alias: TxOutput

> **TxOutput** = `object`

Represents a transaction output with token type, amount and receiver details.

## Properties

### amount

> **amount**: `bigint`

The amount of tokens to transfer

***

### receiverAddress

> **receiverAddress**: `string`

The address of the recipient who will receive the tokens

***

### type

> **type**: `string`

The type/identifier of the token being transferred
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/DEFAULT_WALLET_LOG_LEVEL.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / DEFAULT\_WALLET\_LOG\_LEVEL

# Variable: DEFAULT\_WALLET\_LOG\_LEVEL

> `const` **DEFAULT\_WALLET\_LOG\_LEVEL**: `LogLevel` = `'info'`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/DEFAULT_WALLET_STATE_DIRECTORY.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / DEFAULT\_WALLET\_STATE\_DIRECTORY

# Variable: DEFAULT\_WALLET\_STATE\_DIRECTORY

> `const` **DEFAULT\_WALLET\_STATE\_DIRECTORY**: `"./.states"`

Default directory path for storing wallet state files
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/defaultContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / defaultContainersConfiguration

# Variable: defaultContainersConfiguration

> `const` **defaultContainersConfiguration**: [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/latestContainersConfiguration.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / latestContainersConfiguration

# Variable: latestContainersConfiguration

> `const` **latestContainersConfiguration**: [`ContainersConfiguration`](../interfaces/ContainersConfiguration.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/logger.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / logger

# Variable: logger

> `const` **logger**: `Logger`\<`never`, `boolean`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/variables/MINUTE.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-testing](../README.md) / MINUTE

# Variable: MINUTE

> `const` **MINUTE**: `60000` = `60_000`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-testing/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-testing

# What is this?
A comprehensive testing solution for your Midnight.JS applications, providing seamless integration with various test environments.

This package was created for the [Midnight network](https://midnight.network). 

Please visit the [Midnight Developer Hub](https://midnight.network/developer-hub) to learn more.

# Use only in Midnight test environments
Image exclusively for Midnight test environments use.  

# Agree to Terms
By downloading and using this image, you agree to [Midnight’s Terms and Conditions](https://midnight.network/static/terms.pdf), which includes the [Privacy Policy](https://midnight.network/static/privacy-policy.pdf).

# License
The software provided herein is licensed under the [Apache License V2.0](http://www.apache.org/licenses/LICENSE-2.0).

## Table of Contents
1. [Installation](#installation)
2. [Getting Started](#getting-started)
3. [Features](#Features)
4. [Limitations](#Limitations)
5. [Examples of Usage](#Examples-of-Usage)

---

## Installation
Before using the testing library, ensure you have the following prerequisites:
1. Node.js and yarn installed
2. Docker Desktop (optional for local dockerized tests)
3. Midnight.JS project set up

Install the testing library by running the following command in your terminal:
```
yarn add -D @midnight-ntwrk/midnight-js-testing
```

## Getting Started
To use the testing library, create a new file called `midnight.test.js` in the `__tests__` directory of your project. In this file, import the necessary dependencies:
```typescript
import { getTestEnvironment } from '@midnight-ntwrk/midnight-js-testing';

beforeAll(async () => {
  testEnvironment = getTestEnvironment(logger);
  environmentConfiguration = await testEnvironment.start();
  walletProvider = await testEnvironment.getMidnightWalletProvider();
});

afterAll(async () => {
  await testEnvironment.shutdown();
});
```

---

## Features

Set of functions that simplify testing of DApps in Midnight

- [x] Standard Dockerized environment setup - both live and local
- [x] Predefined Midnight environments configuration 
- [x] Proof server control
- [x] Wallets management
- [x] Fund wallets
- [x] Check system health

---

## Environment variables

### Environment selection:
- MN_TEST_ENVIRONMENT controls the environment to be used for testing. It can take one of these values:
   - undeployed
   - devnet
   - testnet
   - env-var-remote

If **MN_TEST_ENVIRONMENT** is not set, the default value will be `undeployed`.
If **MN_TEST_ENVIRONMENT** is set to `undeployed`, the testing environment will be deployed locally using Docker.
If **MN_TEST_ENVIRONMENT** is set to `devnet`,`testnet, env-var-remote` the testing environment will the corresponding live network, with proof server setup using predefined NETWORK_ID.
If **MN_TEST_ENVIRONMENT** is set to `env-var-remote`, below environment variables must be set:
  - *MN_TEST_NETWORK_ID* - Proof server NETWORK_ID
  - *MN_TEST_INDEXER* - Indexer URL
  - *MN_TEST_INDEXER_WS* - Indexer WebSocket URL
  - *MN_TEST_NODE* - Node URL
  - *MN_TEST_FAUCET* - Faucet URL

### Wallet setup:
- MN_TEST_WALLET_SEED can be used to set a specific seed phrase for the wallet. If not set, a random seed phrase will be used.

---

## Limitations

- Localnet wallets limit count is 4

---

## Examples of Usage

### 1. Selecting Different Environments

You can control the test environment using the `MN_TEST_ENVIRONMENT` environment variable. Here's how you can set it:

```typescript
const testEnvironment = getTestEnvironment(logger);
environmentConfiguration = await testEnvironment.start();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_ENVIRONMENT='devnet'; yarn test
```

This allows you to easily switch between predefined environments like `devnet`, `testnet`, and others.
Default (undefined) value is `undeployed` which will deploy the testing environment locally using Docker.

---

### 2. Creating and Managing Wallets

Here's an example of creating wallets in your test environment:

```typescript
// Example: Create multiple wallets in a test environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

// Create 2 wallets
const wallets = await testEnvironment.startMidnightWalletProviders(2);

// Verify wallet properties
expect(wallets).toHaveLength(2);
wallets.forEach(async (wallet) => {
  expect(wallet.coinPublicKey).not.toBeUndefined();
});

// Shutdown the environment after testing
await testEnvironment.shutdown();
```

This demonstrates how to create wallets and verify their properties, such as the `coinPublicKey`.

---

### 3. Setting Wallet Seeds

If you need to use specific wallet seeds for testing, you can do the following:

```typescript
// Example: Create a wallet with a predefined seed phrase
const wallet = await testEnvironment.getMidnightWalletProvider();

expect(wallet.coinPublicKey).not.toBeUndefined();
```

```shell
# Example: Set the environment variable before initializing the test environment
MN_TEST_WALLET_SEED='00000000000000000000000000000042'; yarn test
```

This allows you to test specific scenarios using known wallet seeds.

---

### 4. Handling Environment Configuration

You can also customize the test environment configuration by modifying the `defaultContainersConfiguration` object:

```typescript
import {
  defaultContainersConfiguration,
  getContainersConfiguration,
  setContainersConfiguration
} from '../configuration';

// Example: Modify default environment configuration before starting
const config: ContainersConfiguration = {
  ...defaultContainersConfiguration,
  proofServer: {
    ...defaultContainersConfiguration.proofServer,
    fileName: 'proof-server.yml'
  }
};
setContainersConfiguration(config);
```

This gives developers flexibility in configuring the test environment according to their needs.

---

### 5. Error Handling

Here's an example of handling errors when setting up wallets:

```typescript
// Example: Test for maximum wallet limit exceeded
process.env.MN_TEST_ENVIRONMENT = undefined; // Use local environment
const testEnvironment = getTestEnvironment(logger);
await testEnvironment.start();

try {
  await testEnvironment.startMidnightWalletProviders(5); // Assuming max is 4
} catch (error) {
  expect(error.message).toContain('Maximum supported number of wallets for this environment reached');
}

await testEnvironment.shutdown();
```

This demonstrates how to handle cases where the wallet limit is exceeded.

---

### 6. Advanced Usage with Proof Server

Here's an example of integrating with the proof server:

```typescript
// Example: Start a proof server with networkd ID = testnet and ID = 123
const proofServer = await DynamicProofServerContainer.start(logger, '123', 'testnet');

//stop the proof server
await proofServer.stop();
```

This shows how to integrate with and customize the proof server for testing.

---

### 7. Customized test environments

Library is provided with set of predefined environment configurations i.e.:

- LocalTestEnvironment 
- Testnet2TestEnvironment

By using `getTestEnvironment(logger);` based on environment variable MN_TEST_ENVIRONMENT test environment configuration is provided.
However, you can either create your own class defining the environment endpoints or use the below environment variables.

Here's an example of fully customized endpoints of the test environment, that you can provide using environment variables:

```shell
MN_TEST_ENVIRONMENT="env-var-remote" \
MN_TEST_NETWORK_ID="undeployed" \
MN_TEST_INDEXER="http://localhost:3085/api/" \
MN_TEST_INDEXER_WS="ws://localhost:3085/ws/" \
MN_TEST_NODE="http://localhost:3086" \
yarn test

```

---

### 8. System health check before tests

For the remote test environemnts (testnet-02, ...) simple health check is performed for each of the components to check their state before test.

## Classes

- [DevnetTestEnvironment](classes/DevnetTestEnvironment.md)
- [DynamicProofServerContainer](classes/DynamicProofServerContainer.md)
- [EnvVarRemoteTestEnvironment](classes/EnvVarRemoteTestEnvironment.md)
- [FaucetClient](classes/FaucetClient.md)
- [GzipFile](classes/GzipFile.md)
- [IndexerClient](classes/IndexerClient.md)
- [LocalTestConfiguration](classes/LocalTestConfiguration.md)
- [LocalTestEnvironment](classes/LocalTestEnvironment.md)
- [MidnightWalletProvider](classes/MidnightWalletProvider.md)
- [NodeClient](classes/NodeClient.md)
- [ProofServerClient](classes/ProofServerClient.md)
- [QanetTestEnvironment](classes/QanetTestEnvironment.md)
- [RemoteTestEnvironment](classes/RemoteTestEnvironment.md)
- [StaticProofServerContainer](classes/StaticProofServerContainer.md)
- [TestEnvironment](classes/TestEnvironment.md)
- [Testnet2TestEnvironment](classes/Testnet2TestEnvironment.md)
- [TestnetTestEnvironment](classes/TestnetTestEnvironment.md)
- [WalletFactory](classes/WalletFactory.md)
- [WalletSaveStateProvider](classes/WalletSaveStateProvider.md)

## Interfaces

- [ContainerEndpoints](interfaces/ContainerEndpoints.md)
- [ContainersConfiguration](interfaces/ContainersConfiguration.md)
- [ContractConfiguration](interfaces/ContractConfiguration.md)
- [EnvironmentConfiguration](interfaces/EnvironmentConfiguration.md)
- [LogConfiguration](interfaces/LogConfiguration.md)
- [ProofServerContainer](interfaces/ProofServerContainer.md)
- [ProofServerContainerConfiguration](interfaces/ProofServerContainerConfiguration.md)
- [StandaloneContainerNames](interfaces/StandaloneContainerNames.md)
- [StandaloneContainersConfiguration](interfaces/StandaloneContainersConfiguration.md)

## Type Aliases

- [ComponentPortsConfiguration](type-aliases/ComponentPortsConfiguration.md)
- [MidnightWallet](type-aliases/MidnightWallet.md)
- [SerializedWalletState](type-aliases/SerializedWalletState.md)
- [TxOutput](type-aliases/TxOutput.md)

## Variables

- [DEFAULT\_WALLET\_LOG\_LEVEL](variables/DEFAULT_WALLET_LOG_LEVEL.md)
- [DEFAULT\_WALLET\_STATE\_DIRECTORY](variables/DEFAULT_WALLET_STATE_DIRECTORY.md)
- [defaultContainersConfiguration](variables/defaultContainersConfiguration.md)
- [latestContainersConfiguration](variables/latestContainersConfiguration.md)
- [logger](variables/logger.md)
- [MINUTE](variables/MINUTE.md)

## Functions

- [createDefaultTestLogger](functions/createDefaultTestLogger.md)
- [createLogger](functions/createLogger.md)
- [createOutputs](functions/createOutputs.md)
- [delay](functions/delay.md)
- [expectFoundAndDeployedStatesEqual](functions/expectFoundAndDeployedStatesEqual.md)
- [expectFoundAndDeployedTxDataEqual](functions/expectFoundAndDeployedTxDataEqual.md)
- [expectFoundAndDeployedTxPrivateDataEqual](functions/expectFoundAndDeployedTxPrivateDataEqual.md)
- [expectFoundAndDeployedTxPublicDataEqual](functions/expectFoundAndDeployedTxPublicDataEqual.md)
- [expectStatesEqual](functions/expectStatesEqual.md)
- [expectSuccessfulCallTx](functions/expectSuccessfulCallTx.md)
- [expectSuccessfulDeployTx](functions/expectSuccessfulDeployTx.md)
- [expectSuccessfulTxData](functions/expectSuccessfulTxData.md)
- [extractHostnameAndPort](functions/extractHostnameAndPort.md)
- [getContainersConfiguration](functions/getContainersConfiguration.md)
- [getInitialState](functions/getInitialState.md)
- [getTestEnvironment](functions/getTestEnvironment.md)
- [getWalletStateFilename](functions/getWalletStateFilename.md)
- [initializeMidnightProviders](functions/initializeMidnightProviders.md)
- [inMemoryPrivateStateProvider](functions/inMemoryPrivateStateProvider.md)
- [normalizeWalletState](functions/normalizeWalletState.md)
- [sendTransactionToAddress](functions/sendTransactionToAddress.md)
- [sendTransactionToWallet](functions/sendTransactionToWallet.md)
- [setContainersConfiguration](functions/setContainersConfiguration.md)
- [stateValueEqual](functions/stateValueEqual.md)
- [syncWallet](functions/syncWallet.md)
- [txsEqual](functions/txsEqual.md)
- [waitForFinalizedBalance](functions/waitForFinalizedBalance.md)
- [waitForFullSync](functions/waitForFullSync.md)
- [waitForFunds](functions/waitForFunds.md)
- [waitForPending](functions/waitForPending.md)
- [waitForSyncProgressDefined](functions/waitForSyncProgressDefined.md)
- [waitForTxInHistory](functions/waitForTxInHistory.md)
- [walletStateWithoutHistoryAndCoins](functions/walletStateWithoutHistoryAndCoins.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/classes/InvalidProtocolSchemeError.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / InvalidProtocolSchemeError

# Class: InvalidProtocolSchemeError

An error describing an invalid protocol scheme.

## Extends

- `Error`

## Constructors

### Constructor

> **new InvalidProtocolSchemeError**(`invalidScheme`, `allowableSchemes`): `InvalidProtocolSchemeError`

#### Parameters

##### invalidScheme

`string`

The invalid scheme.

##### allowableSchemes

`string`[]

The valid schemes that are allowed.

#### Returns

`InvalidProtocolSchemeError`

#### Overrides

`Error.constructor`

## Properties

### allowableSchemes

> `readonly` **allowableSchemes**: `string`[]

The valid schemes that are allowed.

***

### invalidScheme

> `readonly` **invalidScheme**: `string`

The invalid scheme.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/classes/ZKConfigProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKConfigProvider

# Class: `abstract` ZKConfigProvider\<K\>

A provider for zero-knowledge intermediate representations, prover keys, and verifier keys. All
three are used by the [ProofProvider](../interfaces/ProofProvider.md) to create a proof for a call transaction. The implementation
of this provider depends on the runtime environment, since each environment has different conventions
for accessing static artifacts.

## Extended by

- [`FetchZkConfigProvider`](../../midnight-js-fetch-zk-config-provider/classes/FetchZkConfigProvider.md)
- [`NodeZkConfigProvider`](../../midnight-js-node-zk-config-provider/classes/NodeZkConfigProvider.md)

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Constructors

### Constructor

> **new ZKConfigProvider**\<`K`\>(): `ZKConfigProvider`\<`K`\>

#### Returns

`ZKConfigProvider`\<`K`\>

## Methods

### get()

> **get**(`circuitId`): `Promise`\<[`ZKConfig`](../interfaces/ZKConfig.md)\<`K`\>\>

Retrieves all zero-knowledge artifacts produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the artifacts to retrieve.

#### Returns

`Promise`\<[`ZKConfig`](../interfaces/ZKConfig.md)\<`K`\>\>

***

### getProverKey()

> `abstract` **getProverKey**(`circuitId`): `Promise`\<[`ProverKey`](../type-aliases/ProverKey.md)\>

Retrieves the prover key produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the prover key to retrieve.

#### Returns

`Promise`\<[`ProverKey`](../type-aliases/ProverKey.md)\>

***

### getVerifierKey()

> `abstract` **getVerifierKey**(`circuitId`): `Promise`\<[`VerifierKey`](../type-aliases/VerifierKey.md)\>

Retrieves the verifier key produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the verifier key to retrieve.

#### Returns

`Promise`\<[`VerifierKey`](../type-aliases/VerifierKey.md)\>

***

### getVerifierKeys()

> **getVerifierKeys**(`circuitIds`): `Promise`\<\[`K`, [`VerifierKey`](../type-aliases/VerifierKey.md)\][]\>

Retrieves the verifier keys produced by `compactc` for the given circuits.

#### Parameters

##### circuitIds

`K`[]

The circuit IDs of the verifier keys to retrieve.

#### Returns

`Promise`\<\[`K`, [`VerifierKey`](../type-aliases/VerifierKey.md)\][]\>

***

### getZKIR()

> `abstract` **getZKIR**(`circuitId`): `Promise`\<[`ZKIR`](../type-aliases/ZKIR.md)\>

Retrieves the zero-knowledge intermediate representation produced by `compactc` for the given circuit.

#### Parameters

##### circuitId

`K`

The circuit ID of the ZKIR to retrieve.

#### Returns

`Promise`\<[`ZKIR`](../type-aliases/ZKIR.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/enumerations/LogLevel.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / LogLevel

# Enumeration: LogLevel

A valid named log level.

## Enumeration Members

### DEBUG

> **DEBUG**: `"debug"`

Log levels used by Midnight.JS to report internal state.

***

### ERROR

> **ERROR**: `"error"`

***

### FATAL

> **FATAL**: `"fatal"`

***

### INFO

> **INFO**: `"info"`

Log levels typically used by DAapp developers.

***

### TRACE

> **TRACE**: `"trace"`

***

### WARN

> **WARN**: `"warn"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createBalancedTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createBalancedTx

# Function: createBalancedTx()

> **createBalancedTx**(`tx`): [`BalancedTransaction`](../type-aliases/BalancedTransaction.md)

Creates an [BalancedTransaction](../type-aliases/BalancedTransaction.md) from a ledger transaction.

## Parameters

### tx

`Transaction`

The ledger transaction to wrap.

## Returns

[`BalancedTransaction`](../type-aliases/BalancedTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createProverKey.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createProverKey

# Function: createProverKey()

> **createProverKey**(`uint8Array`): [`ProverKey`](../type-aliases/ProverKey.md)

Creates a branded prover key representation from a prover key binary.

## Parameters

### uint8Array

`Uint8Array`

The prover key binary.

## Returns

[`ProverKey`](../type-aliases/ProverKey.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createUnbalancedTx.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createUnbalancedTx

# Function: createUnbalancedTx()

> **createUnbalancedTx**(`tx`): [`UnbalancedTransaction`](../type-aliases/UnbalancedTransaction.md)

Creates an [UnbalancedTransaction](../type-aliases/UnbalancedTransaction.md) from a ledger transaction.

## Parameters

### tx

`Transaction`

The ledger transaction to wrap.

## Returns

[`UnbalancedTransaction`](../type-aliases/UnbalancedTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createVerifierKey.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createVerifierKey

# Function: createVerifierKey()

> **createVerifierKey**(`uint8Array`): [`VerifierKey`](../type-aliases/VerifierKey.md)

Creates a branded verifier key representation from a verifier key binary.

## Parameters

### uint8Array

`Uint8Array`

The verifier key binary.

## Returns

[`VerifierKey`](../type-aliases/VerifierKey.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/createZKIR.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / createZKIR

# Function: createZKIR()

> **createZKIR**(`uint8Array`): [`ZKIR`](../type-aliases/ZKIR.md)

Creates a branded ZKIR representation from a ZKIR binary.

## Parameters

### uint8Array

`Uint8Array`

The ZKIR binary.

## Returns

[`ZKIR`](../type-aliases/ZKIR.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/functions/getImpureCircuitIds.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / getImpureCircuitIds

# Function: getImpureCircuitIds()

> **getImpureCircuitIds**\<`C`\>(`contract`): [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)\<`C`\>[]

Typesafe version of `Object.keys(contract.impureCircuits)`.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)\<`any`, [`Witnesses`](../type-aliases/Witnesses.md)\<`any`\>\>

The contract type for which we would like impure circuit IDs.

## Parameters

### contract

`C`

The contract having impure circuits for which we want ids.

## Returns

[`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)\<`C`\>[]
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/Contract.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Contract

# Interface: Contract\<PS, W\>

Interface for a contract. The data types defined in this file are generic shapes for the artifacts
produced by the `compactc` compiler. In other words, this `Contract` interface should match the shape
of any `Contract` class produced by `compactc`. Midnight.js uses it for generic constraints.

## Type Parameters

### PS

`PS` = `any`

The private state modified by the contract witnesses.

### W

`W` *extends* [`Witnesses`](../type-aliases/Witnesses.md)\<`PS`\> = [`Witnesses`](../type-aliases/Witnesses.md)\<`PS`\>

The contract witnesses type.

## Properties

### impureCircuits

> `readonly` **impureCircuits**: [`ImpureCircuits`](../type-aliases/ImpureCircuits.md)\<`PS`\>

The impure circuits defined in a contract. These circuits can be used to create call transactions.

***

### witnesses

> `readonly` **witnesses**: `W`

The private oracle of the contract.

## Methods

### initialState()

> **initialState**(`context`, ...`args`): `ConstructorResult`\<`PS`\>

Constructs the initial public state of the public oracle of a contract. This is used during
deployment transaction construction.

#### Parameters

##### context

`ConstructorContext`\<`PS`\>

##### args

...`any`[]

#### Returns

`ConstructorResult`\<`PS`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/FinalizedTxData.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FinalizedTxData

# Interface: FinalizedTxData

Data for any finalized transaction.

## Properties

### blockHash

> `readonly` **blockHash**: `string`

The block hash of the block in which the transaction was included.

***

### blockHeight

> `readonly` **blockHeight**: `number`

The block height of the block in which the transaction was included.

***

### status

> `readonly` **status**: [`TxStatus`](../type-aliases/TxStatus.md)

The status of a submitted transaction.

***

### tx

> `readonly` **tx**: `Transaction`

The transaction that was finalized.

***

### txHash

> `readonly` **txHash**: `string`

The transaction hash of the transaction in which the original transaction was included.

***

### txId

> `readonly` **txId**: `string`

The transaction ID of the submitted transaction.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/LoggerProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / LoggerProvider

# Interface: LoggerProvider

A provider for logging functions.

## Properties

### debug?

> `optional` **debug**: `LogFn`

***

### error?

> `optional` **error**: `LogFn`

***

### fatal?

> `optional` **fatal**: `LogFn`

***

### info?

> `optional` **info**: `LogFn`

***

### warn?

> `optional` **warn**: `LogFn`

## Methods

### isLevelEnabled()

> **isLevelEnabled**(`level`): `boolean`

#### Parameters

##### level

[`LogLevel`](../enumerations/LogLevel.md)

#### Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/MidnightProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / MidnightProvider

# Interface: MidnightProvider

Interface for Midnight transaction submission logic. It could be implemented, e.g., by a wallet,
a third-party service, or a node itself.

## Methods

### submitTx()

> **submitTx**(`tx`): `Promise`\<`string`\>

Submit a transaction to the network to be consensed upon.

#### Parameters

##### tx

[`BalancedTransaction`](../type-aliases/BalancedTransaction.md)

A balanced and proven transaction.

#### Returns

`Promise`\<`string`\>

The transaction identifier of the submitted transaction.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/MidnightProviders.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / MidnightProviders

# Interface: MidnightProviders\<ICK, PSI, PS\>

Set of providers needed for transaction construction and submission.

## Type Parameters

### ICK

`ICK` *extends* [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md) = [`ImpureCircuitId`](../type-aliases/ImpureCircuitId.md)

A union of string literal types representing the callable circuits.

### PSI

`PSI` *extends* [`PrivateStateId`](../type-aliases/PrivateStateId.md) = [`PrivateStateId`](../type-aliases/PrivateStateId.md)

Parameter indicating the private state ID, sometimes a union of string literals.

### PS

`PS` = `any`

Parameter indicating the private state type stored, sometimes a union of private state types.

## Properties

### loggerProvider?

> `readonly` `optional` **loggerProvider**: [`LoggerProvider`](LoggerProvider.md)

An optional logger that provides utilities for logging at given levels.

***

### midnightProvider

> `readonly` **midnightProvider**: [`MidnightProvider`](MidnightProvider.md)

Submits proven, balanced transactions to the network.

***

### privateStateProvider

> `readonly` **privateStateProvider**: [`PrivateStateProvider`](PrivateStateProvider.md)\<`PSI`, `PS`\>

Manages the private state of a contract.

***

### proofProvider

> `readonly` **proofProvider**: [`ProofProvider`](ProofProvider.md)\<`ICK`\>

Creates proven, unbalanced transactions.

***

### publicDataProvider

> `readonly` **publicDataProvider**: [`PublicDataProvider`](PublicDataProvider.md)

Retrieves public data from the blockchain.

***

### walletProvider

> `readonly` **walletProvider**: [`WalletProvider`](WalletProvider.md)

Creates proven, balanced transactions.

***

### zkConfigProvider

> `readonly` **zkConfigProvider**: [`ZKConfigProvider`](../classes/ZKConfigProvider.md)\<`ICK`\>

Retrieves the ZK artifacts of a contract needed to create proofs.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/PrivateStateProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateStateProvider

# Interface: PrivateStateProvider\<PSI, PS\>

Interface for a typed key-valued store containing contract private states.

## Type Parameters

### PSI

`PSI` *extends* [`PrivateStateId`](../type-aliases/PrivateStateId.md) = [`PrivateStateId`](../type-aliases/PrivateStateId.md)

Parameter indicating the private state ID, sometimes a union of string literals.

### PS

`PS` = `any`

Parameter indicating the private state type stored, sometimes a union of private state types.

## Methods

### clear()

> **clear**(): `Promise`\<`void`\>

Remove all contract private states.

#### Returns

`Promise`\<`void`\>

***

### clearSigningKeys()

> **clearSigningKeys**(): `Promise`\<`void`\>

Remove all contract signing keys.

#### Returns

`Promise`\<`void`\>

***

### get()

> **get**(`privateStateId`): `Promise`\<`null` \| `PS`\>

Retrieve the private state at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

#### Returns

`Promise`\<`null` \| `PS`\>

***

### getSigningKey()

> **getSigningKey**(`address`): `Promise`\<`null` \| `string`\>

Retrieve the signing key for a contract.

#### Parameters

##### address

`string`

The address of the contract for which to get the signing key.

#### Returns

`Promise`\<`null` \| `string`\>

***

### remove()

> **remove**(`privateStateId`): `Promise`\<`void`\>

Remove the value at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

#### Returns

`Promise`\<`void`\>

***

### removeSigningKey()

> **removeSigningKey**(`address`): `Promise`\<`void`\>

Remove the signing key for a contract.

#### Parameters

##### address

`string`

The address of the contract for which to delete the signing key.

#### Returns

`Promise`\<`void`\>

***

### set()

> **set**(`privateStateId`, `state`): `Promise`\<`void`\>

Store the given private state at the given private state ID.

#### Parameters

##### privateStateId

`PSI`

The private state identifier.

##### state

`PS`

The private state to store.

#### Returns

`Promise`\<`void`\>

***

### setSigningKey()

> **setSigningKey**(`address`, `signingKey`): `Promise`\<`void`\>

Store the given signing key at the given address.

#### Parameters

##### address

`string`

The address of the contract having the given signing key.

##### signingKey

`string`

The signing key to store.

#### Returns

`Promise`\<`void`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ProofProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProofProvider

# Interface: ProofProvider\<K\>

Interface for a proof server running in a trusted environment.

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID used by the provider.

## Methods

### proveTx()

> **proveTx**(`tx`, `proveTxConfig`?): `Promise`\<[`UnbalancedTransaction`](../type-aliases/UnbalancedTransaction.md)\>

Creates call proofs for an unproven transaction. The resulting transaction is unbalanced and
must be balanced using the [WalletProvider](WalletProvider.md) interface.

#### Parameters

##### tx

`UnprovenTransaction`

The transaction to be proved. Prior to version 1.0.0, unproven transactions always only
          contain a single contract call.

##### proveTxConfig?

[`ProveTxConfig`](ProveTxConfig.md)\<`K`\>

The configuration for the proof request to the proof provider. Empty in case
                     a deploy transaction is being proved with no user-defined timeout.

#### Returns

`Promise`\<[`UnbalancedTransaction`](../type-aliases/UnbalancedTransaction.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ProveTxConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProveTxConfig

# Interface: ProveTxConfig\<K\>

The configuration for the proof request to the proof provider.

## Type Parameters

### K

`K` *extends* `string`

## Properties

### timeout?

> `readonly` `optional` **timeout**: `number`

The timeout for the request.

***

### zkConfig?

> `readonly` `optional` **zkConfig**: [`ZKConfig`](ZKConfig.md)\<`K`\>

The zero-knowledge configuration for the circuit that was called in `tx`.
Undefined if `tx` is a deployment transaction.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/PublicDataProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PublicDataProvider

# Interface: PublicDataProvider

Interface for a public data service. This service retrieves public data from the blockchain.
TODO: Add timeouts or retry limits to 'watchFor' queries.

## Methods

### contractStateObservable()

> **contractStateObservable**(`address`, `config`): `Observable`\<`ContractState`\>

Creates a stream of contract states. The observable emits a value every time a state is either
created or updated at the given address.
Waits indefinitely for matching data to appear.

#### Parameters

##### address

`string`

The address of the contract of interest.

##### config

[`ContractStateObservableConfig`](../type-aliases/ContractStateObservableConfig.md)

The configuration for the observable.

#### Returns

`Observable`\<`ContractState`\>

***

### queryContractState()

> **queryContractState**(`contractAddress`, `config`?): `Promise`\<`null` \| `ContractState`\>

Retrieves the on-chain state of a contract. If no block hash or block height are provided, the
contract state at the address in the latest block is returned.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

##### config?

The configuration of the query.
              If `undefined` returns the latest states.

[`BlockHeightConfig`](../type-aliases/BlockHeightConfig.md) | [`BlockHashConfig`](../type-aliases/BlockHashConfig.md)

#### Returns

`Promise`\<`null` \| `ContractState`\>

***

### queryDeployContractState()

> **queryDeployContractState**(`contractAddress`): `Promise`\<`null` \| `ContractState`\>

Retrieves the contract state included in the deployment of the contract at the given contract address.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<`null` \| `ContractState`\>

***

### queryZSwapAndContractState()

> **queryZSwapAndContractState**(`contractAddress`, `config`?): `Promise`\<`null` \| \[`ZswapChainState`, `ContractState`\]\>

Retrieves the zswap chain state (token balances) and the contract state of the contract at the
given address. Both states are retrieved in a single query to ensure consistency between the two.
Immediately returns null if no matching data is found.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

##### config?

The configuration of the query.
              If `undefined` returns the latest states.

[`BlockHeightConfig`](../type-aliases/BlockHeightConfig.md) | [`BlockHashConfig`](../type-aliases/BlockHashConfig.md)

#### Returns

`Promise`\<`null` \| \[`ZswapChainState`, `ContractState`\]\>

***

### watchForContractState()

> **watchForContractState**(`contractAddress`): `Promise`\<`ContractState`\>

Retrieves the contract state of the contract with the given address.
Waits indefinitely for matching data to appear.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<`ContractState`\>

***

### watchForDeployTxData()

> **watchForDeployTxData**(`contractAddress`): `Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

Retrieves data of the deployment transaction for the contract at the given contract address.
Waits indefinitely for matching data to appear.

#### Parameters

##### contractAddress

`string`

The address of the contract of interest.

#### Returns

`Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

***

### watchForTxData()

> **watchForTxData**(`txId`): `Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>

Retrieves data of the transaction containing the call or deployment with the given identifier.
Waits indefinitely for matching data to appear.

#### Parameters

##### txId

`string`

The identifier of the call or deployment of interest.

#### Returns

`Promise`\<[`FinalizedTxData`](FinalizedTxData.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/WalletProvider.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / WalletProvider

# Interface: WalletProvider

Interface for a wallet

## Properties

### coinPublicKey

> `readonly` **coinPublicKey**: `string`

Wallet public coin key

***

### encryptionPublicKey

> `readonly` **encryptionPublicKey**: `string`

Wallet EncryptionPublicKey

## Methods

### balanceTx()

> **balanceTx**(`tx`, `newCoins`): `Promise`\<[`BalancedTransaction`](../type-aliases/BalancedTransaction.md)\>

Balances selects coins, creates spend proofs, and pays fees for a transaction with call proofs.

#### Parameters

##### tx

[`UnbalancedTransaction`](../type-aliases/UnbalancedTransaction.md)

The transaction to balance.

##### newCoins

`CoinInfo`[]

The outputs created during a transaction.

#### Returns

`Promise`\<[`BalancedTransaction`](../type-aliases/BalancedTransaction.md)\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/interfaces/ZKConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKConfig

# Interface: ZKConfig\<K\>

Contains all information required by the [ProofProvider](ProofProvider.md)

## Type Parameters

### K

`K` *extends* `string`

The type of the circuit ID.

## Properties

### circuitId

> `readonly` **circuitId**: `K`

A circuit identifier.

***

### proverKey

> `readonly` **proverKey**: [`ProverKey`](../type-aliases/ProverKey.md)

The prover key corresponding to [ZKConfig.circuitId](#circuitid).

***

### verifierKey

> `readonly` **verifierKey**: [`VerifierKey`](../type-aliases/VerifierKey.md)

The verifier key corresponding to [ZKConfig.circuitId](#circuitid).

***

### zkir

> `readonly` **zkir**: [`ZKIR`](../type-aliases/ZKIR.md)

The zero-knowledge intermediate representation corresponding to [ZKConfig.circuitId](#circuitid).
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/All.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / All

# Type Alias: All

> **All** = `object`

Streams all previous states of a contract.

## Properties

### type

> `readonly` **type**: `"all"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BalancedTransaction.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BalancedTransaction

# Type Alias: BalancedTransaction

> **BalancedTransaction** = `Transaction` & `object`

A type representing a proven, balanced, submittable transaction.

## Type declaration

### BalancedTransaction

> `readonly` **BalancedTransaction**: unique `symbol`

Unique symbol brand.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BlockHashConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BlockHashConfig

# Type Alias: BlockHashConfig

> **BlockHashConfig** = `object`

Starts a contract state stream at the given block hash.

## Properties

### blockHash

> `readonly` **blockHash**: `string`

The block height indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"blockHash"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/BlockHeightConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / BlockHeightConfig

# Type Alias: BlockHeightConfig

> **BlockHeightConfig** = `object`

Starts a contract state stream at the given block height.

## Properties

### blockHeight

> `readonly` **blockHeight**: `number`

The block height indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"blockHeight"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/CircuitParameters.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / CircuitParameters

# Type Alias: CircuitParameters\<C, K\>

> **CircuitParameters**\<`C`, `K`\> = `Parameters`\<`C`\[`"impureCircuits"`\]\[`K`\]\> *extends* \[`CircuitContext`\<`any`\>, `...(infer A)`\] ? `A` : `never`

The parameter types of the circuits in a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

### K

`K` *extends* [`ImpureCircuitId`](ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/CircuitReturnType.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / CircuitReturnType

# Type Alias: CircuitReturnType\<C, K\>

> **CircuitReturnType**\<`C`, `K`\> = `ReturnType`\<`C`\[`"impureCircuits"`\]\[`K`\]\> *extends* `CircuitResults`\<`any`, infer U\> ? `U` : `never`

The return types of the circuits in a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

### K

`K` *extends* [`ImpureCircuitId`](ImpureCircuitId.md)\<`C`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ContractStateObservableConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ContractStateObservableConfig

# Type Alias: ContractStateObservableConfig

> **ContractStateObservableConfig** = [`TxIdConfig`](TxIdConfig.md) \| [`BlockHashConfig`](BlockHashConfig.md) \| [`BlockHeightConfig`](BlockHeightConfig.md) & `object` \| [`Latest`](Latest.md) \| [`All`](All.md)

The configuration for a contract state observable. The corresponding observables may begin at different
places (e.g. after a specific transaction identifier / block height) depending on the configuration, but
all state updates after the beginning are always included.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuit.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuit

# Type Alias: ImpureCircuit()\<PS\>

> **ImpureCircuit**\<`PS`\> = (`context`, ...`args`) => `CircuitResults`\<`PS`, `any`\>

A circuit which affects the public state.

## Type Parameters

### PS

`PS`

The private state modified by the contract witnesses.

## Parameters

### context

`CircuitContext`\<`PS`\>

### args

...`any`[]

## Returns

`CircuitResults`\<`PS`, `any`\>
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuitId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuitId

# Type Alias: ImpureCircuitId\<C\>

> **ImpureCircuitId**\<`C`\> = keyof `C`\[`"impureCircuits"`\] & `string`

A union over the impure circuit identifiers of a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md) = [`Contract`](../interfaces/Contract.md)

The contract type for which we would like impure circuit IDs.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ImpureCircuits.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ImpureCircuits

# Type Alias: ImpureCircuits\<PS\>

> **ImpureCircuits**\<`PS`\> = `Record`\<`string`, [`ImpureCircuit`](ImpureCircuit.md)\<`PS`\>\>

A collection of impure circuits defined in a contract.

## Type Parameters

### PS

`PS`

The private state modified by the contract witnesses.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/InitialStateParameters.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / InitialStateParameters

# Type Alias: InitialStateParameters\<C\>

> **InitialStateParameters**\<`C`\> = `Parameters`\<`C`\[`"initialState"`\]\> *extends* \[`ConstructorContext`\<`any`\>, `...(infer A)`\] ? `A` : `never`

The parameter type of the public state constructor.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Latest.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Latest

# Type Alias: Latest

> **Latest** = `object`

Streams all states of a contract starting with the most recent.

## Properties

### type

> `readonly` **type**: `"latest"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/PrivateState.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateState

# Type Alias: PrivateState\<C\>

> **PrivateState**\<`C`\> = `C` *extends* [`Contract`](../interfaces/Contract.md)\<infer PS\> ? `PS` : `never`

Extracts the private state of a contract.

## Type Parameters

### C

`C` *extends* [`Contract`](../interfaces/Contract.md)

The contract for which we would like the private state.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/PrivateStateId.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / PrivateStateId

# Type Alias: PrivateStateId

> **PrivateStateId** = `string`

A type representing an ID used to store a contract's private state.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ProverKey.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ProverKey

# Type Alias: ProverKey

> **ProverKey** = `Uint8Array` & `object`

A type representing a prover key derived from a contract circuit.

## Type declaration

### ProverKey

> `readonly` **ProverKey**: unique `symbol`

Unique symbol brand.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/TxIdConfig.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TxIdConfig

# Type Alias: TxIdConfig

> **TxIdConfig** = `object`

Starts a contract state stream at the given transaction identifier.

## Properties

### txId

> `readonly` **txId**: `TransactionId`

The transaction identifier indicating where to begin the state stream.

***

### type

> `readonly` **type**: `"txId"`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/TxStatus.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / TxStatus

# Type Alias: TxStatus

> **TxStatus** = *typeof* [`FailEntirely`](../variables/FailEntirely.md) \| *typeof* [`FailFallible`](../variables/FailFallible.md) \| *typeof* [`SucceedEntirely`](../variables/SucceedEntirely.md)

The status of a transaction.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/UnbalancedTransaction.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / UnbalancedTransaction

# Type Alias: UnbalancedTransaction

> **UnbalancedTransaction** = `Transaction` & `object`

A type representing a proven, unbalanced transaction.

## Type declaration

### UnbalancedTransaction

> `readonly` **UnbalancedTransaction**: unique `symbol`

Unique symbol brand.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/VerifierKey.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / VerifierKey

# Type Alias: VerifierKey

> **VerifierKey** = `Uint8Array` & `object`

A type representing a verifier key derived from a contract circuit.

## Type declaration

### VerifierKey

> `readonly` **VerifierKey**: unique `symbol`

Unique symbol brand.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Witness.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Witness

# Type Alias: Witness()\<PS\>

> **Witness**\<`PS`\> = (`context`, ...`rest`) => \[`PS`, `any`\]

A type representing a witness in a contract.

## Type Parameters

### PS

`PS`

The private state modified by the witness.

## Parameters

### context

`WitnessContext`\<`any`, `PS`\>

### rest

...`any`[]

## Returns

\[`PS`, `any`\]
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/Witnesses.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / Witnesses

# Type Alias: Witnesses\<PS\>

> **Witnesses**\<`PS`\> = `Record`\<`string`, [`Witness`](Witness.md)\<`PS`\>\>

A type representing all of a contract's witnesses.

## Type Parameters

### PS

`PS` = `any`

The private state modified by the contract witnesses.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/type-aliases/ZKIR.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / ZKIR

# Type Alias: ZKIR

> **ZKIR** = `Uint8Array` & `object`

A type representing a zero-knowledge circuit intermediate representation derived from a contract circuit.

## Type declaration

### ZKIR

> `readonly` **ZKIR**: unique `symbol`

Unique symbol brand.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/FailEntirely.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FailEntirely

# Variable: FailEntirely

> `const` **FailEntirely**: `"FailEntirely"`

Indicates that the transaction is invalid.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/FailFallible.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / FailFallible

# Variable: FailFallible

> `const` **FailFallible**: `"FailFallible"`

Indicates that the transaction is valid but the portion of the transcript
that is allowed to fail (the portion after a checkpoint) did fail. All effects
from the guaranteed part of the transaction are kept but the effects from the
fallible part of the transaction are discarded.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/variables/SucceedEntirely.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-types](../README.md) / SucceedEntirely

# Variable: SucceedEntirely

> `const` **SucceedEntirely**: `"SucceedEntirely"`

Indicates that the guaranteed and fallible portions of the transaction were
successful.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-types/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-types

# @midnight-ntwrk/midnight-js-types

## Enumerations

- [LogLevel](enumerations/LogLevel.md)

## Classes

- [InvalidProtocolSchemeError](classes/InvalidProtocolSchemeError.md)
- [ZKConfigProvider](classes/ZKConfigProvider.md)

## Interfaces

- [Contract](interfaces/Contract.md)
- [FinalizedTxData](interfaces/FinalizedTxData.md)
- [LoggerProvider](interfaces/LoggerProvider.md)
- [MidnightProvider](interfaces/MidnightProvider.md)
- [MidnightProviders](interfaces/MidnightProviders.md)
- [PrivateStateProvider](interfaces/PrivateStateProvider.md)
- [ProofProvider](interfaces/ProofProvider.md)
- [ProveTxConfig](interfaces/ProveTxConfig.md)
- [PublicDataProvider](interfaces/PublicDataProvider.md)
- [WalletProvider](interfaces/WalletProvider.md)
- [ZKConfig](interfaces/ZKConfig.md)

## Type Aliases

- [All](type-aliases/All.md)
- [BalancedTransaction](type-aliases/BalancedTransaction.md)
- [BlockHashConfig](type-aliases/BlockHashConfig.md)
- [BlockHeightConfig](type-aliases/BlockHeightConfig.md)
- [CircuitParameters](type-aliases/CircuitParameters.md)
- [CircuitReturnType](type-aliases/CircuitReturnType.md)
- [ContractStateObservableConfig](type-aliases/ContractStateObservableConfig.md)
- [ImpureCircuit](type-aliases/ImpureCircuit.md)
- [ImpureCircuitId](type-aliases/ImpureCircuitId.md)
- [ImpureCircuits](type-aliases/ImpureCircuits.md)
- [InitialStateParameters](type-aliases/InitialStateParameters.md)
- [Latest](type-aliases/Latest.md)
- [PrivateState](type-aliases/PrivateState.md)
- [PrivateStateId](type-aliases/PrivateStateId.md)
- [ProverKey](type-aliases/ProverKey.md)
- [TxIdConfig](type-aliases/TxIdConfig.md)
- [TxStatus](type-aliases/TxStatus.md)
- [UnbalancedTransaction](type-aliases/UnbalancedTransaction.md)
- [VerifierKey](type-aliases/VerifierKey.md)
- [Witness](type-aliases/Witness.md)
- [Witnesses](type-aliases/Witnesses.md)
- [ZKIR](type-aliases/ZKIR.md)

## Variables

- [FailEntirely](variables/FailEntirely.md)
- [FailFallible](variables/FailFallible.md)
- [SucceedEntirely](variables/SucceedEntirely.md)

## Functions

- [createBalancedTx](functions/createBalancedTx.md)
- [createProverKey](functions/createProverKey.md)
- [createUnbalancedTx](functions/createUnbalancedTx.md)
- [createVerifierKey](functions/createVerifierKey.md)
- [createZKIR](functions/createZKIR.md)
- [getImpureCircuitIds](functions/getImpureCircuitIds.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertDefined.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertDefined

# Function: assertDefined()

> **assertDefined**\<`A`\>(`value`, `message`?): `asserts value is NonNullable<A>`

Asserts that the given value is non-nullable.

## Type Parameters

### A

`A`

## Parameters

### value

The value to test for nullability.

`undefined` | `null` | `A`

### message?

`string`

The error message to use if an error is thrown.

## Returns

`asserts value is NonNullable<A>`

## Throws

Error If the value is nullable.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertIsContractAddress.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertIsContractAddress

# Function: assertIsContractAddress()

> **assertIsContractAddress**(`contractAddress`): `asserts contractAddress is string`

**`Internal`**

Asserts that a string represents a hex-encoded contract address.

## Parameters

### contractAddress

`string`

The source string.

## Returns

`asserts contractAddress is string`

## Throws

`TypeError`
`contractAddress` is not a correctly formatted ContractAddress.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertIsHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertIsHex

# Function: assertIsHex()

> **assertIsHex**(`source`, `byteLen`?): `asserts source is string`

Asserts that a string represents a hex-encoded sequence of bytes.

## Parameters

### source

`string`

The source string.

### byteLen?

`number`

An optional number of bytes that `source` should represent. If not specified
then any number of bytes can be represented by `source`.

## Returns

`asserts source is string`

## Throws

`Error`
`byteLen` is \<= zero. Valid hex-strings will be required to have at least one byte.

## Throws

`TypeError`
`source` is not a hex-encoded string because it:
- is empty,
- contains invalid or incomplete characters, or
- does not represent `byteLen` bytes.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/assertUndefined.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / assertUndefined

# Function: assertUndefined()

> **assertUndefined**\<`A`\>(`value`, `message`?): asserts value is undefined \| null

Asserts that the given value is null or undefined.

## Type Parameters

### A

`A`

## Parameters

### value

The value to test for nullability.

`undefined` | `null` | `A`

### message?

`string`

The error message to use if an error is thrown.

## Returns

asserts value is undefined \| null

## Throws

Error If the value is not undefined or null
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/fromHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / fromHex

# Function: fromHex()

> **fromHex**(`str`): `Buffer`

Converts a hex string into a byte string.

## Parameters

### str

`string`

The hex string to decode.

## Returns

`Buffer`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/isHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / isHex

# Function: isHex()

> **isHex**(`source`, `byteLen`?): `boolean`

Determines if a string represents a hex-encoded sequence of bytes.

## Parameters

### source

`string`

The source string.

### byteLen?

`number`

An optional number of bytes that `source` should represent. If not specified
then any number of bytes can be represented by `source`.

## Returns

`boolean`

`true` if the `source` string is parsable as a hex-string, of non-zero length, and
of the optional byte length of `byteLen`; otherwise `false`.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseCoinPublicKeyToHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseCoinPublicKeyToHex

# Function: parseCoinPublicKeyToHex()

> **parseCoinPublicKeyToHex**(`possibleBech32`, `zswapNetworkId`): `string`

Parses a coin public key (in Bech32m format or hex) into a hex formatted string.

## Parameters

### possibleBech32

`string`

The input string, which can be a Bech32m-encoded coin public key or a hex string.

### zswapNetworkId

`NetworkId`

The network ID used for decoding the Bech32m formatted string.

## Returns

`string`

The hex string representation of the coin public key.

## Throws

`Error`
If the input string is not a valid hex string or a valid Bech32m-encoded coin public key.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseEncPublicKeyToHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseEncPublicKeyToHex

# Function: parseEncPublicKeyToHex()

> **parseEncPublicKeyToHex**(`possibleBech32`, `zswapNetworkId`): `string`

Parses an encryption public key (in Bech32m or hex format) into a hex formatted string.

## Parameters

### possibleBech32

`string`

The input string, which can be a Bech32m-encoded encryption public key or a hex string.

### zswapNetworkId

`NetworkId`

The network ID used for decoding the Bech32m formatted string.

## Returns

`string`

The hex string representation of the encryption public key.

## Throws

`Error`
If the input string is not a valid hex string or a valid Bech32m-encoded encryption public key.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/parseHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / parseHex

# Function: parseHex()

> **parseHex**(`source`): [`ParsedHexString`](../type-aliases/ParsedHexString.md)

Parses a string as a hex-encoded string.

## Parameters

### source

`string`

The source string to parse.

## Returns

[`ParsedHexString`](../type-aliases/ParsedHexString.md)

A [ParsedHexString](../type-aliases/ParsedHexString.md) describing the parsed elements of `source`.

## Examples

```ts
parseHex('Hello') =>
  {
    hasPrefix: false,
    incompleteChars: 'Hello'
  }
```

```ts
parseHex('ab12e') =>
  {
    hasPrefix: false,
    byteChars: 'ab12'
    incompleteChars: 'e'
  }
```

```ts
parseHex('0xab12') =>
  {
    hasPrefix: true,
    byteChars: 'ab12'
    incompleteChars: ''
  }
```
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/functions/toHex.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / toHex

# Function: toHex()

> **toHex**(`bytes`): `string`

Converts a byte string into a hex string.

## Parameters

### bytes

`Uint8Array`

The byte string to encode.

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/type-aliases/ParsedHexString.md">
[**Midnight.js API Reference v2.0.2**](../../../README.md)

***

[Midnight.js API Reference](../../../packages.md) / [@midnight-ntwrk/midnight-js-utils](../README.md) / ParsedHexString

# Type Alias: ParsedHexString

> **ParsedHexString** = `object`

The result of parsing a string as a hex-encoded string.

## Properties

### byteChars

> `readonly` **byteChars**: `string`

The captured sequence of _whole_ bytes found in the source string.

***

### hasPrefix

> `readonly` **hasPrefix**: `boolean`

A flag indicating if the hex-string has a `'0x'` prefix.

***

### incompleteChars

> `readonly` **incompleteChars**: `string`

The remaining characters of incomplete bytes and/or the non hexadecimal characters found
in the source string.
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-utils/README.md">
[**Midnight.js API Reference v2.0.2**](../../README.md)

***

[Midnight.js API Reference](../../packages.md) / @midnight-ntwrk/midnight-js-utils

# @midnight-ntwrk/midnight-js-utils

## Type Aliases

- [ParsedHexString](type-aliases/ParsedHexString.md)

## Functions

- [assertDefined](functions/assertDefined.md)
- [assertIsContractAddress](functions/assertIsContractAddress.md)
- [assertIsHex](functions/assertIsHex.md)
- [assertUndefined](functions/assertUndefined.md)
- [fromHex](functions/fromHex.md)
- [isHex](functions/isHex.md)
- [parseCoinPublicKeyToHex](functions/parseCoinPublicKeyToHex.md)
- [parseEncPublicKeyToHex](functions/parseEncPublicKeyToHex.md)
- [parseHex](functions/parseHex.md)
- [toHex](functions/toHex.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/packages.md">
[**Midnight.js API Reference v2.0.2**](README.md)

***

# Midnight.js API Reference v2.0.2

## Packages

- [@midnight-ntwrk/midnight-js-contracts - v2.0.2](@midnight-ntwrk/midnight-js-contracts/README.md)
- [@midnight-ntwrk/midnight-js-fetch-zk-config-provider - v2.0.2](@midnight-ntwrk/midnight-js-fetch-zk-config-provider/README.md)
- [@midnight-ntwrk/midnight-js-http-client-proof-provider - v2.0.2](@midnight-ntwrk/midnight-js-http-client-proof-provider/README.md)
- [@midnight-ntwrk/midnight-js-indexer-public-data-provider - v2.0.2](@midnight-ntwrk/midnight-js-indexer-public-data-provider/README.md)
- [@midnight-ntwrk/midnight-js-level-private-state-provider - v2.0.2](@midnight-ntwrk/midnight-js-level-private-state-provider/README.md)
- [@midnight-ntwrk/midnight-js-logger-provider - v2.0.2](@midnight-ntwrk/midnight-js-logger-provider/README.md)
- [@midnight-ntwrk/midnight-js-network-id - v2.0.2](@midnight-ntwrk/midnight-js-network-id/README.md)
- [@midnight-ntwrk/midnight-js-node-zk-config-provider - v2.0.2](@midnight-ntwrk/midnight-js-node-zk-config-provider/README.md)
- [@midnight-ntwrk/midnight-js-testing - v2.0.2](@midnight-ntwrk/midnight-js-testing/README.md)
- [@midnight-ntwrk/midnight-js-types - v2.0.2](@midnight-ntwrk/midnight-js-types/README.md)
- [@midnight-ntwrk/midnight-js-utils - v2.0.2](@midnight-ntwrk/midnight-js-utils/README.md)
</file>

<file path="docs/develop/reference/midnight-api/midnight-js/README.md">
**Midnight.js API Reference v2.0.2**

***

# Midnight.js

Midnight.js is a Typescript-based application development framework for the 
Midnight blockchain. Analogous to [Web3.js](https://web3js.org/) for Ethereum, or
[polkadot.js](https://polkadot.js.org/) for Polkadot, it contains utilities for:

- Creating and submitting transactions
- Interacting with wallets
- Querying for block and state information
- Subscribing to chain events

Due to the privacy-preservation properties of the Midnight system, Midnight.js also 
contains a number of utilities that are unique to it:

- Executing smart contracts locally
- Incorporating private state into contract execution
- Persisting, querying, and updating private state
- Creating and verifying zero-knowledge proofs

## Package structure

- `types` - Contains types and interfaces common to all other packages.
- `contracts` - Contains utilities for interacting with Midnight smart contracts.
- `indexer-public-data-provider` - Contains a cross-environment implementation of a Midnight indexer client.
- `node-zk-config-provider` - Contains a file system based Node.js utility for retrieving zero-knowledge artifacts.
- `fetch-zk-config-provider` - Contains a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) based cross-environment utility for retrieving zero-knowledge artifacts.
- `network-id` - Contains utilities for setting the network id used by `ledger`, `zswap`, and `compact-runtime` dependencies.
- `http-client-proof-provider` - Contains a cross-environment implementation of a proof-server client.
- `level-private-state-provider` - Contains a cross-environment implementation of a persistent private state store based on [Level](https://github.com/Level/level).
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/ContractMaintenanceAuthority.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ContractMaintenanceAuthority

# Class: ContractMaintenanceAuthority

A committee permitted to make changes to this contract. If a threshold of
the public keys in this committee sign off, they can change the rules of
this contract, or recompile it for a new version.

If the threshold is greater than the number of committee members, it is
impossible for them to sign anything.

## Constructors

### new ContractMaintenanceAuthority(committee, threshold, counter)

```ts
new ContractMaintenanceAuthority(
   committee, 
   threshold, 
   counter?): ContractMaintenanceAuthority
```

Constructs a new authority from its components

If not supplied, `counter` will default to `0n`. Values should be
non-negative, and at most 2^32 - 1.

At deployment, `counter` must be `0n`, and any subsequent update should
set counter to exactly one greater than the current value.

#### Parameters

• **committee**: `string`[]

• **threshold**: `number`

• **counter?**: `bigint`

#### Returns

[`ContractMaintenanceAuthority`](ContractMaintenanceAuthority.md)

## Properties

### committee

```ts
readonly committee: string[];
```

The committee public keys

***

### counter

```ts
readonly counter: bigint;
```

The replay protection counter

***

### threshold

```ts
readonly threshold: number;
```

How many keys must sign rule changes

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractState`](ContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/ContractOperation.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ContractOperation

# Class: ContractOperation

An individual operation, or entry point of a contract, consisting primarily
of a ZK verifier keys, potentially for different versions of the proving
system.

Only the latest available version is exposed to this API.

Note that the serialized form of the key is checked on initialization

## Constructors

### new ContractOperation()

```ts
new ContractOperation(): ContractOperation
```

#### Returns

[`ContractOperation`](ContractOperation.md)

## Properties

### verifierKey

```ts
verifierKey: Uint8Array;
```

## Methods

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractOperation
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractOperation`](ContractOperation.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/ContractState.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ContractState

# Class: ContractState

The state of a contract, consisting primarily of the [data](ContractState.md#data) accessible
directly to the contract, and the map of [ContractOperation](ContractOperation.md)s that can
be called on it, the keys of which can be accessed with [operations](ContractState.md#operations),
and the individual operations can be read with [operation](ContractState.md#operation) and written
to with [setOperation](ContractState.md#setoperation).

## Constructors

### new ContractState()

```ts
new ContractState(): ContractState
```

Creates a blank contract state

#### Returns

[`ContractState`](ContractState.md)

## Properties

### data

```ts
data: StateValue;
```

The current value of the primary state of the contract

***

### maintenanceAuthority

```ts
maintenanceAuthority: ContractMaintenanceAuthority;
```

The maintenance authority associated with this contract

## Methods

### operation()

```ts
operation(operation): undefined | ContractOperation
```

Get the operation at a specific entry point name

#### Parameters

• **operation**: `string` \| `Uint8Array`

#### Returns

`undefined` \| [`ContractOperation`](ContractOperation.md)

***

### operations()

```ts
operations(): (string | Uint8Array)[]
```

Return a list of the entry points currently registered on this contract

#### Returns

(`string` \| `Uint8Array`)[]

***

### query()

```ts
query(query, cost_model): GatherResult[]
```

Runs a series of operations against the current state, and returns the
results

#### Parameters

• **query**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`GatherResult`](../type-aliases/GatherResult.md)[]

***

### serialize()

```ts
serialize(networkid): Uint8Array
```

#### Parameters

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### setOperation()

```ts
setOperation(operation, value): void
```

Set a specific entry point name to contain a given operation

#### Parameters

• **operation**: `string` \| `Uint8Array`

• **value**: [`ContractOperation`](ContractOperation.md)

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, networkid): ContractState
```

#### Parameters

• **raw**: `Uint8Array`

• **networkid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ContractState`](ContractState.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/CostModel.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / CostModel

# Class: CostModel

A cost model for calculating transaction fees

## Constructors

### new CostModel()

```ts
private new CostModel(): CostModel
```

#### Returns

[`CostModel`](CostModel.md)

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### dummyCostModel()

```ts
static dummyCostModel(): CostModel
```

A cost model for use in non-critical contexts

#### Returns

[`CostModel`](CostModel.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/QueryContext.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / QueryContext

# Class: QueryContext

Provides the information needed to fully process a transaction, including
information about the rest of the transaction, and the state of the chain at
the time of execution.

## Constructors

### new QueryContext(state, address)

```ts
new QueryContext(state, address): QueryContext
```

Construct a basic context from a contract's address and current state
value

#### Parameters

• **state**: [`StateValue`](StateValue.md)

• **address**: `string`

#### Returns

[`QueryContext`](QueryContext.md)

## Properties

### address

```ts
readonly address: string;
```

The address of the contract

***

### block

```ts
block: BlockContext;
```

The block-level information accessible to the contract

***

### comIndicies

```ts
readonly comIndicies: Map<string, bigint>;
```

The commitment indices map accessible to the contract, primarily via
[qualify](QueryContext.md#qualify)

***

### effects

```ts
effects: Effects;
```

The effects that occurred during execution against this context, should
match those declared in a [Transcript](../type-aliases/Transcript.md)

***

### state

```ts
readonly state: StateValue;
```

The current contract state retained in the context

## Methods

### insertCommitment()

```ts
insertCommitment(comm, index): QueryContext
```

Register a given coin commitment as being accessible at a specific index,
for use when receiving coins in-contract, and needing to record their
index to later spend them

#### Parameters

• **comm**: `string`

• **index**: `bigint`

#### Returns

[`QueryContext`](QueryContext.md)

***

### ~~intoTranscript()~~

```ts
intoTranscript(program, cost_model): [undefined | Transcript<AlignedValue>, undefined | Transcript<AlignedValue>]
```

Finalizes a sequence of operations against their initial context,
resulting in a guaranteed and fallible [Transcript](../type-aliases/Transcript.md), optimally
allocated, and heuristically covered for gas fees.

#### Parameters

• **program**: [`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>, `undefined` \| [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>]

#### Deprecated

Please use the ledger's `partitionTranscripts` instead.

***

### qualify()

`Internal`

```ts
qualify(coin): undefined | Value
```

Internal counterpart to [insertCommitment](QueryContext.md#insertcommitment); upgrades an encoded
[CoinInfo](../type-aliases/CoinInfo.md) to an encoded [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) using the
inserted commitments

#### Parameters

• **coin**: [`Value`](../type-aliases/Value.md)

#### Returns

`undefined` \| [`Value`](../type-aliases/Value.md)

***

### query()

```ts
query(
   ops, 
   cost_model, 
   gas_limit?): QueryResults
```

Runs a sequence of operations in gather mode, returning the results of the
gather.

#### Parameters

• **ops**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](CostModel.md)

• **gas\_limit?**: `bigint`

#### Returns

[`QueryResults`](QueryResults.md)

***

### runTranscript()

```ts
runTranscript(transcript, cost_model): QueryContext
```

Runs a transcript in verifying mode against the current query context,
outputting a new query context, with the [state](QueryContext.md#state) and [effects](QueryContext.md#effects)
from after the execution.

#### Parameters

• **transcript**: [`Transcript`](../type-aliases/Transcript.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>

• **cost\_model**: [`CostModel`](CostModel.md)

#### Returns

[`QueryContext`](QueryContext.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/QueryResults.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / QueryResults

# Class: QueryResults

The results of making a query against a specific state or context

## Constructors

### new QueryResults()

```ts
private new QueryResults(): QueryResults
```

#### Returns

[`QueryResults`](QueryResults.md)

## Properties

### context

```ts
readonly context: QueryContext;
```

The context state after executing the query. This can be used to execute
further queries

***

### events

```ts
readonly events: GatherResult[];
```

Any events/results that occurred during or from the query

***

### gasCost

```ts
readonly gasCost: bigint;
```

The measured cost of executing the query

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/StateBoundedMerkleTree.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / StateBoundedMerkleTree

# Class: StateBoundedMerkleTree

Represents a fixed-depth Merkle tree storing hashed data, whose preimages
are unknown

## Constructors

### new StateBoundedMerkleTree(height)

```ts
new StateBoundedMerkleTree(height): StateBoundedMerkleTree
```

Create a blank tree with the given height

#### Parameters

• **height**: `number`

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

## Properties

### height

```ts
readonly height: number;
```

## Methods

### collapse()

`Internal`

```ts
collapse(start, end): StateBoundedMerkleTree
```

Erases all but necessary hashes between, and inclusive of, `start` and
`end` inidices

#### Parameters

• **start**: `bigint`

• **end**: `bigint`

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Throws

If the indices are out-of-bounds for the tree, or `end < start`

***

### findPathForLeaf()

`Internal`

```ts
findPathForLeaf(leaf): AlignedValue
```

Internal implementation of the finding path primitive

#### Parameters

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the leaf is not in the tree

***

### pathForLeaf()

`Internal`

```ts
pathForLeaf(index, leaf): AlignedValue
```

Internal implementation of the path construction primitive

#### Parameters

• **index**: `bigint`

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

#### Throws

If the index is out-of-bounds for the tree

***

### root()

`Internal`

```ts
root(): Value
```

Internal implementation of the merkle tree root primitive

#### Returns

[`Value`](../type-aliases/Value.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### update()

```ts
update(index, leaf): StateBoundedMerkleTree
```

Inserts a value into the Merkle tree, returning the updated tree

#### Parameters

• **index**: `bigint`

• **leaf**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Throws

If the index is out-of-bounds for the tree
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/StateMap.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / StateMap

# Class: StateMap

Represents a key-value map, where keys are [AlignedValue](../type-aliases/AlignedValue.md)s, and values
are [StateValue](StateValue.md)s.

## Constructors

### new StateMap()

```ts
new StateMap(): StateMap
```

#### Returns

[`StateMap`](StateMap.md)

## Methods

### get()

```ts
get(key): undefined | StateValue
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### insert()

```ts
insert(key, value): StateMap
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **value**: [`StateValue`](StateValue.md)

#### Returns

[`StateMap`](StateMap.md)

***

### keys()

```ts
keys(): AlignedValue[]
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)[]

***

### remove()

```ts
remove(key): StateMap
```

#### Parameters

• **key**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateMap`](StateMap.md)

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/StateValue.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / StateValue

# Class: StateValue

Represents the core of a contract's state, and recursively represents each
of its components.

There are different *classes* of state values:
- `null`
- Cells of [AlignedValue](../type-aliases/AlignedValue.md)s
- Maps from [AlignedValue](../type-aliases/AlignedValue.md)s to state values
- Bounded Merkle trees containing [AlignedValue](../type-aliases/AlignedValue.md) leaves
- Short (\<= 15 element) arrays of state values

State values are *immutable*, any operations that mutate states will return
a new state instead.

## Constructors

### new StateValue()

```ts
private new StateValue(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)

## Methods

### arrayPush()

```ts
arrayPush(value): StateValue
```

#### Parameters

• **value**: [`StateValue`](StateValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### asArray()

```ts
asArray(): undefined | StateValue[]
```

#### Returns

`undefined` \| [`StateValue`](StateValue.md)[]

***

### asBoundedMerkleTree()

```ts
asBoundedMerkleTree(): undefined | StateBoundedMerkleTree
```

#### Returns

`undefined` \| [`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

***

### asCell()

```ts
asCell(): AlignedValue
```

#### Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)

***

### asMap()

```ts
asMap(): undefined | StateMap
```

#### Returns

`undefined` \| [`StateMap`](StateMap.md)

***

### encode()

`Internal`

```ts
encode(): EncodedStateValue
```

#### Returns

[`EncodedStateValue`](../type-aliases/EncodedStateValue.md)

***

### logSize()

```ts
logSize(): number
```

#### Returns

`number`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### type()

```ts
type(): 
  | "map"
  | "null"
  | "cell"
  | "array"
  | "boundedMerkleTree"
```

#### Returns

  \| `"map"`
  \| `"null"`
  \| `"cell"`
  \| `"array"`
  \| `"boundedMerkleTree"`

***

### decode()

`Internal`

```ts
static decode(value): StateValue
```

#### Parameters

• **value**: [`EncodedStateValue`](../type-aliases/EncodedStateValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newArray()

```ts
static newArray(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)

***

### newBoundedMerkleTree()

```ts
static newBoundedMerkleTree(tree): StateValue
```

#### Parameters

• **tree**: [`StateBoundedMerkleTree`](StateBoundedMerkleTree.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newCell()

```ts
static newCell(value): StateValue
```

#### Parameters

• **value**: [`AlignedValue`](../type-aliases/AlignedValue.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newMap()

```ts
static newMap(map): StateValue
```

#### Parameters

• **map**: [`StateMap`](StateMap.md)

#### Returns

[`StateValue`](StateValue.md)

***

### newNull()

```ts
static newNull(): StateValue
```

#### Returns

[`StateValue`](StateValue.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/VmResults.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / VmResults

# Class: VmResults

Represents the results of a VM call

## Constructors

### new VmResults()

```ts
private new VmResults(): VmResults
```

#### Returns

[`VmResults`](VmResults.md)

## Properties

### events

```ts
readonly events: GatherResult[];
```

The events that got emitted by this VM invocation

***

### gasCost

```ts
readonly gasCost: bigint;
```

The computed gas cost of running this VM invocation

***

### stack

```ts
readonly stack: VmStack;
```

The VM stack at the end of the VM invocation

## Methods

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/classes/VmStack.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / VmStack

# Class: VmStack

Represents the state of the VM's stack at a specific point. The stack is an
array of [StateValue](StateValue.md)s, each of which is also annotated with whether
it is "strong" or "weak"; that is, whether it is permitted to be stored
on-chain or not.

## Constructors

### new VmStack()

```ts
new VmStack(): VmStack
```

#### Returns

[`VmStack`](VmStack.md)

## Methods

### get()

```ts
get(idx): undefined | StateValue
```

#### Parameters

• **idx**: `number`

#### Returns

`undefined` \| [`StateValue`](StateValue.md)

***

### isStrong()

```ts
isStrong(idx): undefined | boolean
```

#### Parameters

• **idx**: `number`

#### Returns

`undefined` \| `boolean`

***

### length()

```ts
length(): number
```

#### Returns

`number`

***

### push()

```ts
push(value, is_strong): void
```

#### Parameters

• **value**: [`StateValue`](StateValue.md)

• **is\_strong**: `boolean`

#### Returns

`void`

***

### removeLast()

```ts
removeLast(): void
```

#### Returns

`void`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/enumerations/NetworkId.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / NetworkId

# Enumeration: NetworkId

The network currently being targeted

## Enumeration Members

### DevNet

```ts
DevNet: 1;
```

A developer network, not guaranteed to be persistent

***

### MainNet

```ts
MainNet: 3;
```

The Midnight mainnet

***

### TestNet

```ts
TestNet: 2;
```

A persistent testnet

***

### Undeployed

```ts
Undeployed: 0;
```

A local test network
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/bigIntModFr.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / bigIntModFr

# Function: bigIntModFr()

```ts
bigIntModFr(x): bigint
```

Takes a bigint modulus the proof systems scalar field

## Parameters

• **x**: `bigint`

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/bigIntToValue.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / bigIntToValue

# Function: bigIntToValue()

`Internal`

```ts
bigIntToValue(x): Value
```

Internal conversion between bigints and their field-aligned binary
representation

## Parameters

• **x**: `bigint`

## Returns

[`Value`](../type-aliases/Value.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/checkProofData.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / checkProofData

# Function: checkProofData()

`Internal`

```ts
checkProofData(
   zkir, 
   input, 
   output, 
   public_transcript, 
   private_transcript_outputs): void
```

Internal implementation of proof dry runs.

## Parameters

• **zkir**: `string`

• **input**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **output**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **public\_transcript**: [`Op`](../type-aliases/Op.md)\<[`AlignedValue`](../type-aliases/AlignedValue.md)\>[]

• **private\_transcript\_outputs**: [`AlignedValue`](../type-aliases/AlignedValue.md)[]

## Returns

`void`

## Throws

If the proof would not hold
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/coinCommitment.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / coinCommitment

# Function: coinCommitment()

`Internal`

```ts
coinCommitment(coin, recipient): AlignedValue
```

Internal implementation of the coin commitment primitive.

## Parameters

• **coin**: [`AlignedValue`](../type-aliases/AlignedValue.md)

• **recipient**: [`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/decodeCoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / decodeCoinInfo

# Function: decodeCoinInfo()

```ts
decodeCoinInfo(coin): CoinInfo
```

Decode a [CoinInfo](../type-aliases/CoinInfo.md) from Compact's `CoinInfo` TypeScript representation

## Parameters

• **coin**

• **coin\.color**: `Uint8Array`

• **coin\.nonce**: `Uint8Array`

• **coin\.value**: `bigint`

## Returns

[`CoinInfo`](../type-aliases/CoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/decodeCoinPublicKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / decodeCoinPublicKey

# Function: decodeCoinPublicKey()

```ts
decodeCoinPublicKey(pk): CoinPublicKey
```

Decode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) from a `Uint8Array` originating from Compact's
`CoinPublicKey` type

## Parameters

• **pk**: `Uint8Array`

## Returns

[`CoinPublicKey`](../type-aliases/CoinPublicKey.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/decodeContractAddress.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / decodeContractAddress

# Function: decodeContractAddress()

```ts
decodeContractAddress(addr): ContractAddress
```

Decode a [ContractAddress](../type-aliases/ContractAddress.md) from a `Uint8Array` originating from
Compact's `ContractAddress` type

## Parameters

• **addr**: `Uint8Array`

## Returns

[`ContractAddress`](../type-aliases/ContractAddress.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/decodeQualifiedCoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / decodeQualifiedCoinInfo

# Function: decodeQualifiedCoinInfo()

```ts
decodeQualifiedCoinInfo(coin): QualifiedCoinInfo
```

Decode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) from Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

• **coin**

• **coin\.color**: `Uint8Array`

• **coin\.mt\_index**: `bigint`

• **coin\.nonce**: `Uint8Array`

• **coin\.value**: `bigint`

## Returns

[`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/decodeTokenType.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / decodeTokenType

# Function: decodeTokenType()

```ts
decodeTokenType(tt): TokenType
```

Decode a [TokenType](../type-aliases/TokenType.md) from a `Uint8Array` originating from Compact's
`TokenType` type

## Parameters

• **tt**: `Uint8Array`

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/degradeToTransient.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / degradeToTransient

# Function: degradeToTransient()

`Internal`

```ts
degradeToTransient(persistent): Value
```

Internal implementation of the degrade to transient primitive

## Parameters

• **persistent**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If persistent does not encode a 32-byte bytestring
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/dummyContractAddress.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / dummyContractAddress

# Function: dummyContractAddress()

```ts
dummyContractAddress(): string
```

A sample contract address, guaranteed to be the same for a given network ID
for use in testing

## Returns

`string`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/ecAdd.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ecAdd

# Function: ecAdd()

`Internal`

```ts
ecAdd(a, b): Value
```

Internal implementation of the elliptic curve addition primitive

## Parameters

• **a**: [`Value`](../type-aliases/Value.md)

• **b**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If either input does not encode an elliptic curve point
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/ecMul.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ecMul

# Function: ecMul()

`Internal`

```ts
ecMul(a, b): Value
```

Internal implementation of the elliptic curve multiplication primitive

## Parameters

• **a**: [`Value`](../type-aliases/Value.md)

• **b**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If a does not encode an elliptic curve point or b
does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/ecMulGenerator.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ecMulGenerator

# Function: ecMulGenerator()

`Internal`

```ts
ecMulGenerator(val): Value
```

Internal implementation of the elliptic curve generator multiplication
primitive

## Parameters

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

if val does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/encodeCoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / encodeCoinInfo

# Function: encodeCoinInfo()

```ts
encodeCoinInfo(coin): {
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

Encode a [CoinInfo](../type-aliases/CoinInfo.md) into a Compact's `CoinInfo` TypeScript
representation

## Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/encodeCoinPublicKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / encodeCoinPublicKey

# Function: encodeCoinPublicKey()

```ts
encodeCoinPublicKey(pk): Uint8Array
```

Encode a [CoinPublicKey](../type-aliases/CoinPublicKey.md) into a `Uint8Array` for use in Compact's
`CoinPublicKey` type

## Parameters

• **pk**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/encodeContractAddress.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / encodeContractAddress

# Function: encodeContractAddress()

```ts
encodeContractAddress(addr): Uint8Array
```

Encode a [ContractAddress](../type-aliases/ContractAddress.md) into a `Uint8Array` for use in Compact's
`ContractAddress` type

## Parameters

• **addr**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/encodeQualifiedCoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / encodeQualifiedCoinInfo

# Function: encodeQualifiedCoinInfo()

```ts
encodeQualifiedCoinInfo(coin): {
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
}
```

Encode a [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) into a Compact's `QualifiedCoinInfo`
TypeScript representation

## Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

## Returns

```ts
{
  color: Uint8Array;
  mt_index: bigint;
  nonce: Uint8Array;
  value: bigint;
}
```

### color

```ts
color: Uint8Array;
```

### mt\_index

```ts
mt_index: bigint;
```

### nonce

```ts
nonce: Uint8Array;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/encodeTokenType.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / encodeTokenType

# Function: encodeTokenType()

```ts
encodeTokenType(tt): Uint8Array
```

Encode a [TokenType](../type-aliases/TokenType.md) into a `Uint8Array` for use in Compact's
`TokenType` type

## Parameters

• **tt**: `string`

## Returns

`Uint8Array`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/hashToCurve.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / hashToCurve

# Function: hashToCurve()

`Internal`

```ts
hashToCurve(align, val): Value
```

Internal implementation of the hash to curve primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/leafHash.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / leafHash

# Function: leafHash()

`Internal`

```ts
leafHash(value): AlignedValue
```

Internal implementation of the Merkle tree leaf hash primitive.

## Parameters

• **value**: [`AlignedValue`](../type-aliases/AlignedValue.md)

## Returns

[`AlignedValue`](../type-aliases/AlignedValue.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/maxAlignedSize.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / maxAlignedSize

# Function: maxAlignedSize()

`Internal`

```ts
maxAlignedSize(alignment): bigint
```

Internal implementation of the max aligned size primitive.

## Parameters

• **alignment**: [`Alignment`](../type-aliases/Alignment.md)

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/maxField.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / maxField

# Function: maxField()

```ts
maxField(): bigint
```

Returns the maximum representable value in the proof systems scalar field
(that is, 1 less than the prime modulus)

## Returns

`bigint`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/persistentCommit.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / persistentCommit

# Function: persistentCommit()

`Internal`

```ts
persistentCommit(
   align, 
   val, 
   opening): Value
```

Internal implementation of the persistent commitment primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

• **opening**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align,
opening does not encode a 32-byte bytestring, or any component has a
compress alignment
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/persistentHash.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / persistentHash

# Function: persistentHash()

`Internal`

```ts
persistentHash(align, val): Value
```

Internal implementation of the persistent hash primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align, or any
component has a compress alignment
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/runProgram.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / runProgram

# Function: runProgram()

```ts
runProgram(
   initial, 
   ops, 
   cost_model, 
   gas_limit?): VmResults
```

Runs a VM program against an initial stack, with an optional gas limit

## Parameters

• **initial**: [`VmStack`](../classes/VmStack.md)

• **ops**: [`Op`](../type-aliases/Op.md)\<`null`\>[]

• **cost\_model**: [`CostModel`](../classes/CostModel.md)

• **gas\_limit?**: `bigint`

## Returns

[`VmResults`](../classes/VmResults.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/sampleContractAddress.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / sampleContractAddress

# Function: sampleContractAddress()

```ts
sampleContractAddress(): ContractAddress
```

Samples a uniform contract address, for use in testing

## Returns

[`ContractAddress`](../type-aliases/ContractAddress.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/sampleSigningKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / sampleSigningKey

# Function: sampleSigningKey()

```ts
sampleSigningKey(): SigningKey
```

Randomly samples a [SigningKey](../type-aliases/SigningKey.md).

## Returns

[`SigningKey`](../type-aliases/SigningKey.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/sampleTokenType.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / sampleTokenType

# Function: sampleTokenType()

```ts
sampleTokenType(): TokenType
```

Samples a uniform token type, for use in testing

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/signatureVerifyingKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / signatureVerifyingKey

# Function: signatureVerifyingKey()

```ts
signatureVerifyingKey(sk): SignatureVerifyingKey
```

Returns the verifying key for a given signing key

## Parameters

• **sk**: `string`

## Returns

[`SignatureVerifyingKey`](../type-aliases/SignatureVerifyingKey.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/signData.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / signData

# Function: signData()

```ts
signData(key, data): Signature
```

Signs arbitrary data with the given signing key.

WARNING: Do not expose access to this function for valuable keys for data
that is not strictly controlled!

## Parameters

• **key**: `string`

• **data**: `Uint8Array`

## Returns

[`Signature`](../type-aliases/Signature.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/tokenType.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / tokenType

# Function: tokenType()

```ts
tokenType(domain_sep, contract): TokenType
```

Derives the [TokenType](../type-aliases/TokenType.md) associated with a particular
[DomainSeperator](../type-aliases/DomainSeperator.md) and contract.

## Parameters

• **domain\_sep**: `Uint8Array`

• **contract**: `string`

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/transientCommit.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / transientCommit

# Function: transientCommit()

`Internal`

```ts
transientCommit(
   align, 
   val, 
   opening): Value
```

Internal implementation of the transient commitment primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

• **opening**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align, or
opening does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/transientHash.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / transientHash

# Function: transientHash()

`Internal`

```ts
transientHash(align, val): Value
```

Internal implementation of the transient hash primitive

## Parameters

• **align**: [`Alignment`](../type-aliases/Alignment.md)

• **val**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If val does not have alignment align
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/upgradeFromTransient.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / upgradeFromTransient

# Function: upgradeFromTransient()

`Internal`

```ts
upgradeFromTransient(transient): Value
```

Internal implementation of the upgrade from transient primitive

## Parameters

• **transient**: [`Value`](../type-aliases/Value.md)

## Returns

[`Value`](../type-aliases/Value.md)

## Throws

If transient does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/valueToBigInt.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / valueToBigInt

# Function: valueToBigInt()

`Internal`

```ts
valueToBigInt(x): bigint
```

Internal conversion between field-aligned binary values and bigints within
the scalar field

## Parameters

• **x**: [`Value`](../type-aliases/Value.md)

## Returns

`bigint`

## Throws

If the value does not encode a field element
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/functions/verifySignature.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / verifySignature

# Function: verifySignature()

```ts
verifySignature(
   vk, 
   data, 
   signature): boolean
```

Verifies if a signature is correct

## Parameters

• **vk**: `string`

• **data**: `Uint8Array`

• **signature**: `string`

## Returns

`boolean`
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/AlignedValue.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / AlignedValue

# Type alias: AlignedValue

```ts
type AlignedValue: {
  alignment: Alignment;
  value: Value;
};
```

An onchain data value, in field-aligned binary format, annotated with its
alignment.

## Type declaration

### alignment

```ts
alignment: Alignment;
```

### value

```ts
value: Value;
```
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Alignment.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Alignment

# Type alias: Alignment

```ts
type Alignment: AlignmentSegment[];
```

The alignment of an onchain field-aligned binary data value.
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/AlignmentAtom.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / AlignmentAtom

# Type alias: AlignmentAtom

```ts
type AlignmentAtom: {
  tag: "compress";
  } | {
  tag: "field";
  } | {
  length: number;
  tag: "bytes";
};
```

A atom in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/AlignmentSegment.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / AlignmentSegment

# Type alias: AlignmentSegment

```ts
type AlignmentSegment: {
  tag: "option";
  value: Alignment[];
  } | {
  tag: "atom";
  value: AlignmentAtom;
};
```

A segment in a larger [Alignment](Alignment.md).
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/BlockContext.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / BlockContext

# Type alias: BlockContext

```ts
type BlockContext: {
  blockHash: string;
  secondsSinceEpoch: bigint;
  secondsSinceEpochErr: number;
};
```

The context information about a block available inside the VM

## Type declaration

### blockHash

```ts
blockHash: string;
```

The hash of the block prior to this transaction, as a hex-encoded string

### secondsSinceEpoch

```ts
secondsSinceEpoch: bigint;
```

The seconds since the UNIX epoch that have elapsed

### secondsSinceEpochErr

```ts
secondsSinceEpochErr: number;
```

The maximum error on secondsSinceEpoch that should occur, as a
positive seconds value
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/CoinCommitment.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / CoinCommitment

# Type alias: CoinCommitment

```ts
type CoinCommitment: string;
```

A Zswap coin commitment, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/CoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / CoinInfo

# Type alias: CoinInfo

```ts
type CoinInfo: {
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to create a new coin, alongside details about the
recipient

## Type declaration

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/CoinPublicKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / CoinPublicKey

# Type alias: CoinPublicKey

```ts
type CoinPublicKey: string;
```

A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
string
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/ContractAddress.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / ContractAddress

# Type alias: ContractAddress

```ts
type ContractAddress: string;
```

A contract address, as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/DomainSeperator.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / DomainSeperator

# Type alias: DomainSeperator

```ts
type DomainSeperator: Uint8Array;
```

A token domain seperator, the pre-stage of `TokenType`, as 32-byte bytearray
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Effects.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Effects

# Type alias: Effects

```ts
type Effects: {
  claimedContractCalls: [bigint, ContractAddress, string, Fr][];
  claimedNullifiers: Nullifier[];
  claimedReceives: CoinCommitment[];
  claimedSpends: CoinCommitment[];
  mints: Map<string, bigint>;
};
```

The contract-external effects of a transcript.

## Type declaration

### claimedContractCalls

```ts
claimedContractCalls: [bigint, ContractAddress, string, Fr][];
```

The contracts called from this contract. The values are, in order:

- The sequence number of this call
- The contract being called
- The entry point being called
- The communications commitment

### claimedNullifiers

```ts
claimedNullifiers: Nullifier[];
```

The nullifiers (spends) this contract call requires

### claimedReceives

```ts
claimedReceives: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
received

### claimedSpends

```ts
claimedSpends: CoinCommitment[];
```

The coin commitments (outputs) this contract call requires, as coins
sent

### mints

```ts
mints: Map<string, bigint>;
```

The tokens minted in this call, as a map from hex-encoded 256-bit domain
separators to non-negative 64-bit integers.
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/EncodedStateValue.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / EncodedStateValue

# Type alias: EncodedStateValue

```ts
type EncodedStateValue: 
  | {
  tag: "null";
  }
  | {
  content: EncodedStateValue;
  tag: "cell";
  }
  | {
  content: Map<AlignedValue, EncodedStateValue>;
  tag: "map";
  }
  | {
  content: EncodedStateValue[];
  tag: "array";
  }
  | {
  content: [number, Map<bigint, [Uint8Array, undefined]>];
  tag: "boundedMerkleTree";
};
```

An alternative encoding of [StateValue](../classes/StateValue.md) for use in [Op](Op.md) for
technical reasons
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Fr.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Fr

# Type alias: Fr

```ts
type Fr: Uint8Array;
```

An internal encoding of a value of the proof systems scalar field
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/GatherResult.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / GatherResult

# Type alias: GatherResult

```ts
type GatherResult: {
  content: AlignedValue;
  tag: "read";
  } | {
  content: EncodedStateValue;
  tag: "log";
};
```

An individual result of observing the results of a non-verifying VM program
execution
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Key.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Key

# Type alias: Key

```ts
type Key: {
  tag: "value";
  value: AlignedValue;
  } | {
  tag: "stack";
};
```

A key used to index into an array or map in the onchain VM
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Nonce.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Nonce

# Type alias: Nonce

```ts
type Nonce: string;
```

A Zswap nonce, as a hex-encoded 256-bit string
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Nullifier.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Nullifier

# Type alias: Nullifier

```ts
type Nullifier: string;
```

A Zswap nullifier, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Op.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Op

# Type alias: Op\<R\>

```ts
type Op<R>: 
  | {
  noop: {
     n: number;
  };
  }
  | "lt"
  | "eq"
  | "type"
  | "size"
  | "new"
  | "and"
  | "or"
  | "neg"
  | "log"
  | "root"
  | "pop"
  | {
  popeq: {
     cached: boolean;
     result: R;
  };
  }
  | {
  addi: {
     immediate: number;
  };
  }
  | {
  subi: {
     immediate: number;
  };
  }
  | {
  push: {
     storage: boolean;
     value: EncodedStateValue;
  };
  }
  | {
  branch: {
     skip: number;
  };
  }
  | {
  jmp: {
     skip: number;
  };
  }
  | "add"
  | "sub"
  | {
  concat: {
     cached: boolean;
     n: number;
  };
  }
  | "member"
  | {
  rem: {
     cached: boolean;
  };
  }
  | {
  dup: {
     n: number;
  };
  }
  | {
  swap: {
     n: number;
  };
  }
  | {
  idx: {
     cached: boolean;
     path: Key[];
     pushPath: boolean;
  };
  }
  | {
  ins: {
     cached: boolean;
     n: number;
  };
  }
  | "ckpt";
```

An individual operation in the onchain VM

## Type parameters

• **R**

`null` or [AlignedValue](AlignedValue.md), for gathering and verifying
mode respectively
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/QualifiedCoinInfo.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / QualifiedCoinInfo

# Type alias: QualifiedCoinInfo

```ts
type QualifiedCoinInfo: {
  mt_index: bigint;
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to spend an existing coin, alongside authorization of
the owner

## Type declaration

### mt\_index

```ts
mt_index: bigint;
```

The coin's location in the chain's Merkle tree of coin commitments

Bounded to be a non-negative 64-bit integer

### nonce

```ts
nonce: Nonce;
```

The coin's randomness, preventing it from colliding with other coins

### type

```ts
type: TokenType;
```

The coin's type, identifying the currency it represents

### value

```ts
value: bigint;
```

The coin's value, in atomic units dependent on the currency

Bounded to be a non-negative 64-bit integer
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Signature.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Signature

# Type alias: Signature

```ts
type Signature: string;
```

A hex-encoded signature BIP-340 signature, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/SignatureVerifyingKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / SignatureVerifyingKey

# Type alias: SignatureVerifyingKey

```ts
type SignatureVerifyingKey: string;
```

A hex-encoded signature BIP-340 verifying key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/SigningKey.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / SigningKey

# Type alias: SigningKey

```ts
type SigningKey: string;
```

A hex-encoded signature BIP-340 signing key, with a 3-byte version prefix
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/TokenType.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / TokenType

# Type alias: TokenType

```ts
type TokenType: string;
```

A token type (or color), as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Transcript.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Transcript

# Type alias: Transcript\<R\>

```ts
type Transcript<R>: {
  effects: Effects;
  gas: bigint;
  program: Op<R>[];
};
```

A transcript of operations, to be recorded in a transaction

## Type parameters

• **R**

## Type declaration

### effects

```ts
effects: Effects;
```

The effects of the transcript, which are checked before execution, and
must match those constructed by program

### gas

```ts
gas: bigint;
```

The execution budget for this transcript, which program must not
exceed

### program

```ts
program: Op<R>[];
```

The sequence of operations that this transcript captured
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/type-aliases/Value.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/onchain-runtime v0.2.2](../README.md) / Value

# Type alias: Value

```ts
type Value: Uint8Array[];
```

An onchain data value, in field-aligned binary format.
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/globals.md">
**@midnight-ntwrk/onchain-runtime v0.2.2** • [Readme](README.md) \| API

***

# @midnight-ntwrk/onchain-runtime v0.2.2

## Enumerations

- [NetworkId](enumerations/NetworkId.md)

## Classes

- [ContractMaintenanceAuthority](classes/ContractMaintenanceAuthority.md)
- [ContractOperation](classes/ContractOperation.md)
- [ContractState](classes/ContractState.md)
- [CostModel](classes/CostModel.md)
- [QueryContext](classes/QueryContext.md)
- [QueryResults](classes/QueryResults.md)
- [StateBoundedMerkleTree](classes/StateBoundedMerkleTree.md)
- [StateMap](classes/StateMap.md)
- [StateValue](classes/StateValue.md)
- [VmResults](classes/VmResults.md)
- [VmStack](classes/VmStack.md)

## Type Aliases

- [AlignedValue](type-aliases/AlignedValue.md)
- [Alignment](type-aliases/Alignment.md)
- [AlignmentAtom](type-aliases/AlignmentAtom.md)
- [AlignmentSegment](type-aliases/AlignmentSegment.md)
- [BlockContext](type-aliases/BlockContext.md)
- [CoinCommitment](type-aliases/CoinCommitment.md)
- [CoinInfo](type-aliases/CoinInfo.md)
- [CoinPublicKey](type-aliases/CoinPublicKey.md)
- [ContractAddress](type-aliases/ContractAddress.md)
- [DomainSeperator](type-aliases/DomainSeperator.md)
- [Effects](type-aliases/Effects.md)
- [EncodedStateValue](type-aliases/EncodedStateValue.md)
- [Fr](type-aliases/Fr.md)
- [GatherResult](type-aliases/GatherResult.md)
- [Key](type-aliases/Key.md)
- [Nonce](type-aliases/Nonce.md)
- [Nullifier](type-aliases/Nullifier.md)
- [Op](type-aliases/Op.md)
- [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md)
- [Signature](type-aliases/Signature.md)
- [SignatureVerifyingKey](type-aliases/SignatureVerifyingKey.md)
- [SigningKey](type-aliases/SigningKey.md)
- [TokenType](type-aliases/TokenType.md)
- [Transcript](type-aliases/Transcript.md)
- [Value](type-aliases/Value.md)

## Functions

- [bigIntModFr](functions/bigIntModFr.md)
- [bigIntToValue](functions/bigIntToValue.md)
- [checkProofData](functions/checkProofData.md)
- [coinCommitment](functions/coinCommitment.md)
- [decodeCoinInfo](functions/decodeCoinInfo.md)
- [decodeCoinPublicKey](functions/decodeCoinPublicKey.md)
- [decodeContractAddress](functions/decodeContractAddress.md)
- [decodeQualifiedCoinInfo](functions/decodeQualifiedCoinInfo.md)
- [decodeTokenType](functions/decodeTokenType.md)
- [degradeToTransient](functions/degradeToTransient.md)
- [dummyContractAddress](functions/dummyContractAddress.md)
- [ecAdd](functions/ecAdd.md)
- [ecMul](functions/ecMul.md)
- [ecMulGenerator](functions/ecMulGenerator.md)
- [encodeCoinInfo](functions/encodeCoinInfo.md)
- [encodeCoinPublicKey](functions/encodeCoinPublicKey.md)
- [encodeContractAddress](functions/encodeContractAddress.md)
- [encodeQualifiedCoinInfo](functions/encodeQualifiedCoinInfo.md)
- [encodeTokenType](functions/encodeTokenType.md)
- [hashToCurve](functions/hashToCurve.md)
- [leafHash](functions/leafHash.md)
- [maxAlignedSize](functions/maxAlignedSize.md)
- [maxField](functions/maxField.md)
- [persistentCommit](functions/persistentCommit.md)
- [persistentHash](functions/persistentHash.md)
- [runProgram](functions/runProgram.md)
- [sampleContractAddress](functions/sampleContractAddress.md)
- [sampleSigningKey](functions/sampleSigningKey.md)
- [sampleTokenType](functions/sampleTokenType.md)
- [signData](functions/signData.md)
- [signatureVerifyingKey](functions/signatureVerifyingKey.md)
- [tokenType](functions/tokenType.md)
- [transientCommit](functions/transientCommit.md)
- [transientHash](functions/transientHash.md)
- [upgradeFromTransient](functions/upgradeFromTransient.md)
- [valueToBigInt](functions/valueToBigInt.md)
- [verifySignature](functions/verifySignature.md)
</file>

<file path="docs/develop/reference/midnight-api/onchain-runtime/README.md">
# On-Chain runtime API

**@midnight-ntwrk/onchain-runtime v0.2.2** • Readme \| [API](globals.md)

***

# Midnight Onchain Runtime TypeScript API

This API provides a TypeScript interface to Midnight's onchain runtime,
including the execution of VM instructions, and the primitives required to
successfully use them.

Key parts of this API are:

- [ContractState](classes/ContractState.md), encapsulating the entirety of a smart contract's
  on-chain state
- [StateValue](classes/StateValue.md), encoding data a contract maintains on-chain
- [QueryContext](classes/QueryContext.md), providing an annotated view into the contract state,
  against which on-chain VM programs can be run
- [Op](type-aliases/Op.md), providing the TypeScript encoding of on-chain VM programs
- [AlignedValue](type-aliases/AlignedValue.md), the "base" value type that encodes all user data stored
  on-chain
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/interfaces/Wallet.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / Wallet

# Interface: Wallet

Wallet API

## Remarks

Wallet is a data structure that holds the state of the wallet and provides methods for proving, balancing, and submitting transactions.

## Methods

### balanceTransaction()

```ts
balanceTransaction(tx, newCoins): Promise<BalanceTransactionToProve | NothingToProve>
```

Balances the provided transaction.

#### Parameters

• **tx**: `Transaction`

Transaction to balance

• **newCoins**: `CoinInfo`[]

CoinInfo array of coins created by the transaction, which the wallet will watch for and apply to the state

The `newCoins` parameter should be used in cases where a new coin is created (for example, a DApp mints a coin and wants to send it to the wallet).
Because of how Midnight works, newly created coins must be explicitly sent to the wallet using this method. This allows the wallet to monitor them and
incorporate them into its state.

#### Returns

`Promise`\<[`BalanceTransactionToProve`](../type-aliases/BalanceTransactionToProve.md) \| [`NothingToProve`](../type-aliases/NothingToProve.md)\>

[BalanceTransactionToProve](../type-aliases/BalanceTransactionToProve.md) or [NothingToProve](../type-aliases/NothingToProve.md) recipe (for the already balanced transaction) or error.

#### Remarks

Balancing a transaction means that for any given output and transaction fees, the wallet will take the available coins
from the state to cover them.

***

### proveTransaction()

```ts
proveTransaction(recipe): Promise<Transaction>
```

Calls the proving server with the proving recipe and returns the proven transaction or error.

#### Parameters

• **recipe**: [`ProvingRecipe`](../type-aliases/ProvingRecipe.md)

[ProvingRecipe](../type-aliases/ProvingRecipe.md) with data to prove

#### Returns

`Promise`\<`Transaction`\>

Transaction or error

#### Remarks

- Proof generation takes time and resources, therefore depending on the user's computer specs, this can be an expensive operation
- There can be wallet implementations that do not need to support proving, in which case this method should return an error

***

### serializeState()

```ts
serializeState(): Promise<string>
```

Serializes and returns the current state of the wallet which contains:
- The zswap local state
- The transaction history
- The offset in the blockchain corresponding to this state
- The protocol version
- The network ID

#### Returns

`Promise`\<`string`\>

Serialized [WalletState](../type-aliases/WalletState.md) in stringified JSON format

***

### state()

```ts
state(): Observable<WalletState>
```

Observable (rx.js) stream of [WalletState](../type-aliases/WalletState.md)

#### Returns

`Observable`\<[`WalletState`](../type-aliases/WalletState.md)\>

#### Remarks

Should update every time there's a state update

***

### submitTransaction()

```ts
submitTransaction(tx): Promise<string>
```

Submits the provided transaction to the node

#### Parameters

• **tx**: `Transaction`

Transaction to submit

#### Returns

`Promise`\<`string`\>

[TransactionIdentifier](../type-aliases/TransactionIdentifier.md) - First transaction identifier from identifiers list or error

***

### transferTransaction()

```ts
transferTransaction(outputs): Promise<TransactionToProve>
```

Prepares a transfer transaction

#### Parameters

• **outputs**: [`TokenTransfer`](../type-aliases/TokenTransfer.md)[]

An array of [TokenTransfer](../type-aliases/TokenTransfer.md) a user wants to perform.

#### Returns

`Promise`\<[`TransactionToProve`](../type-aliases/TransactionToProve.md)\>

Recipe with [TransactionToProve](../type-aliases/TransactionToProve.md) or error
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/Address.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / Address

# Type alias: Address

```ts
type Address: string;
```

Bech32m encoded address
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/AddressLegacy.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / AddressLegacy

# Type alias: AddressLegacy

```ts
type AddressLegacy: string;
```

Concatenated Hex-encoded byte string

## Remarks

CoinPublicKey (32 byte hex string), EncryptionPublicKey (35 byte hex string) concatenated by "|"
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/ApplyStage.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / ApplyStage

# Type alias: ApplyStage

```ts
type ApplyStage: "FailEntirely" | "FailFallible" | "SucceedEntirely";
```

The status of the transaction

## Remarks

- FailEntirely - transaction failed and no part of it was applied
- FailFallible - the fallible part of the transaction failed, but the guaranteed part succeeded
- SucceedEntirely - transaction succeeded
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/BalanceTransactionToProve.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / BalanceTransactionToProve

# Type alias: BalanceTransactionToProve

```ts
type BalanceTransactionToProve: {
  transactionToBalance: Transaction;
  transactionToProve: UnprovenTransaction;
  type: typeof BALANCE_TRANSACTION_TO_PROVE;
};
```

Balance transaction data for proving

## Remarks

BalanceTransactionToProve is a data structure used for proving the unproven transaction (transactionToProve)
and merging it with the original transaction (transactionToBalance)

## Type declaration

### transactionToBalance

```ts
readonly transactionToBalance: Transaction;
```

Transaction which will be merged with proved `transactionToProve`.
It is a original transaction which we want to balance.

### transactionToProve

```ts
readonly transactionToProve: UnprovenTransaction;
```

Unproven transaction which needs to be proven.
Transaction which will balance the `transactionToBalance`

### type

```ts
readonly type: typeof BALANCE_TRANSACTION_TO_PROVE;
```

Used to identify the transaction type
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/CoinPublicKey.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / CoinPublicKey

# Type alias: CoinPublicKey

```ts
type CoinPublicKey: string;
```

Bech32m encoded CoinPublicKey
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/CoinPublicKeyLegacy.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / CoinPublicKeyLegacy

# Type alias: CoinPublicKeyLegacy

```ts
type CoinPublicKeyLegacy: string;
```

Hex-encoded 32-byte byte string

## Remarks

A coin public key is a public key used to identify the wallet.
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/EncPublicKeyLegacy.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / EncPublicKeyLegacy

# Type alias: EncPublicKeyLegacy

```ts
type EncPublicKeyLegacy: string;
```

35 byte hex string
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/NothingToProve.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / NothingToProve

# Type alias: NothingToProve

```ts
type NothingToProve: {
  transaction: Transaction;
  type: typeof NOTHING_TO_PROVE;
};
```

No-Op transaction data for proving

## Remarks

balanceTransaction API allows passing already balanced and proved transaction.

NothingToProve is designed to mark this special case and can be passed further to proveTransaction endpoint
without a risk of executing unnecessary proving process,
and without disturbing transaction flow with supporting special cases

## Type declaration

### transaction

```ts
readonly transaction: Transaction;
```

Original transaction

### type

```ts
readonly type: typeof NOTHING_TO_PROVE;
```

Used to identify the transaction type
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/ProvingRecipe.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / ProvingRecipe

# Type alias: ProvingRecipe

```ts
type ProvingRecipe: TransactionToProve | BalanceTransactionToProve | NothingToProve;
```

Transaction data used for proving

## Remarks

ProvingRecipe is a data structure used for proving the unproven transaction, balancing, and proving a transaction
or declaring a recipe that has no transaction to prove
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/SyncLag.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / SyncLag

# Type alias: SyncLag

```ts
type SyncLag: {
  applyGap: bigint;
  sourceGap: bigint;
};
```

Lag of the wallet syncing process.

## Type declaration

### applyGap

```ts
readonly applyGap: bigint;
```

Blocks your wallet still needs to process, if this is greater than 0, it means that your wallet is not fully synced
Formula: backend tip - last transaction index processed by your wallet

### sourceGap

```ts
readonly sourceGap: bigint;
```

Blocks the backend still needs to process, if this is greater than 0, it means that the backend is not fully synced
Formula: chain tip - backend tip
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/SyncProgress.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / SyncProgress

# Type alias: SyncProgress

```ts
type SyncProgress: {
  lag: SyncLag;
  synced: boolean;
};
```

Sync progress of the wallet

## Type declaration

### lag

```ts
lag: SyncLag;
```

Lag of the wallet syncing process

### synced

```ts
synced: boolean;
```

SyncLag.indexer === 0 && SyncLag.wallet === 0
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TokenTransfer.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TokenTransfer

# Type alias: TokenTransfer

```ts
type TokenTransfer: {
  amount: bigint;
  receiverAddress: Address;
  type: TokenType;
};
```

Data for transferring tokens

## Type declaration

### amount

```ts
readonly amount: bigint;
```

Amount of transferred tokens

#### Remarks

It is a non-negative integer, which represents the amount of tokens to be transferred. The smallest unit that can be transferred is 1.

### receiverAddress

```ts
readonly receiverAddress: Address;
```

[Address](Address.md) of receiver

### type

```ts
readonly type: TokenType;
```

[TokenType](TokenType.md) of transferred token
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TokenType.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TokenType

# Type alias: TokenType

```ts
type TokenType: string;
```

Hex-encoded 35-byte byte string

## Remarks

Token type is a unique identifier of a native token, which is used to distinguish native tokens in the network.
"tDUST" is a specific, well-know native token type.
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TransactionHash.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TransactionHash

# Type alias: TransactionHash

```ts
type TransactionHash: string;
```

Hex-encoded 32-byte bytes string

## Remarks

A transaction hash is a unique identifier of a transaction, which is used to distinguish it in the network.
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TransactionHistoryEntry.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TransactionHistoryEntry

# Type alias: TransactionHistoryEntry

```ts
type TransactionHistoryEntry: {
  applyStage: ApplyStage;
  deltas: Record<TokenType, bigint>;
  identifiers: TransactionIdentifier[];
  transaction: Transaction;
  transactionHash: TransactionHash;
};
```

Transaction history data

## Type declaration

### applyStage

```ts
readonly applyStage: ApplyStage;
```

[ApplyStage](ApplyStage.md) of the transaction

### deltas

```ts
readonly deltas: Record<TokenType, bigint>;
```

The value of this offer for each token type

#### Remarks

It contains the input coin values - output coin values, for value vectors of the transaction.
Note that this will not list any zero value coins;

### identifiers

```ts
readonly identifiers: TransactionIdentifier[];
```

An array of [TransactionIdentifier](TransactionIdentifier.md) of the transaction.

### transaction

```ts
readonly transaction: Transaction;
```

Original transaction

### transactionHash

```ts
readonly transactionHash: TransactionHash;
```

[TransactionHash](TransactionHash.md) of the transaction
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TransactionIdentifier.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TransactionIdentifier

# Type alias: TransactionIdentifier

```ts
type TransactionIdentifier: string;
```

Hex-encoded 32-byte byte string

## Remarks

The transaction identifier is used to index merged transactions.
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/TransactionToProve.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TransactionToProve

# Type alias: TransactionToProve

```ts
type TransactionToProve: {
  transaction: UnprovenTransaction;
  type: typeof TRANSACTION_TO_PROVE;
};
```

Transaction data for proving

## Remarks

TransactionToProve is a data structure used for proving the unproven transaction.

## Type declaration

### transaction

```ts
readonly transaction: UnprovenTransaction;
```

Unproven transaction which needs to be proven.

### type

```ts
readonly type: typeof TRANSACTION_TO_PROVE;
```

Used to identify the transaction type
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/type-aliases/WalletState.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / WalletState

# Type alias: WalletState

```ts
type WalletState: {
  address: Address;
  addressLegacy: AddressLegacy;
  availableCoins: QualifiedCoinInfo[];
  balances: Record<TokenType, bigint>;
  coinPublicKey: CoinPublicKey;
  coinPublicKeyLegacy: CoinPublicKeyLegacy;
  coins: QualifiedCoinInfo[];
  encryptionPublicKey: EncPublicKey;
  encryptionPublicKeyLegacy: EncPublicKeyLegacy;
  nullifiers: Nullifier[];
  pendingCoins: CoinInfo[];
  syncProgress: SyncProgress | undefined;
  transactionHistory: TransactionHistoryEntry[];
};
```

Wallet state information

## Remarks

WalletState is a data structure used for storing wallet state information, such as wallet coins, balances, transaction history, etc.

## Type declaration

### address

```ts
readonly address: Address;
```

Wallet [address](Address.md)

### addressLegacy

```ts
readonly addressLegacy: AddressLegacy;
```

Wallet [address](AddressLegacy.md)

### availableCoins

```ts
readonly availableCoins: QualifiedCoinInfo[];
```

All available wallet coins that can be spent immediately.

### balances

```ts
readonly balances: Record<TokenType, bigint>;
```

A map of balances for all available coins, where the key is a [TokenType](TokenType.md) and the value is a balance.
Note that this won't list any zero balance coins

### coinPublicKey

```ts
readonly coinPublicKey: CoinPublicKey;
```

Wallet [CoinPublicKey](CoinPublicKey.md)

### coinPublicKeyLegacy

```ts
readonly coinPublicKeyLegacy: CoinPublicKeyLegacy;
```

Wallet [CoinPublicKeyLegacy](CoinPublicKeyLegacy.md)

### coins

```ts
readonly coins: QualifiedCoinInfo[];
```

All wallet coins (including those which are pending to spend)

### encryptionPublicKey

```ts
readonly encryptionPublicKey: EncPublicKey;
```

Wallet EncryptionPublicKey

### encryptionPublicKeyLegacy

```ts
readonly encryptionPublicKeyLegacy: EncPublicKeyLegacy;
```

Wallet [EncPublicKeyLegacy](EncPublicKeyLegacy.md)

### nullifiers

```ts
readonly nullifiers: Nullifier[];
```

Nullifiers corresponding to the coins.
For `0 <= i < coins.length`,  nullifiers[i] corresponds to coins[i]

### pendingCoins

```ts
readonly pendingCoins: CoinInfo[];
```

The coins the wallet is expecting to receive in the future, but which are not yet available for spending

### syncProgress

```ts
readonly syncProgress: SyncProgress | undefined;
```

[SyncProgress](SyncProgress.md) of the wallet

It can be undefined when wallet is started and if it is not syncing

### transactionHistory

```ts
readonly transactionHistory: TransactionHistoryEntry[];
```

Transaction history - an array of [TransactionHistoryEntry](TransactionHistoryEntry.md) sorted from the oldest one to the newest one.
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/variables/BALANCE_TRANSACTION_TO_PROVE.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / BALANCE\_TRANSACTION\_TO\_PROVE

# Variable: BALANCE\_TRANSACTION\_TO\_PROVE

```ts
const BALANCE_TRANSACTION_TO_PROVE: "BalanceTransactionToProve" = 'BalanceTransactionToProve';
```

Proving recipe identifier type for BalanceTransactionToProve
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/variables/NOTHING_TO_PROVE.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / NOTHING\_TO\_PROVE

# Variable: NOTHING\_TO\_PROVE

```ts
const NOTHING_TO_PROVE: "NothingToProve" = 'NothingToProve';
```

Proving recipe identifier type for NothingToProve
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/variables/TRANSACTION_TO_PROVE.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight-ntwrk/wallet-api v5.0.0](../README.md) / TRANSACTION\_TO\_PROVE

# Variable: TRANSACTION\_TO\_PROVE

```ts
const TRANSACTION_TO_PROVE: "TransactionToProve" = 'TransactionToProve';
```

Proving recipe identifier type for TransactionToProve
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/globals.md">
**@midnight-ntwrk/wallet-api v5.0.0** • [Readme](README.md) \| API

***

# @midnight-ntwrk/wallet-api v5.0.0

## Interfaces

- [Wallet](interfaces/Wallet.md)

## Type Aliases

- [Address](type-aliases/Address.md)
- [AddressLegacy](type-aliases/AddressLegacy.md)
- [ApplyStage](type-aliases/ApplyStage.md)
- [BalanceTransactionToProve](type-aliases/BalanceTransactionToProve.md)
- [CoinPublicKey](type-aliases/CoinPublicKey.md)
- [CoinPublicKeyLegacy](type-aliases/CoinPublicKeyLegacy.md)
- [EncPublicKeyLegacy](type-aliases/EncPublicKeyLegacy.md)
- [NothingToProve](type-aliases/NothingToProve.md)
- [ProvingRecipe](type-aliases/ProvingRecipe.md)
- [SyncLag](type-aliases/SyncLag.md)
- [SyncProgress](type-aliases/SyncProgress.md)
- [TokenTransfer](type-aliases/TokenTransfer.md)
- [TokenType](type-aliases/TokenType.md)
- [TransactionHash](type-aliases/TransactionHash.md)
- [TransactionHistoryEntry](type-aliases/TransactionHistoryEntry.md)
- [TransactionIdentifier](type-aliases/TransactionIdentifier.md)
- [TransactionToProve](type-aliases/TransactionToProve.md)
- [WalletState](type-aliases/WalletState.md)

## Variables

- [BALANCE\_TRANSACTION\_TO\_PROVE](variables/BALANCE_TRANSACTION_TO_PROVE.md)
- [NOTHING\_TO\_PROVE](variables/NOTHING_TO_PROVE.md)
- [TRANSACTION\_TO\_PROVE](variables/TRANSACTION_TO_PROVE.md)
</file>

<file path="docs/develop/reference/midnight-api/wallet-api/README.md">
# Wallet API

**@midnight-ntwrk/wallet-api v5.0.0** • Readme \| [API](globals.md)

***

# Midnight Wallet API

This API provides a comprehensive interface for wallet operations, defining the structure of the wallet state, the methods for interacting with it, and the types and variables used within. It is implemented by the `@midnight-ntwrk/wallet` package.

See the [Midnight wallet developer guide](https://docs.midnight.network/develop/guides/wallet-dev-guide) for implementation and usage information.
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/AuthorizedMint.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / AuthorizedMint

# Class: AuthorizedMint

A request to mint a coin, authorized by the mint's recipient

## Constructors

### new AuthorizedMint()

```ts
private new AuthorizedMint(): AuthorizedMint
```

#### Returns

[`AuthorizedMint`](AuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### erase\_proof()

```ts
erase_proof(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): AuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`AuthorizedMint`](AuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/EncryptionSecretKey.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / EncryptionSecretKey

# Class: EncryptionSecretKey

Holds the encryption secret key of a user, which may be used to determine if
a given offer contains outputs addressed to this user

## Constructors

### new EncryptionSecretKey()

```ts
private new EncryptionSecretKey(): EncryptionSecretKey
```

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)

## Methods

### test()

```ts
test(offer): boolean
```

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

`boolean`

***

### yesIKnowTheSecurityImplicationsOfThis\_serialize()

```ts
yesIKnowTheSecurityImplicationsOfThis_serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### deserialize()

```ts
static deserialize(raw, netid): EncryptionSecretKey
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/Input.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Input

# Class: Input

A shielded transaction input

## Constructors

### new Input()

```ts
private new Input(): Input
```

#### Returns

[`Input`](Input.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Input
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Input`](Input.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/LedgerParameters.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / LedgerParameters

# Class: LedgerParameters

Parameters used by the Midnight ledger, including transaction fees and
bounds

## Constructors

### new LedgerParameters()

```ts
private new LedgerParameters(): LedgerParameters
```

#### Returns

[`LedgerParameters`](LedgerParameters.md)

## Properties

### transactionCostModel

```ts
readonly transactionCostModel: TransactionCostModel;
```

The cost model used for transaction fees contained in these parameters

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): LedgerParameters
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`LedgerParameters`](LedgerParameters.md)

***

### dummyParameters()

```ts
static dummyParameters(): LedgerParameters
```

A dummy set of testing parameters

#### Returns

[`LedgerParameters`](LedgerParameters.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/LocalState.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / LocalState

# Class: LocalState

The local state of a user/wallet, consisting of their secret key, and a set
of unspent coins.

It also keeps track of coins that are in-flight, either expecting to spend
or expecting to receive, and a local copy of the global coin commitment
Merkle tree to generate proofs against.

## Constructors

### new LocalState()

```ts
new LocalState(): LocalState
```

Creates a new state with a randomly sampled secret key

#### Returns

[`LocalState`](LocalState.md)

## Properties

### coinPublicKey

```ts
readonly coinPublicKey: string;
```

The coin public key of this wallet

***

### coins

```ts
readonly coins: Set<QualifiedCoinInfo>;
```

The set of *spendable* coins of this wallet

***

### encryptionPublicKey

```ts
readonly encryptionPublicKey: string;
```

The encryption public key of this wallet

***

### firstFree

```ts
readonly firstFree: bigint;
```

The first free index in the internal coin commitments Merkle tree.
This may be used to identify which merkle tree updates are necessary.

***

### pendingOutputs

```ts
readonly pendingOutputs: Map<string, CoinInfo>;
```

The outputs that this wallet is expecting to receive in the future

***

### pendingSpends

```ts
readonly pendingSpends: Map<string, QualifiedCoinInfo>;
```

The spends that this wallet is expecting to be finalized on-chain in the
future

## Methods

### apply()

```ts
apply(offer): LocalState
```

Locally applies an offer to the current state, returning the updated state

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyCollapsedUpdate()

```ts
applyCollapsedUpdate(update): LocalState
```

Applies a collapsed Merkle tree update to the current local state, fast
forwarding through the indices included in it, if it is a correct update.

The general flow for usage if Alice is in state A, and wants to ask Bob how to reach the new state B, is:
 - Find where she left off – what's her firstFree?
 - Find out where she's going – ask for Bob's firstFree.
 - Find what contents she does care about – ask Bob for the filtered
   entries she want to include proper in her tree.
 - In order, of Merkle tree indicies:
   - Insert (with `apply` offers Alice cares about).
   - Skip (with this method) sections Alice does not care about, obtaining
     the collapsed update covering the gap from Bob.
Note that `firstFree` is not included in the tree itself, and both ends of
updates *are* included.

#### Parameters

• **update**: [`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyFailed()

```ts
applyFailed(offer): LocalState
```

Locally marks an offer as failed, allowing inputs used in it to be
spendable once more.

#### Parameters

• **offer**: [`Offer`](Offer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyFailedProofErased()

```ts
applyFailedProofErased(offer): LocalState
```

Locally marks an proof-erased offer as failed, allowing inputs used in it
to be spendable once more.

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyProofErased()

```ts
applyProofErased(offer): LocalState
```

Locally applies a proof-erased offer to the current state, returning the
updated state

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyProofErasedTx()

```ts
applyProofErasedTx(tx, res): LocalState
```

Locally applies a proof-erased transaction to the current state, returning
the updated state

#### Parameters

• **tx**: [`ProofErasedTransaction`](ProofErasedTransaction.md)

• **res**: `"success"` \| `"partialSuccess"` \| `"failure"`

The result type of applying this transaction against the
ledger state

#### Returns

[`LocalState`](LocalState.md)

***

### applySystemTx()

```ts
applySystemTx(tx): LocalState
```

Locally applies a system transaction to the current state, returning the
updated state

#### Parameters

• **tx**: [`SystemTransaction`](SystemTransaction.md)

#### Returns

[`LocalState`](LocalState.md)

***

### applyTx()

```ts
applyTx(tx, res): LocalState
```

Locally applies a transaction to the current state, returning the updated
state

#### Parameters

• **tx**: [`Transaction`](Transaction.md)

• **res**: `"success"` \| `"partialSuccess"` \| `"failure"`

The result type of applying this transaction against the
ledger state

#### Returns

[`LocalState`](LocalState.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### spend()

```ts
spend(coin): [LocalState, UnprovenInput]
```

Initiates a new spend of a specific coin, outputting the corresponding
[UnprovenInput](UnprovenInput.md), and the updated state marking this coin as
in-flight.

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

#### Returns

[[`LocalState`](LocalState.md), [`UnprovenInput`](UnprovenInput.md)]

***

### spendFromOutput()

```ts
spendFromOutput(coin, output): [LocalState, UnprovenTransient]
```

Initiates a new spend of a new-yet-received output, outputting the
corresponding [UnprovenTransient](UnprovenTransient.md), and the updated state marking
this coin as in-flight.

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

#### Returns

[[`LocalState`](LocalState.md), [`UnprovenTransient`](UnprovenTransient.md)]

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### watchFor()

```ts
watchFor(coin): LocalState
```

Adds a coin to the list of coins that are expected to be received

This should be used if an output is creating a coin for this wallet, which
does not contain a ciphertext to detect it. In this case, the wallet must
know the commitment ahead of time to notice the receipt.

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

#### Returns

[`LocalState`](LocalState.md)

***

### yesIKnowTheSecurityImplicationsOfThis\_encryptionSecretKey()

```ts
yesIKnowTheSecurityImplicationsOfThis_encryptionSecretKey(): EncryptionSecretKey
```

#### Returns

[`EncryptionSecretKey`](EncryptionSecretKey.md)

***

### deserialize()

```ts
static deserialize(raw, netid): LocalState
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`LocalState`](LocalState.md)

***

### fromSeed()

```ts
static fromSeed(seed): LocalState
```

Creates a new state from a predefined random seed (which can act as a
recovery phrase)

#### Parameters

• **seed**: `Uint8Array`

#### Returns

[`LocalState`](LocalState.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/MerkleTreeCollapsedUpdate.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / MerkleTreeCollapsedUpdate

# Class: MerkleTreeCollapsedUpdate

A compact delta on the coin commitments Merkle tree, used to keep local
spending trees in sync with the global state without requiring receiving all
transactions.

## Constructors

### new MerkleTreeCollapsedUpdate(state, start, end)

```ts
new MerkleTreeCollapsedUpdate(
   state, 
   start, 
   end): MerkleTreeCollapsedUpdate
```

Create a new compact update from a non-compact state, and inclusive
`start` and `end` indices

#### Parameters

• **state**: [`ZswapChainState`](ZswapChainState.md)

• **start**: `bigint`

• **end**: `bigint`

#### Returns

[`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)

#### Throws

If the indices are out-of-bounds for the state, or `end < start`

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): MerkleTreeCollapsedUpdate
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`MerkleTreeCollapsedUpdate`](MerkleTreeCollapsedUpdate.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/Offer.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Offer

# Class: Offer

A full Zswap offer; the zswap part of a transaction

Consists of sets of [Input](Input.md)s, [Output](Output.md)s, and [Transient](Transient.md)s,
as well as a [deltas](Offer.md#deltas) vector of the transaction value

## Constructors

### new Offer()

```ts
private new Offer(): Offer
```

#### Returns

[`Offer`](Offer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: Input[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: Output[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: Transient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): Offer
```

Combine this offer with another

#### Parameters

• **other**: [`Offer`](Offer.md)

#### Returns

[`Offer`](Offer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Offer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Offer`](Offer.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/Output.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Output

# Class: Output

A shielded transaction output

## Constructors

### new Output()

```ts
private new Output(): Output
```

#### Returns

[`Output`](Output.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Output
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Output`](Output.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedAuthorizedMint.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedAuthorizedMint

# Class: ProofErasedAuthorizedMint

A request to mint a coin, authorized by the mint's recipient, with the
authorizing proof having been erased

## Constructors

### new ProofErasedAuthorizedMint()

```ts
private new ProofErasedAuthorizedMint(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedAuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedInput.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedInput

# Class: ProofErasedInput

A [Input](Input.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedInput()

```ts
private new ProofErasedInput(): ProofErasedInput
```

#### Returns

[`ProofErasedInput`](ProofErasedInput.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedInput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedInput`](ProofErasedInput.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedOffer.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedOffer

# Class: ProofErasedOffer

An [Offer](Offer.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedOffer()

```ts
private new ProofErasedOffer(): ProofErasedOffer
```

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: ProofErasedInput[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: ProofErasedOutput[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: ProofErasedTransient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): ProofErasedOffer
```

#### Parameters

• **other**: [`ProofErasedOffer`](ProofErasedOffer.md)

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedOffer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedOffer`](ProofErasedOffer.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedOutput.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedOutput

# Class: ProofErasedOutput

An [Output](Output.md) with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedOutput()

```ts
private new ProofErasedOutput(): ProofErasedOutput
```

#### Returns

[`ProofErasedOutput`](ProofErasedOutput.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedOutput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedOutput`](ProofErasedOutput.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedTransaction.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedTransaction

# Class: ProofErasedTransaction

[Transaction](Transaction.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedTransaction()

```ts
private new ProofErasedTransaction(): ProofErasedTransaction
```

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

## Properties

### fallibleCoins

```ts
readonly fallibleCoins: undefined | ProofErasedOffer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | ProofErasedOffer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | ProofErasedAuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### fees()

```ts
fees(params): bigint
```

The cost of this transaction, in the atomic unit of the base token

#### Parameters

• **params**: [`LedgerParameters`](LedgerParameters.md)

#### Returns

`bigint`

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### imbalances()

```ts
imbalances(guaranteed, fees?): Map<string, bigint>
```

For given fees, and a given section (guaranteed/fallible), what the
surplus or deficit of this transaction in any token type is.

#### Parameters

• **guaranteed**: `boolean`

• **fees?**: `bigint`

#### Returns

`Map`\<`string`, `bigint`\>

***

### merge()

```ts
merge(other): ProofErasedTransaction
```

Merges this transaction with another

#### Parameters

• **other**: [`ProofErasedTransaction`](ProofErasedTransaction.md)

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedTransaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ProofErasedTransient.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ProofErasedTransient

# Class: ProofErasedTransient

A [Transient](Transient.md), with all proof information erased

Primarily for use in testing, or handling data known to be correct from
external information

## Constructors

### new ProofErasedTransient()

```ts
private new ProofErasedTransient(): ProofErasedTransient
```

#### Returns

[`ProofErasedTransient`](ProofErasedTransient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): ProofErasedTransient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ProofErasedTransient`](ProofErasedTransient.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/SystemTransaction.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / SystemTransaction

# Class: SystemTransaction

A priviledged transaction issued by the system.

## Constructors

### new SystemTransaction()

```ts
private new SystemTransaction(): SystemTransaction
```

#### Returns

[`SystemTransaction`](SystemTransaction.md)

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Transaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transaction`](Transaction.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/Transaction.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Transaction

# Class: Transaction

A Midnight transaction, consisting a guaranteed and fallible [Offer](Offer.md),
and contract call information hidden from this API.

The guaranteed section are run first, and fee payment is taken during this
part. If it succeeds, the fallible section is also run, and atomically
rolled back if it fails.

## Constructors

### new Transaction()

```ts
private new Transaction(): Transaction
```

#### Returns

[`Transaction`](Transaction.md)

## Properties

### fallibleCoins

```ts
readonly fallibleCoins: undefined | Offer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | Offer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | AuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### eraseProofs()

```ts
eraseProofs(): ProofErasedTransaction
```

Erases the proofs contained in this transaction

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

***

### fees()

```ts
fees(params): bigint
```

The cost of this transaction, in the atomic unit of the base token

#### Parameters

• **params**: [`LedgerParameters`](LedgerParameters.md)

#### Returns

`bigint`

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### imbalances()

```ts
imbalances(guaranteed, fees?): Map<string, bigint>
```

For given fees, and a given section (guaranteed/fallible), what the
surplus or deficit of this transaction in any token type is.

#### Parameters

• **guaranteed**: `boolean`

• **fees?**: `bigint`

#### Returns

`Map`\<`string`, `bigint`\>

***

### merge()

```ts
merge(other): Transaction
```

Merges this transaction with another

#### Parameters

• **other**: [`Transaction`](Transaction.md)

#### Returns

[`Transaction`](Transaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### transactionHash()

```ts
transactionHash(): string
```

Returns the hash associated with this transaction. Due to the ability to
merge transactions, this should not be used to watch for a specific
transaction.

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Transaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transaction`](Transaction.md)

***

### fromUnproven()

```ts
static fromUnproven(prove, unproven): Promise<Transaction>
```

Type hint that you should use an external proving function, for instance
via the proof server.

#### Parameters

• **prove**

• **unproven**: [`UnprovenTransaction`](UnprovenTransaction.md)

#### Returns

`Promise`\<[`Transaction`](Transaction.md)\>
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/TransactionCostModel.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / TransactionCostModel

# Class: TransactionCostModel

## Constructors

### new TransactionCostModel()

```ts
private new TransactionCostModel(): TransactionCostModel
```

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)

## Properties

### inputFeeOverhead

```ts
readonly inputFeeOverhead: bigint;
```

The increase in fees to expect from adding a new input to a transaction

***

### outputFeeOverhead

```ts
readonly outputFeeOverhead: bigint;
```

The increase in fees to expect from adding a new output to a transaction

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): TransactionCostModel
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)

***

### dummyTransactionCostModel()

```ts
static dummyTransactionCostModel(): TransactionCostModel
```

A dummy cost model, for use in testing

#### Returns

[`TransactionCostModel`](TransactionCostModel.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/Transient.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Transient

# Class: Transient

A shielded "transient"; an output that is immediately spent within the same
transaction

## Constructors

### new Transient()

```ts
private new Transient(): Transient
```

#### Returns

[`Transient`](Transient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): Transient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`Transient`](Transient.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenAuthorizedMint.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenAuthorizedMint

# Class: UnprovenAuthorizedMint

A request to mint a coin, authorized by the mint's recipient, without the
proof for the authorization being generated

## Constructors

### new UnprovenAuthorizedMint()

```ts
private new UnprovenAuthorizedMint(): UnprovenAuthorizedMint
```

#### Returns

[`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)

## Properties

### coin

```ts
readonly coin: CoinInfo;
```

The coin to be minted

***

### recipient

```ts
readonly recipient: string;
```

The recipient of this mint

## Methods

### erase\_proof()

```ts
erase_proof(): ProofErasedAuthorizedMint
```

#### Returns

[`ProofErasedAuthorizedMint`](ProofErasedAuthorizedMint.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenAuthorizedMint
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenInput.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenInput

# Class: UnprovenInput

A [Input](Input.md), before being proven

All "shielded" information in the input can still be extracted at this
stage!

## Constructors

### new UnprovenInput()

```ts
private new UnprovenInput(): UnprovenInput
```

#### Returns

[`UnprovenInput`](UnprovenInput.md)

## Properties

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the input, if the sender is a contract

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the input

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenInput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenInput`](UnprovenInput.md)

***

### newContractOwned()

```ts
static newContractOwned(
   coin, 
   contract, 
   state): UnprovenInput
```

Creates a new input, spending a specific coin from a smart contract,
against a state which contains this coin.

Note that inputs created in this way *also* need to be authorized by the
contract

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **contract**: `string`

• **state**: [`ZswapChainState`](ZswapChainState.md)

#### Returns

[`UnprovenInput`](UnprovenInput.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenOffer.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenOffer

# Class: UnprovenOffer

A [Offer](Offer.md), prior to being proven

All "shielded" information in the offer can still be extracted at this
stage!

## Constructors

### new UnprovenOffer()

```ts
new UnprovenOffer(): UnprovenOffer
```

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

## Properties

### deltas

```ts
readonly deltas: Map<string, bigint>;
```

The value of this offer for each token type; note that this may be
negative

This is input coin values - output coin values, for value vectors

***

### inputs

```ts
readonly inputs: UnprovenInput[];
```

The inputs this offer is composed of

***

### outputs

```ts
readonly outputs: UnprovenOutput[];
```

The outputs this offer is composed of

***

### transient

```ts
readonly transient: UnprovenTransient[];
```

The transients this offer is composed of

## Methods

### merge()

```ts
merge(other): UnprovenOffer
```

Combine this offer with another

#### Parameters

• **other**: [`UnprovenOffer`](UnprovenOffer.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenOffer
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromInput()

```ts
static fromInput(
   input, 
   type_, 
   value): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenInput](UnprovenInput.md) and its value
vector

#### Parameters

• **input**: [`UnprovenInput`](UnprovenInput.md)

• **type\_**: `string`

• **value**: `bigint`

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromOutput()

```ts
static fromOutput(
   output, 
   type_, 
   value): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenOutput](UnprovenOutput.md) and its value
vector

#### Parameters

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

• **type\_**: `string`

• **value**: `bigint`

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)

***

### fromTransient()

```ts
static fromTransient(transient): UnprovenOffer
```

Creates a singleton offer, from an [UnprovenTransient](UnprovenTransient.md)

#### Parameters

• **transient**: [`UnprovenTransient`](UnprovenTransient.md)

#### Returns

[`UnprovenOffer`](UnprovenOffer.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenOutput.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenOutput

# Class: UnprovenOutput

An [Output](Output.md) before being proven

All "shielded" information in the output can still be extracted at this
stage!

## Constructors

### new UnprovenOutput()

```ts
private new UnprovenOutput(): UnprovenOutput
```

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the output

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address receiving the output, if the recipient is a contract

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenOutput
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

***

### new()

```ts
static new(
   coin, 
   target_cpk, 
   target_epk?): UnprovenOutput
```

Creates a new output, targeted to a user's coin public key.

Optionally the output contains a ciphertext encrypted to the user's
encryption public key, which may be omitted *only* if the [CoinInfo](../type-aliases/CoinInfo.md)
is transferred to the recipient another way

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

• **target\_cpk**: `string`

• **target\_epk?**: `string`

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)

***

### newContractOwned()

```ts
static newContractOwned(coin, contract): UnprovenOutput
```

Creates a new output, targeted to a smart contract

A contract must *also* explicitly receive a coin created in this way for
the output to be valid

#### Parameters

• **coin**: [`CoinInfo`](../type-aliases/CoinInfo.md)

• **contract**: `string`

#### Returns

[`UnprovenOutput`](UnprovenOutput.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenTransaction.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenTransaction

# Class: UnprovenTransaction

[Transaction](Transaction.md), prior to being proven

All "shielded" information in the transaction can still be extracted at this
stage!

## Constructors

### new UnprovenTransaction(guaranteed, fallible)

```ts
new UnprovenTransaction(guaranteed, fallible?): UnprovenTransaction
```

Creates the transaction from guaranteed/fallible [UnprovenOffer](UnprovenOffer.md)s

#### Parameters

• **guaranteed**: [`UnprovenOffer`](UnprovenOffer.md)

• **fallible?**: [`UnprovenOffer`](UnprovenOffer.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

## Properties

### fallibleCoins

```ts
readonly fallibleCoins: undefined | UnprovenOffer;
```

The fallible Zswap offer

***

### guaranteedCoins

```ts
readonly guaranteedCoins: undefined | UnprovenOffer;
```

The guaranteed Zswap offer

***

### mint

```ts
readonly mint: undefined | UnprovenAuthorizedMint;
```

The mint this transaction represents, if applicable

## Methods

### eraseProofs()

```ts
eraseProofs(): ProofErasedTransaction
```

Erases the proofs contained in this transaction

#### Returns

[`ProofErasedTransaction`](ProofErasedTransaction.md)

***

### identifiers()

```ts
identifiers(): string[]
```

Returns the set of identifiers contained within this transaction. Any of
these *may* be used to watch for a specific transaction.

#### Returns

`string`[]

***

### merge()

```ts
merge(other): UnprovenTransaction
```

Merges this transaction with another

#### Parameters

• **other**: [`UnprovenTransaction`](UnprovenTransaction.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

#### Throws

If both transactions have contract interactions, or they spend the
same coins

***

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenTransaction
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)

***

### fromMint()

```ts
static fromMint(mint): UnprovenTransaction
```

Creates a minting claim transaction, the funds claimed must have been
legitimately minted previously.

#### Parameters

• **mint**: [`UnprovenAuthorizedMint`](UnprovenAuthorizedMint.md)

#### Returns

[`UnprovenTransaction`](UnprovenTransaction.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/UnprovenTransient.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / UnprovenTransient

# Class: UnprovenTransient

A [Transient](Transient.md), before being proven

All "shielded" information in the transient can still be extracted at this
stage!

## Constructors

### new UnprovenTransient()

```ts
private new UnprovenTransient(): UnprovenTransient
```

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)

## Properties

### commitment

```ts
readonly commitment: string;
```

The commitment of the transient

***

### contractAddress

```ts
readonly contractAddress: undefined | string;
```

The contract address creating the transient, if applicable

***

### nullifier

```ts
readonly nullifier: string;
```

The nullifier of the transient

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### deserialize()

```ts
static deserialize(raw, netid): UnprovenTransient
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)

***

### newFromContractOwnedOutput()

```ts
static newFromContractOwnedOutput(coin, output): UnprovenTransient
```

Creates a new contract-owned transient, from a given output and its coin.

The [QualifiedCoinInfo](../type-aliases/QualifiedCoinInfo.md) should have an `mt_index` of `0`

#### Parameters

• **coin**: [`QualifiedCoinInfo`](../type-aliases/QualifiedCoinInfo.md)

• **output**: [`UnprovenOutput`](UnprovenOutput.md)

#### Returns

[`UnprovenTransient`](UnprovenTransient.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/classes/ZswapChainState.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ZswapChainState

# Class: ZswapChainState

The on-chain state of Zswap, consisting of a Merkle tree of coin
commitments, a set of nullifiers, an index into the Merkle tree, and a set
of valid past Merkle tree roots

## Constructors

### new ZswapChainState()

```ts
new ZswapChainState(): ZswapChainState
```

#### Returns

[`ZswapChainState`](ZswapChainState.md)

## Properties

### firstFree

```ts
readonly firstFree: bigint;
```

The first free index in the coin commitment tree

## Methods

### serialize()

```ts
serialize(netid): Uint8Array
```

#### Parameters

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

`Uint8Array`

***

### toString()

```ts
toString(compact?): string
```

#### Parameters

• **compact?**: `boolean`

#### Returns

`string`

***

### tryApply()

```ts
tryApply(offer, whitelist?): [ZswapChainState, Map<string, bigint>]
```

Try to apply an [Offer](Offer.md) to the state, returning the updated state
and a map on newly inserted coin commitments to their inserted indices.

#### Parameters

• **offer**: [`Offer`](Offer.md)

• **whitelist?**: `Set`\<`string`\>

A set of contract addresses that are of interest. If
set, *only* these addresses are tracked, and all other information is
discarded.

#### Returns

[[`ZswapChainState`](ZswapChainState.md), `Map`\<`string`, `bigint`\>]

***

### tryApplyProofErased()

```ts
tryApplyProofErased(offer, whitelist?): [ZswapChainState, Map<string, bigint>]
```

[tryApply](ZswapChainState.md#tryapply) for [ProofErasedOffer](ProofErasedOffer.md)s

#### Parameters

• **offer**: [`ProofErasedOffer`](ProofErasedOffer.md)

• **whitelist?**: `Set`\<`string`\>

#### Returns

[[`ZswapChainState`](ZswapChainState.md), `Map`\<`string`, `bigint`\>]

***

### deserialize()

```ts
static deserialize(raw, netid): ZswapChainState
```

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ZswapChainState`](ZswapChainState.md)

***

### deserializeFromLedgerState()

```ts
static deserializeFromLedgerState(raw, netid): ZswapChainState
```

Given a whole ledger serialized state, deserialize only the Zswap portion

#### Parameters

• **raw**: `Uint8Array`

• **netid**: [`NetworkId`](../enumerations/NetworkId.md)

#### Returns

[`ZswapChainState`](ZswapChainState.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/enumerations/NetworkId.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / NetworkId

# Enumeration: NetworkId

The network currently being targeted

## Enumeration Members

### DevNet

```ts
DevNet: 1;
```

A developer network, not guaranteed to be persistent

***

### MainNet

```ts
MainNet: 3;
```

The Midnight mainnet

***

### TestNet

```ts
TestNet: 2;
```

A persistent testnet

***

### Undeployed

```ts
Undeployed: 0;
```

A local test network
</file>

<file path="docs/develop/reference/midnight-api/zswap/functions/createCoinInfo.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / createCoinInfo

# Function: createCoinInfo()

```ts
createCoinInfo(type_, value): CoinInfo
```

Creates a new [CoinInfo](../type-aliases/CoinInfo.md), sampling a uniform nonce

## Parameters

• **type\_**: `string`

• **value**: `bigint`

## Returns

[`CoinInfo`](../type-aliases/CoinInfo.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/functions/nativeToken.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / nativeToken

# Function: nativeToken()

```ts
nativeToken(): TokenType
```

The base/system token type

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/functions/sampleCoinPublicKey.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / sampleCoinPublicKey

# Function: sampleCoinPublicKey()

```ts
sampleCoinPublicKey(): CoinPublicKey
```

Samples a dummy user coin public key, for use in testing

## Returns

[`CoinPublicKey`](../type-aliases/CoinPublicKey.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/functions/sampleContractAddress.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / sampleContractAddress

# Function: sampleContractAddress()

```ts
sampleContractAddress(): ContractAddress
```

Samples a uniform contract address, for use in testing

## Returns

[`ContractAddress`](../type-aliases/ContractAddress.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/functions/sampleTokenType.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / sampleTokenType

# Function: sampleTokenType()

```ts
sampleTokenType(): TokenType
```

Samples a uniform token type, for use in testing

## Returns

[`TokenType`](../type-aliases/TokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/CoinCommitment.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / CoinCommitment

# Type alias: CoinCommitment

```ts
type CoinCommitment: string;
```

A Zswap coin commitment, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/CoinInfo.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / CoinInfo

# Type alias: CoinInfo

```ts
type CoinInfo: {
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to create a new coin, alongside details about the
recipient

## Type declaration

### nonce

```ts
nonce: Nonce;
```

### type

```ts
type: TokenType;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/CoinPublicKey.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / CoinPublicKey

# Type alias: CoinPublicKey

```ts
type CoinPublicKey: string;
```

A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
string
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/ContractAddress.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / ContractAddress

# Type alias: ContractAddress

```ts
type ContractAddress: string;
```

A contract address, as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/EncPublicKey.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / EncPublicKey

# Type alias: EncPublicKey

```ts
type EncPublicKey: string;
```

An encryption public key, used to inform users of new coins sent to them
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/Nonce.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Nonce

# Type alias: Nonce

```ts
type Nonce: string;
```

A Zswap nonce, as a hex-encoded 256-bit string
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/Nullifier.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / Nullifier

# Type alias: Nullifier

```ts
type Nullifier: string;
```

A Zswap nullifier, as a hex-encoded 256-bit bitstring
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/QualifiedCoinInfo.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / QualifiedCoinInfo

# Type alias: QualifiedCoinInfo

```ts
type QualifiedCoinInfo: {
  mt_index: bigint;
  nonce: Nonce;
  type: TokenType;
  value: bigint;
};
```

Information required to spend an existing coin, alongside authorization of
the owner

## Type declaration

### mt\_index

```ts
mt_index: bigint;
```

### nonce

```ts
nonce: Nonce;
```

### type

```ts
type: TokenType;
```

### value

```ts
value: bigint;
```
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/TokenType.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / TokenType

# Type alias: TokenType

```ts
type TokenType: string;
```

A token type (or color), as a hex-encoded 35-byte string
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/TransactionHash.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / TransactionHash

# Type alias: TransactionHash

```ts
type TransactionHash: string;
```

The hash of a transaction, as a hex-encoded 256-bit bytestring
</file>

<file path="docs/develop/reference/midnight-api/zswap/type-aliases/TransactionId.md">
**@midnight/zswap v3.0.2** • [Readme](../README.md) \| [API](../globals.md)

***

[@midnight/zswap v3.0.2](../README.md) / TransactionId

# Type alias: TransactionId

```ts
type TransactionId: string;
```

A transaction identifier, used to index merged transactions
</file>

<file path="docs/develop/reference/midnight-api/zswap/globals.md">
**@midnight/zswap v3.0.2** • [Readme](README.md) \| API

***

# @midnight/zswap v3.0.2

## Enumerations

- [NetworkId](enumerations/NetworkId.md)

## Classes

- [AuthorizedMint](classes/AuthorizedMint.md)
- [EncryptionSecretKey](classes/EncryptionSecretKey.md)
- [Input](classes/Input.md)
- [LedgerParameters](classes/LedgerParameters.md)
- [LocalState](classes/LocalState.md)
- [MerkleTreeCollapsedUpdate](classes/MerkleTreeCollapsedUpdate.md)
- [Offer](classes/Offer.md)
- [Output](classes/Output.md)
- [ProofErasedAuthorizedMint](classes/ProofErasedAuthorizedMint.md)
- [ProofErasedInput](classes/ProofErasedInput.md)
- [ProofErasedOffer](classes/ProofErasedOffer.md)
- [ProofErasedOutput](classes/ProofErasedOutput.md)
- [ProofErasedTransaction](classes/ProofErasedTransaction.md)
- [ProofErasedTransient](classes/ProofErasedTransient.md)
- [SystemTransaction](classes/SystemTransaction.md)
- [Transaction](classes/Transaction.md)
- [TransactionCostModel](classes/TransactionCostModel.md)
- [Transient](classes/Transient.md)
- [UnprovenAuthorizedMint](classes/UnprovenAuthorizedMint.md)
- [UnprovenInput](classes/UnprovenInput.md)
- [UnprovenOffer](classes/UnprovenOffer.md)
- [UnprovenOutput](classes/UnprovenOutput.md)
- [UnprovenTransaction](classes/UnprovenTransaction.md)
- [UnprovenTransient](classes/UnprovenTransient.md)
- [ZswapChainState](classes/ZswapChainState.md)

## Type Aliases

- [CoinCommitment](type-aliases/CoinCommitment.md)
- [CoinInfo](type-aliases/CoinInfo.md)
- [CoinPublicKey](type-aliases/CoinPublicKey.md)
- [ContractAddress](type-aliases/ContractAddress.md)
- [EncPublicKey](type-aliases/EncPublicKey.md)
- [Nonce](type-aliases/Nonce.md)
- [Nullifier](type-aliases/Nullifier.md)
- [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md)
- [TokenType](type-aliases/TokenType.md)
- [TransactionHash](type-aliases/TransactionHash.md)
- [TransactionId](type-aliases/TransactionId.md)

## Functions

- [createCoinInfo](functions/createCoinInfo.md)
- [nativeToken](functions/nativeToken.md)
- [sampleCoinPublicKey](functions/sampleCoinPublicKey.md)
- [sampleContractAddress](functions/sampleContractAddress.md)
- [sampleTokenType](functions/sampleTokenType.md)
</file>

<file path="docs/develop/reference/midnight-api/zswap/README.md">
# ZSwap API

**@midnight/zswap v3.0.2** • Readme \| [API](globals.md)

***

# Zswap TypeScript API

This document outlines the usage of the Zswap TS API

## Network ID

Prior to any interaction, setNetworkId should be used to set the [NetworkId](enumerations/NetworkId.md) to target the correct network.

## Proof stages

Most transaction components will be in one of three stages: `X`, `UnprovenX`,
or `ProofErasedX`. The `UnprovenX` stage is _always_ the first one. It is
possible to transition to the `X` stage by proving an `UnprovenTransaction`
through the proof server. For testing, and where proofs aren't necessary, the
`ProofErasedX` stage is used, which can be reached via `eraseProof[s]` from the
other two stages.

## Transaction structure

A [Transaction](classes/Transaction.md) runs in two phases: a _guaranteed_ phase, handling fee payments
and fast-to-verify operations, and a _fallible_ phase, handling operations
which may fail atomically, separately from the guaranteed phase. It therefore
contains:

* A "guaranteed" [Offer](classes/Offer.md)
* Optionally, a "fallible" [Offer](classes/Offer.md)
* Contract call information not accessible to this API

It also contains additional cryptographic glue that will be omitted in this
document.

### Zswap

A Zswap [Offer](classes/Offer.md) consists of:
* A set of [Input](classes/Input.md)s, burning coins.
* A set of [Output](classes/Output.md)s, creating coins.
* A set of [Transient](classes/Transient.md)s, indicating a coin that is created and burnt in
  the same transaction.
* A mapping from [TokenType](type-aliases/TokenType.md)s to offer balance, positive when there are more
  inputs than outputs and vice versa.

[Input](classes/Input.md)s can be created either from a [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) and a contract
address, if the coin is contract-owned, or from a [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) and a
ZswapLocalState, if it is user-owned. Similarly, [Output](classes/Output.md)s can be created
from a [CoinInfo](type-aliases/CoinInfo.md) and a contract address for contract-owned coins, or from a
[CoinInfo](type-aliases/CoinInfo.md) and a user's public key(s), if it is user-owned. A [Transient](classes/Transient.md)
is created similarly to a [Input](classes/Input.md), but directly converts an existing
[Output](classes/Output.md).

A [QualifiedCoinInfo](type-aliases/QualifiedCoinInfo.md) is a [CoinInfo](type-aliases/CoinInfo.md) with an index into the Merkle tree of
coin commitments that can be used to find the relevant coin to spend, while a
[CoinInfo](type-aliases/CoinInfo.md) consists of a coins [TokenType](type-aliases/TokenType.md), value, and a nonce.

## State Structure

[ZswapChainState](classes/ZswapChainState.md) holds the on-chain state of Zswap, while ZswaplocalState contains the local, wallet state.
</file>

<file path="docs/develop/reference/midnight-api/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Midnight APIs

Collection of Midnight APIs:

- [Compact runtime API](compact-runtime/README.md)

- [DApp connector API](dapp-connector/README.md)

- [Ledger API](ledger/README.md)

- [Midnight JS API](midnight-js/README.md)

- [On-Chain runtime API](onchain-runtime/README.md)

- [Midnight Indexer API](midnight-indexer/README.md)

- [Wallet API](wallet-api/README.md)

- [ZSwap API](zswap/README.md)
</file>

<file path="docs/develop/reference/tools/vsc-plugin/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Visual Studio Code extension for Compact

The [Visual Studio Code extension] for Compact is a plugin
that assists with writing and debugging smart contracts written in Midnight's Compact language.

DApp developers can create new smart contracts
* using a file template
* from scratch, optionally using code snippets.

## Features

### Syntax highlighting

Smart contracts are written in the Compact language.  The following language elements
will be recognized and formatted:
* Compact keywords, such as `enum`, `struct`, and `circuit`
* string, boolean, and numeric literals
* comments
* parentheses

![Syntax highlighting](/img/vsc-plugin/compact-syntax.png)

### Building Compact source files and error highlighting

For building smart contracts, you will typically want to add a script definition in `package.json`, like so:
```json
"scripts": {
  "compact": "compact compile --vscode ./src/myContract.compact ./src/managed/myContract"
}
```
The preceding assumes that the Compact compiler is on the shell's command search path 
(if it isn't, follow the instructions provided in [Running Midnight Compact compiler](../../../../develop/tutorial/building/counter-build#compile-the-code)). It also uses the Compact compiler's --vscode option to omit newlines in error messages, so that they render properly inside the VS Code environment.

This allows you to compile your smart contract using:
```shell
yarn compact
```

When you edit complex contracts, and you want to have fast interactions, it is more convenient to 
add a [task file](https://code.visualstudio.com/docs/editor/tasks) `.vscode/tasks.json` configured like this:
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Compile compact file to JS",
      "type": "shell",
      "command": "npx compact compile --vscode --skip-zk ${file} ${workspaceFolder}/src/managed",
      "group": "build",
      "presentation": {
        "echo": true,
        "reveal": "never",
        "focus": false,
        "panel": "shared",
        "showReuseMessage": false,
        "clear": true,
        "revealProblems": "onProblem"
      },
      "problemMatcher": [
        "$compactException",
        "$compactInternal",
        "$compactCommandNotFound"
      ]
    }
  ]
}
```

The preceding configuration uses the
Compact compiler flag `--skip-zk` to skip the generation of circuits,
which can take a long time and may be unnecessary when you only want
to the compiler to check your syntax.

Moreover, you can configure a `problemMatcher` for VS Code:
```json
 "problemMatcher": [
     "$compactException",
     "$compactInternal",
     "$compactCommandNotFound"
 ]
```
so that all errors reported by the compiler will be shown on the **Problems** tab.

### Code snippets

The VS Code extension provides the following [code snippets](https://code.visualstudio.com/docs/editor/userdefinedsnippets) when editing Compact smart contracts:
* `ledger` (`state`)
* `constructor` in ledger
* potentially exported `circuit` (`function` / `transition`)
* `witness` (`private` function)
* constructor
* import Compact `standard library` (`init`, `stdlib`)
* `if` statement (`cond`)
* `map` (`for`)
* `fold`
* `enum`
* `struct`
* `module`
* `assert`
* `pragma`

There is also a `compact` template, which will generate a simple Compact skeleton for a contract.

![Code snippets and errors](/img/vsc-plugin/code-snippets-errors.gif)

### New Compact smart contract

If you are creating DApp, you can create a new smart contract 
with an empty ledger and a single circuit as follows:
1. Bring up the commands pallette (Cmd+Shift+P).
2. Select **Snippets: Fill File with Snippet**.
3. Select **Compact**.
Be aware: if you perform these steps in an existing file, the contents of the file are overwritten.
Other snippets are available from inside the file. Just start typing the name of the function.

![File template](/img/vsc-plugin/file-template.gif)

## License

The Visual Studio Code extension for Compact is distributed under the Apache 2.0 license.
</file>

<file path="docs/develop/reference/tools/compiler-usage.mdx">
Compact Compiler Manual Page
============================

NAME
====

compactc

OVERVIEW
========

The Compact compiler, **compactc**, takes as input a Compact source
program in a specified source file and translates it into several
target files in a specified directory.

SYNOPSYS
========

**compactc** _flag_ **...** _sourcepath_ _targetpath_

DESCRIPTION
===========

The flags _flag_ **...** are optional.  They are described under FLAGS later in this document.

_sourcepath_ should identify a file containing a Compact source program, and
_targetpath_ should identify a target directory into which the target files are to be placed.
The target directory is created if it does not already exist.

**compactc** compiles the source file and produces from it the following target files,
where _sourceroot_ is the name of the file identified by _sourcepath_ without any
extension.

- a Typescript type-definition file _targetdir_**/contract/index.d.cts**

- a Javascript source file _targetdir_**/contract/index.cjs**

- a Javascript source-map file _targetdir_**/contract/index.cjs.map**

- one Zk/ir circuit file for each exported circuit _circuitname_
  in _targetdir_**/zkir/**_circuitname_**.zkir**,
  and

- a pair of proving keys for each exported circuit _circuitname_
  in _targetdir_**/keys/**_circuitname_**.prover** and
  _targetdir_**/keys/**_circuitname_**.verifier**.

Compact source files can include other Compact source files via an **include** form:

**include** '_name_';

They can also import externally defined modules via an **import** form:

**import** _name_;
**import** '_name_';

By default, the compiler looks for include files and externally defined modules
in the current working directory under the full filename _name_**.compact**.
When the environment variable **COMPACT_PATH** is set to a colon-separated
(semicolon-separated on Windows) list of directory pathnames
_dirpath_**:...:**_dirpath_ (_dirpath_**;...;**_dirpath_ under Windows), the
compiler looks instead 
under the full pathname _dirpath_**/**_name_**.compact** for each
_dirpath_ until the file is found or the set of _dirpath_ entries
is exhausted.

Every Compact source program should import the standard library **CompactStandardLibrary**.
This is typically done by placing the following line at the top of the program:

**import CompactStandardLibrary;** 

FLAGS
=====

The following flags, if present, affect the compiler's behavior as follows:

**--help**

prints help text and exits.

**--version**

prints the compiler version and exits.

**--language-version**

prints the language version and exits.

**--vscode**

causes the compiler to omit newlines from error messages, so that they are rendered
properly within the VS Code extension for Compact.

**--skip-zk**

causes the compiler to skip the generation of proving keys.
Generating proving keys can be time-consuming, so this option is useful
when debugging only the Typescript output.  The compiler also skips,
after printing a warning message, the generation of proving keys when
it cannot find zkir.

**--no-communications-commitment**

omits the contract communications commitment that enables data integrity for contract-to-contract calls.

**--sourceRoot _sourceRoot-value_**

overrides the compiler's setting of the
sourceRoot field in the generated source-map (.cjs.map) file.  By default,
the compiler tries to determine a useful value based on the source and
target-directory pathnames, but this value might not be appropriate for
the deployed structure of the application.

**--trace-passes**

causes the compiler to print tracing information that is
generally useful only to compiler developers.

EXAMPLES
========

Assuming **src/test.compact** contains a well-formed Compact program exporting circuits *foo*
and *bar*:

```
compactc src/test.compact obj/test
```

produces:

```
obj/test/contract/index.d.cts
obj/test/contract/index.cjs
obj/test/contract/index.cjs.map

obj/test/zkir/foo.zkir
obj/test/zkir/bar.zkir

obj/test/keys/foo.prover
obj/test/keys/foo.verifier
obj/test/keys/bar.prover
obj/test/keys/bar.verifier
```

**compactc --skip-zk src/test.compact obj/test**

produces the same, except without the keys.
</file>

<file path="docs/develop/reference/tools/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Tools
</file>

<file path="docs/develop/reference/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Reference documentation

This part of the Midnight documentation provides reference materials covering the Compact language, TypeScript APIs, and tools provided by the Midnight team.  It includes:

- [The Compact language](/docs/develop/reference/compact/index.mdx), providing details on using
  Compact, including a [tutorial on writing smart contracts](/docs/develop/reference/compact/writing.mdx).
- [Midnight APIs](/docs/develop/reference/midnight-api/index.mdx), describing the application
  programming interfaces of various libraries available for Midnight developers.
- [Tools](/docs/develop/reference/tools/index.mdx), providing usage details for some of the developer
  tools, including the Visual Studio Code extension for Compact and the manual
  page for the Compact compiler.
</file>

<file path="docs/develop/tutorial/1-using/chrome-ext.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Lace wallet"
---

# Lace wallet

The Lace wallet is a Chrome extension.

:::important Chrome browser

You must use the Chrome web browser or its derivatives to complete
web-based transactions on the Midnight testnet.

Only the Chrome browser itself is fully supported. The Lace
wallet may not be able to connect to your local proof server from
Chrome derivatives. If you choose to use Brave, for example, it will
be necessary to disable Brave shields when running this tutorial's
welcome DApp, so that the DApp (hosted at one address) can contact
your local proof server (hosted on your system, at a different
address) through the Lace extension.

Supported Chromium version: 119 or later.

:::

## Install Lace wallet

1. Go to the [Lace wallet](https://chromewebstore.google.com/detail/lace-beta/hgeekaiplokcnmakghbdfbgnlfheichg).
2. Install the extension.

You may want to go to the Lace wallet extension's detailed settings
and enable the toggle-switch labeled **Pin to toolbar**, so that the
wallet is easily accessible.

## Set up Lace wallet

1. Start the extension, either by clicking its icon on the web
   browser's toolbar (if you pinned it there after the preceding
   steps) or by clicking on it in the list of extensions under the
   extensions icon in your browser's toolbar.
2. The first page you see presents the options of creating a new
   wallet or restoring an existing one.
   ![new Lace wallet](/img/midnight-lace/lace-create-restore.png)
   At this point, create a new wallet.
3. Read and accept the 'Lace Terms of Use'.
   ![Lace Terms of Use](/img/midnight-lace/lace-terms.png)
4. Give your wallet a name to help you identify it later, maybe a name
   like _Midnight testnet_.
   ![Lace wallet name](/img/midnight-lace/lace-wallet-name.png)
5. Choose and save a strong password for your wallet. Please make sure to keep your password in a safe place. No one will have
access to or the ability to retrieve or recover your password.
If you lose your password, you will need to restore your wallet with your secret passphrase.
6. In the next step, the wallet asks for the network addresses and
   ports of the three client service components it needs:

   - the Midnight network you are going to connect to. If you're connecting to our testnet, choose the "Testnet" option. If you're running a local version of midnight testnet, choose the "Undeployed" option.
   - the Midnight network node through which transactions are to be
     submitted
   - the Midnight Indexer of the blockchain, which
     transmits ledger updates to the wallet
   - the proof server, which generates zero-knowledge proofs of the
     validity of your Midnight transactions


   ![Lace server configuration](/img/midnight-lace/lace-server-config.png)

:::important
   Notice that the default proof server address points to a local instance
   that you have installed. This is because the proof server requires
   private data as inputs, and using a remote instance could compromise
   users' private data.
:::

7. Finally, fill in all the words for a secret passphrase, which may
   be needed to restore your wallet in the future.
   _Do not lose this passphrase! Please write down and keep your passphrase in a safe place. No one will have access to or the ability to retrieve or recover your passphrase. If you lose your passphrase, you will not be able to restore your wallet._
   ![Lace secret passphrase](/img/midnight-lace/lace-passphrase.png)

8. After you have verified your passphrase, a page confirming that you
   have completed the setup is displayed.
   ![Lace setup complete](/img/midnight-lace/lace-done.png)

Then the main page for your new wallet appears, with 0.00 tDUST as its
initial balance. You can access this view at any time by clicking on the Lace wallet extension icon again.

Before your wallet has received any tDUST, the main page displays the
wallet address, so that you can copy it into some place that will
transfer funds to the wallet.
Visit the [token acquisition page](/docs/develop/tutorial/1-using/faucet.mdx) to find out more.
Later, you can access the wallet address
at any time by clicking on the **Receive** button at the top of the
page.
![Lace receive](/img/midnight-lace/lace-receive.png)
</file>

<file path="docs/develop/tutorial/1-using/faucet.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Token acquisition"
---

# Token acquisition

In the production Midnight network, anyone running a DApp would need
to hold some DUST in a persistent wallet and spend some of it on each
transaction.  On the testnet, however, a supply of free tDUST is
available for developers who want to experiment with Midnight DApps.

## Get tDUST

1. Copy your receiving address from your Lace wallet.

  :::note Bech32m Address Format
  All wallet addresses are shown in Bech32m format by default. The faucet supports both formats, however the legacy (HEX) format will be dropped in future versions.
  :::

2. Visit the [Midnight testnet faucet 🚰](https://midnight.network/test-faucet/) and enter your wallet address.
3. Select **Request tokens**. This may take a few seconds to process and will return something like:

`Transaction submitted. Its ID is 1644b988ac71dc6bd6...`

4. You should have received 1000.0 tDUST from the faucet.
</file>

<file path="docs/develop/tutorial/1-using/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Using Midnight

In this first part of the Midnight developer tutorial, you will:

1. Learn to install and configure the components needed to connect to the
   Midnight network
2. Acquire some tDUST to pay for transactions on the network
3. Run a DApp that connects to the network and performs a transaction.

When you are done with part 1, you will have connected to the Midnight
network and made real changes to the Testnet blockchain ledger.

Remember, if you run into any problems, ask for help using the
pathways described in the [getting help](/docs/develop/getting-help.mdx) section.

# Prerequisites

## Supported platforms

These instructions have been tested on recent versions of macOS and
various Linux distributions.  Development on Windows has been tested
using the Windows Subsystem for Linux (WSL), specifically
`Ubuntu 22.04.2 LTS (GNU/Linux 5.15.90.1-microsoft-standard-WSL2 x86_64)`.

## Docker

A working Docker installation is needed to continue with this tutorial. 
The easiest and recommended installation is [Docker Desktop](https://docs.docker.com/desktop/).

Check that you can invoke Docker. If you type the following at a
shell prompt, you should see a recent version number, such as 24.0.5.

```shell
docker --version
```

List available images from Midnight docker repository.

```shell
docker search midnightnetwork
```

You can also manually add our images through Docker Desktop.

![](./img/docker_manual_add.png)

If you cannot complete this step, contact the Midnight DevRel team, as
described in the [getting help](/docs/develop/getting-help.mdx) section.
</file>

<file path="docs/develop/tutorial/1-using/proof-server.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Proof server"
---

# Proof server

Midnight uses zero-knowledge (ZK) cryptography to enable shielded
transactions and data protection. An essential element of this
architecture is ZK functionality provided by a Midnight *proof
server*, which generates proofs locally that will be verified on-chain. The information that a DApp sends to the proof server includes
private data, such as details of token ownership or a DApp's
private state. To protect your data, you should access only a local
proof server, or perhaps one on a remote machine that you control,
over an encrypted channel.

Run a Midnight proof server on your system in a Docker container. The Lace wallet
Chrome extension (including the wallet) communicates with the proof
server to invoke ZK functionality and generate ZK proofs for your
transactions.

## Install the proof server

1. In the prerequisites from the installation guide, you
installed Docker and verified your access to the [Midnight Testnet docker repo](https://hub.docker.com/u/midnightnetwork).

   - Using the terminal:

      ```shell
      docker search midnightnetwork
      ```

   - Or by searching `midnightnetwork` in the Docker Desktop search bar.

2. To download the Docker image for the Midnight proof server:

   - Via the terminal:

      ```shell
      docker pull midnightnetwork/proof-server:latest
      ```

      If you need to run an older version of the proof-server, Replace `latest` with the required version of the proof server according to the [release compatibility matrix](../../../relnotes/support-matrix).

   - Or by clicking **pull** in the search results of the Docker Desktop.


3. You can verify the download's success by checking that the following
command lists a proof server image.

   - Via the terminal:

      ```shell
      docker images | grep proof-server
      ```
    
   - Or by clicking **>_ Terminal**, clicking **Enable Docker terminal** and running the same command as above.


## Start the proof server

In the terminal, run the proof server with the following command:

```shell
docker run -p 6300:6300 midnightnetwork/proof-server -- 'midnight-proof-server --network testnet'
```

You should see some output indicating that the server has started.

## Stop the proof server

To stop the proof server, simply exit the process you launched with
`docker run`. For example, on most systems, you can type `Ctrl-C` to
stop the process.

**For the next step in this tutorial, the proof server must be
running**, so if you have stopped it, start it again now.

## Your privacy

The proof server exists to protect your privacy.  It does not open any
network connections; it simply listens on its assigned port for
requests from your Chrome extension. One of the lines of output you
may see from the proof server includes this text:

```
Targeting network: TestNet
```

This indicates that the instance you are running is configured
appropriately to generate proofs that are valid on the Midnight
Testnet. It does not indicate a network connection from the proof
server to Testnet.

Please let the DevRel support team know if you have any privacy
concerns regarding the proof server.

## Set up proof server as a systemd service

Optionally for Linux users, you might consider running the proof server as an automatic background process anytime you boot your machine.

1. Create a new file for your systemd service, typically in the `/etc/systemd/system/` directory. For example:

```shell
sudo nano /etc/systemd/system/midnight-proof-server.service
```

2. Add the following contents.

```
[Unit]
Description=Midnight Network Proof Server
After=docker.service
Requires=docker.service

[Service]
ExecStart=/usr/bin/docker run -p 6300:6300 midnightnetwork/proof-server -- 'midnight-proof-server --network testnet'
Restart=always
RestartSec=5

[Install]
WantedBy=default.target
```

Adjust the `Description`, `ExecStart`, and other parameters as needed.

3. Reload systemd manager to apply changes.

```shell
sudo systemctl daemon-reload
```

4. **Start** service.
```
sudo systemctl start midnight-proof-server # start service
```

5. How to **stop** and get **status** of service.

```shell
sudo systemctl enable midnight-proof-server # stop service

sudo systemctl status midnight-proof-server # get status of service
```
</file>

<file path="docs/develop/tutorial/1-using/welcome.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Welcome to the Midnight Testnet"
---

# Use the Midnight Testnet

By now you have:
- A Lace wallet
- Some amount of tDUST assigned to that wallet, and
- A proof server running locally.

You are ready to perform your first transaction on the Midnight Testnet.

1. Copy your best friend's receiving address or the address below and send exactly 1.0 tDUST.

```
mn_shield-addr_test1kjwksfp8x2tachehsfvufsdl35ljg5cxzdcysjdn6ntadspyxn3qxqrxypgjm055c2azrpuyn7un0ge2vm25vkfv38d24rj3ewcku5wmdc94gjr9
```

:::note Address Format Reminder
The example address above uses the legacy HEX format. If you're copying a receiving address from the Lace wallet, it will be in Bech32m format by default. For example: `mn_shield-addr_test1kjwksfp8x2tachehsfvufsdl35ljg5cxzdcysjdn6ntadspyxn3qxqrxypgjm055c2azrpuyn7un0ge2vm25vkfv38d24rj3ewcku5wmdc94gjr9`
:::



At this point you've completed your first Midnight Testnet transaction. Now, let's build some DApps!
</file>

<file path="docs/develop/tutorial/2-building/contract-details.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "The counter contract"
---

# The counter contract

The remainder of this part of the tutorial examines first the
Compact contract and then the TypeScript code for the counter DApp.

The contract behind the counter DApp can be found within the
Counter Dapp examples directory at:

```
example-counter/contract/
```

The counter contract itself is very simple. Here are the entire
contents of `counter.compact`:

import CodeFromGithub from '@site/src/components/CodeFromGithub';

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/contract/src/counter.compact"
  language="compact"
/>



To make sense of this Compact code, start in the middle, with the `ledger` field
declaration. It says that the public state of the contract, visible on the
Midnight blockchain, includes a field `round`. The Midnight ledger supports
`Counter` as one of its [state
types](../../reference/compact/lang-ref#ledger-state-types), and the field is
declared to be of that type.

In addition to declaring ledger fields, a contract can declare the functions
that provide the interface to its private state, each marked with the `witness`
keyword. The counter contract has no support for such hidden, off-chain state,
so no witnesses are mentioned.

This contract provides a single public operation (_circuit_) that its users can
call: `increment`. The `increment` operation simply increments the value of the
`round` counter by `1`.

There are two other lines of code in this contract, at the top of the file.  The
first line is a `pragma` that specifies a constraint on the Compact language
version.  If the Compact compiler does not support the language versions
specified, it will signal a compile-time error.  The second is the `import` that
makes Compact's standard library (`CompactStandardLibrary`) available in this
file.  The standard library includes the ledger type `Counter` and so it has to
be imported to make that type available.

More interesting contracts can declare enumerations and structured types to be
used in the ledger, multiple circuits (including unexported ones called only by
other circuits in the contract), and the functions that manipulate private,
off-chain state. You will learn much more about Midnight contracts in the next
major section of this tutorial: the bulletin board example.
</file>

<file path="docs/develop/tutorial/2-building/counter-build.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Build the counter DApp"
---

# Build the counter DApp

To keep the code short enough to read easily, the counter DApp uses a text-based user interface,
omitting the additional complexities of a web interface.  

At the root level of the `example-counter` repository, notice two sub-directories, each of which is a
separately buildable project.
- `contract` - contains the Compact source for the counter contract,
  plus a tiny amount of associated TypeScript
- `counter-cli` - contains the command-line interface of the DApp and
  depends on the `contract` code.


## Compile the code

1. In the `contract` folder, compile the Compact contract and build:

```shell
npm run compact && npm run build
```

The `compact` script calls `compact compile` with the correct paths configured in `package.json`. The `build` script compiles the TypeScript wrapper code.

2. Switch to the `counter-cli` folder and run the application:

```shell
npm run start-testnet-remote
```

This starts the DApp and connects to a remote Midnight testnet node.

:::note
The npm scripts use the new `compact compile` command internally. The deprecated `compactc` executable should not be used directly. Always use either `compact compile` or the provided npm scripts.
:::

You should see the following output from npm and the Compact compiler:

```
Compact version: 0.25.0
Compiling 1 circuits:
  circuit "increment" (k=10, rows=29)
Overall progress [====================] 1/1
```

:::note 
The compiler completes very quickly because you've instructed it to skip ZK key generation with the option `--skip-zk`. The compiler's output files are placed in the directory `contract/src/managed/counter`.
:::

## Build the TypeScript source files

1. In the `contract` folder, run this command:

```shell
npm run build
```

This creates the `contract/dist` directory.

2. Start unit tests by running:

```shell
npm run test
```

3. In the `counter-cli` folder, run this command:

```shell
npm run build
```
</file>

<file path="docs/develop/tutorial/2-building/counter-run.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Run the counter DApp"
---

# Run the counter DApp

Now you are ready to run the counter DApp, deploying a new instance of
its contract to the Midnight Testnet and submitting transactions
to the network.

## A command-line wallet

Because this DApp has no web-based user interface and runs outside of
your web browser, it cannot access the Lace wallet. Instead, the DApp initializes
a Midnight wallet that shares its core libraries with Lace wallet, but
which can be invoked through library calls in command-line
applications. (Many programmers refer to the software without a graphical
user interface as 'headless', so you may find text elsewhere that
refers to this wallet as the 'headless wallet'.)

When you run the DApp, the first thing it does is instantiate its
wallet, either by creating a completely fresh one or by rebuilding the
wallet from a previously generated seed.  On the first run, you must
create a fresh one and transfer some tDUST to it from your Midnight
Lace wallet.

## Run the counter CLI

1. Be sure the proof server that you installed in part 1 of the
   tutorial is started.

2. In the `counter-cli` directory, launch the DApp with:
   ```shell
   yarn testnet-remote
   ```
   This starts the DApp in a configuration that uses your local proof
   server, but connects to cloud-deployed instances of a Midnight node
   and a Midnight Indexer.

3. Choose to build a fresh wallet.  The DApp displays the wallet's
   address and a balance of `0` tokens.

   The seed for the freshly created wallet is printed.  Save
   this information so that you can reuse this wallet on a later run
   of the counter DApp.


   Additionally, your interactions with the DApp, including the wallet
   address and seed, are stored in a `log` subdirectory of
   `counter-cli`.

4. Transfer tokens from your Lace wallet to your CLI wallet:
   - Copy your new wallet's address and open the Lace wallet
     in your web browser by clicking its icon on the Chrome toolbar.
   - Select **Send** and paste the CLI wallet address into the 'recipient's address' field.
   - Enter an amount to transfer. The value of 10 tDUST will be more than enough.
   - Review and click **Send**.
   - Enter your wallet password and click **Confirm**.

5. Return to the counter DApp's window and wait for the tokens to be
   received.  The DApp detects the funds that were transferred to
   your CLI wallet and reports your new wallet balance, followed
   by a new prompt.

6. The next prompt asks whether you want to deploy a new counter
   contract on Testnet or join an existing one.  Choose to deploy
   your newly-compiled contract.

   The DApp prints the deployed contract's address.  Save this
   information, so that you can run the DApp again later and rejoin
   the contract.

7. Interact with the contract.  You are prompted with three options: increment, display, or exit.
   - First, display the current value by selecting option 2.  This
     retrieves the current state of the contract from the blockchain
     ledger.  It should report a value of `0`.
   - Next, increment the counter by selecting option 1.  This submits a
     new transaction and awaits confirmation.

     If you watch your proof server's output in another window at the
     same time, you will see that it generates a proof for the
     transaction, which is submitted to Testnet.

     Generating the proof, submitting it to Testnet, and waiting
     for the transaction to be processed by the network takes some
     time.  Eventually, the DApp should report the successful
     completion of the transaction, with output like:
     ```
     Transaction <transaction hash> added in block <block number>
     ```
   - Now verify that the counter's value has been incremented by
     selecting option 2.  It should report a new value of `1`.

   - Repeat as you like, and then select (3) to exit.  There is a problem in one of the underlying libraries
     that can cause error messages upon exit.  You may safely ignore
     these.

8. Try running the DApp again, rebuilding the wallet from the saved
   seed, and rejoining the existing contract.
</file>

<file path="docs/develop/tutorial/2-building/dapp-details.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "The counter DApp"
---

import CodeFromGithub from '@site/src/components/CodeFromGithub';

# The counter DApp

## Project structure

You might find it useful to split DApps into several
sub-projects.  This is especially true for larger, more complex DApps
with web-based user interfaces, where it is desirable to test the core
logic independently from the user experience.  Even for a DApp as
simple as the counter, however, you will see that the code is split
into two sub-projects:
- `contract` - This sub-project contains the contract itself, plus
  supporting code to define the implementation of the local private
  state and code to test the contract's logic.
- `counter-cli` - This sub-project defines the command-line interface
  of the DApp.  It depends on the outputs of the `contract`
  sub-project.

You will find project definition and configuration files in each
sub-project's top level directory, while the source code is in its
`src` subdirectory.

## The `contract` sub-project

The preceding page already gave you a tour of the contract itself.
Because the contract is so simple, there is very little additional
code to be written.

### Witness implementation

Look in the file `contract/src/witnesses.ts`. The counter contract defines no private state and therefore
requires no witness functions to be defined.  In the TypeScript
representation of contracts, however, every contract is parameterized
over its private state, so there remains a need to define *some*
private state object for the contract. In this case, we use the type
`Record<string, never>` to represent the type of an empty object.
The definitions in counter's `witnesses.ts` therefore provide the minimal (empty)
implementations of witnesses possible.


<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/contract/src/witnesses.ts"
  language="typescript"
/>

Part 3 of the Midnight tutorial introduces an example that follows the
same structure, but with more interesting contents in its
`witnesses.ts`.

### Generated source

The file `contract/src/index.ts` merely re-exports the definitions
from the other files in the contract sub-project.  Which definitions?
The empty definitions of the witnesses, of course, *but also the
definitions generated by the Compact compiler*.

If you are following the steps of this tutorial in order, then you
have already built the counter project.  That means you have already
run the Compact compiler on `counter.compact`.

Look in the `managed/counter` subdirectory of the contract
sub-project.  In it, you see four directories:
- `contract` - contains files defining the TypeScript/JavaScript API for the contract
- `zkir` - contains the intermediate representations for the circuits
  defined in the contract
- `keys` - contains the prover and verifier keys for each circuit
  defined in the contract
- `compiler` - contains metadata about the contract, including the names of
  exported circuits and their argument and return types in JSON format

The counter contract defines only one circuit, `increment`, so there is
a single pair of prover and verifier key for `increment` in `keys`. The `zkir`
directory contains two files, `increment.bzkir` and `increment.zkir`.  Respectively,
these files are the binary and JSON representations of the ZKIR of the `increment`
circuit.

Most of this generated content is not useful to examine, but you might
want to look at `managed/counter/contract/index.d.ts`.  You will see
that it defines various types and functions that correspond directly
to the code in `counter.compact`.  For example:
- The `Circuits` type for this contract includes an `increment`
  function.
- The `Ledger` type for this contract includes a `round` field,
  declared to be a JavaScript `bigint`.
- The `Witnesses` type for this contract is empty, because the
  contract declares no witnesses.

Notice that many of the types are parameterized over some type `T`,
representing the DApp's private state implementation, which is opaque
to the circuits and ledger types emitted by the compiler.

### Tests

Part 3 of the Midnight tutorial explores unit testing, so it will not
be discussed here, but you are free to examine the code in the
`contract/src/test` subdirectory.  It defines just a few Jest tests to
exercise the contract in a simulation environment.

## The `counter-cli` subproject

All the interactive logic for the counter DApp's command-line
interface is exposed through `counter-cli/src/index.ts`.  Before examining
that file, though, it may be useful to see how the whole DApp is
launched.

### Different configurations

There are four 'entry-point' files in the directory:
- `testnet-remote.ts` - the first way you ran the counter DApp, so that
  it uses a local proof server, but a remote Midnight node and a
  remote Midnight Indexer, both connected to TestNet
- `testnet-local.ts` - the second way you ran the counter DApp, if you
  tried the optional step of running your own TestNet node and indexer
- `testnet-remote-start-proof-server.ts` - the same configuration as
  `testnet-remote.ts`, but not assuming you already have a proof server
  running and instead starting one as part of the script
- `standalone.ts` - invokes a `DockerComposeEnvironment` that launches
  a proof server, Midnight node, and the Midnight Indexer, all disconnected
  from TestNet and running entirely locally, for unit testing.

If you look in `testnet-remote.ts`, you will see that it is very short:


<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/testnet-remote.ts"
  language="typescript"
/>


and the other entry points are similar, because they rely on the
configurations defined in `config.ts`.  Each of those configurations
is quite similar.  For example, here is the one that says to connect
to the Midnight-hosted instances of a Midnight node and an indexer:


<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/config.ts#L55-L64"
  language="typescript"
/>


The various subsystems are all configured for operation on Midnight TestNet.

Notice the `setNetworkId` call in the `TestnetRemoteConfig` constructor.
Many Midnight APIs and packages require the API consumer to explicitly specify
the network they are targeting via a network ID parameter. Providing such a parameter to
each API would be tedious and error-prone. Midnight.js provides the `setNetworkId` function
so that the user can specify the network they are targeting once and have the correct network
ID used everywhere.


### Generated types, instantiated

Recall that many of the types, such as `Contract`, in the source files
generated by the Compact compiler, are parameterized.  Writing out the
instantiated forms of these types can become unwieldy, especially when
the type arguments will be the same, over and over.  Thus, the
Midnight team often creates a short file defining instantiated versions
of some of these generated types and uses those instantiated versions
in the rest of the code.

You can see an example of this pattern in the file `common-types.ts`,
which defines types such as `CounterContract`, like this:

```tsx
export type CounterContract = Contract<CounterPrivateState, Witnesses<CounterPrivateState>>;
```

### The Dapp

The two main files implementing our application are `counter-cli/src/cli.ts` and
`counter-cli/src/api.ts`. The former contains the main run loop of the application.
The latter contains convenience functions for interacting with the Midnight network.

To understand `counter-cli/src/cli.ts`, start at the end, looking at the `run` function.  Ignoring the
startup and error-handling code, the core actions of the DApp are to
1. instantiate a wallet,
2. instantiate a collection of 'providers' for working with the contract, and
3. start the main user interaction loop.

#### Create a wallet

If this DApp were running in a web browser, it would begin by
connecting to the browser's Lace wallet extension.  Instead,
the counter DApp is running outside any web browser, so it
initializes a 'headless' wallet to be used for funding transactions.

Depending on the user's input in the interactive `buildWallet`
function, the DApp either prompts for a wallet seed or generates some
random bytes to serve as the seed.  Either way, the flow eventually
reaches `buildWalletAndWaitForFunds` in `counter-cli/src/api.ts`.
Omitting the logging code, this function is as follows:


<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L200-L311"
  language="typescript"
/>


The `WalletBuilder` class provides the main entry point into creating
a wallet: `buildFromSeed`.  The wallet needs to know about the
indexer, the node, and the proof server, because it watches the ledger
for information about funds and transaction results (using the
indexer), submits transactions through the node, and calls on the
proof server to generate proofs that transactions are valid.

:::note Wallet SDK v4.0.0 Compatibility
The counter DApp uses `@midnight-ntwrk/wallet@4.0.0`, which introduces the following breaking changes:

- `WalletBuilder.buildFromSeed()` is **deprecated**. It still works, but will be removed in a future version. Use `WalletBuilder.build()` with a seed parameter instead.
- Wallet addresses and keys are returned in the new **Bech32m format** by default.
- The seed is no longer embedded in the serialized wallet state. You must explicitly pass the seed again when restoring a wallet.
:::


Notice the `getZswapNetworkId` argument to `WalletBuilder.buildFromSeed`.
The `getZswapNetworkId` function is provided by Midnight.js. It retrieves
the current network ID (set by the `setNetworkId` call we have already seen)
and converts it to a format the wallet can understand.

After the wallet is started, the DApp pauses to wait for funds to
appear.  You may find it instructive to look at the definition of
`waitForFunds` just above `buildWalletAndWaitForFunds` in the file.
The wallet's state appears in TypeScript as an observable stream, so
`waitForFunds` uses RxJS functions to watch for the wallet's balance
to be non-zero.


<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L180-L198"
  language="typescript"
/>


Notice that the wallet's state includes information about the degree
to which it is synchronized with the total state of the blockchain.

Hypothetically, the wallet could track the balances of many different
tokens, so the code in `waitForFunds` asks specifically for the
`nativeToken` balance, meaning tDUST.  Once the tDUST balance is
non-zero, the `waitForFunds` function returns, and the
`buildWalletAndWaitForFunds` function returns the wallet itself.

#### Providers

The Midnight programmatic interface to a smart contract is extremely
flexible and thus highly parameterized.  For example, a DApp developer
might implement a new kind of private state storage or interpose some
kind of balance-checking functionality between the contract and a
wallet.  The way that the Midnight libraries handle all this
functional parameterization is through a JavaScript object with fields
for different types of *providers*.

Of course, most of the time, a standard implementation for each type
of provider is what you want, and the Midnight libraries define these
for you.  All you have to specify is some information about where to
find the indexer, the proof server, and so on.

The `counter-cli/src/api.ts` file defines a function `configureProviders` that
returns an object containing the providers our application will need to interact
with the network.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L322-L334"
  language="typescript"
/>

Back in the `run` function, you can see where the counter DApp creates
the providers.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/cli.ts#L152"
  language="typescript"
/>


The exception to the pattern of using standard implementations for the
providers is seen in the value provided for the `walletProvider` and
`midnightProvider` fields.
- The wallet provider specifies the wallet's public key and defines a
  function for balancing transactions (that is, attaching to the
  transaction an appropriate amount of 'fuel' to run the transaction): `balanceTx`.
- The Midnight provider defines a function for submitting transactions
  to the Midnight network: `submitTx`.

The counter DApp defines a single object to satisfy both provider
interfaces:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L123-L142"
  language="typescript"
/>


You can read more about what happens when a transaction is
balanced and submitted to the network in the portion of the Midnight
developer documentation that describes [how Midnight works](/docs/develop/how-midnight-works/index.mdx).

### Work with a contract

The bulk of the counter DApp uses input from the user to direct its
actions, which include:
- deploying a new counter contract
- joining an existing counter contract
- calling the `increment` circuit on the contract
- examining the ledger state associated with the contract.

With the wallet and providers objects in hand, these actions
are performed by calling Midnight library functions.  For example, the
call to find and join an existing contract can be seen in the `join`
function, near the top of `counter-cli/src/api.ts.  The relevant call is:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L78-L83"
  language="typescript"
/>


where `counterContractInstance` is simply a `Contract` object defined in the `index.ts` file
in the generated code.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L72"
  language="typescript"
/>


### Submit a Transaction

Using the generated code and the Midnight.js library, creating and submitting an
`increment` transaction becomes a simple function call:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L104"
  language="typescript"
/>


The `callTx` access on the `counterContract` object indicates that we want to create a call
transaction for the counter contract. The `increment()` call creates and submits a call transaction for the `increment`
circuit. After the transaction is submitted and included in the blockchain, the result is stored in `finalizedTxData`.public, which contains additional public information about the transaction. 


### Viewing Contract State

The `publicDataProvider` in the `providers` object can be used to query for information about the blockchain.
To view the current value of `round` defined in the counter contract, we can query the `publicDataProvider`
and convert the result to a JavaScript object using the `ledger` function generated for the counter contract
by the compiler.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-counter/blob/main/counter-cli/src/api.ts#L59-L70"
  language="typescript"
/>




At this point, you have seen enough to be able to read and understand the gist of the
`counter-cli/src/api.ts` and `counter-cli/src/cli.ts` files.
</file>

<file path="docs/develop/tutorial/2-building/examples-repo.mdx">
---
sidebar_label: "Midnight examples repository"
---

# Midnight examples repository

1. Clone the [Counter Dapp repository](https://github.com/midnightntwrk/example-counter).
2. Go to the root level of the repository.

```shell
cd example-counter
```

3. Run `npm install` in the root folder to install all the necessary packages.

## Configure Yarn to download Midnight libraries

You will be using Yarn to build Midnight example DApps.  An easy way
to install Yarn, now that you have dependencies configured, is with the
`corepack` command:

```shell
corepack enable
```

This succeeds silently, but you should see version information now if
you type:

```shell
yarn --version
```

You should see a version number printed, such as `4.1.0`.

The best way to verify this step is to use Yarn to pull the Midnight examples dependencies.  In the top level of your `example-counter` repository, simply invoke Yarn with no parameters:

```shell
yarn
```

You should see a lot of output, but no errors, although there may be some warnings.  For example, the last line of output may say `Done with warnings`.

## Configure the Compact compiler path

If you did not add `COMPACT_HOME` to your shell profile after
installing the compiler, or if you have not restarted your shell since
then, execute the following command:

```shell
export COMPACT_HOME='<absolute path to compact directory>'
```
</file>

<file path="docs/develop/tutorial/2-building/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Build a DApp

Build and deploy decentralized applications (DApps) on the Midnight network. This guide covers toolchain installation, contract compilation, DApp deployment, and node operation. The following example implementation demonstrates a counter contract.


## Prerequisites

- **Operating System:** Linux, macOS, or Windows (via WSL)
- **Node.js:** v18 LTS or higher (NVM recommended)
- **Yarn**
- **Git**
- **Terminal:** Bash, Zsh, or compatible shell
- **Disk Space:** ≥ 2 GB
- **Network:** Internet connection

## Objectives

This guide enables developers to:

1. Install the tools necessary to compile a Midnight contract and DApp from source code
2. Download the example code needed for development
3. Build a simple example from source
4. Run the example and deploy a smart contract
5. Install and run a Midnight network node and its associated Indexer

:::important
Use compatible versions of example code and the Compact compiler, as shown in the [release compatibility matrix](../../../relnotes/support-matrix).
:::

The final sections examine the Compact code for the example contract and the TypeScript code for the example DApp in detail.

Upon completion, developers have built a DApp from source, deployed a contract, and run a non-voting Midnight node connected to the Midnight network.

The example contract creates a counter on the ledger and provides a circuit to increment it. The contract enforces only constraints implied by the `Counter` type. While this example doesn't demonstrate Midnight's full privacy capabilities, it provides the foundation for building and deploying contracts on the Midnight network.


## Node

Many Midnight Testnet features are provided as TypeScript packages, including example applications and APIs. These packages require Node.js as their runtime environment and use npm (Node Package Manager) for dependency management. Node Version Manager (NVM) provides the best way to install and manage Node.js versions because it enables switching between different Node versions for different projects and ensures compatibility with Midnight's requirements.

Find installation and troubleshooting instructions on [the NVM GitHub site](https://github.com/nvm-sh/nvm#installing-and-updating). For macOS users installing via Homebrew, the installation process differs slightly from the standard script installation. Homebrew places NVM in a different directory and requires specific additions to shell profile files for proper initialization.

After following NVM installation instructions, verify installation:

```shell
nvm --version
```

The command displays a version number such as `0.39.5`. If the command isn't found, the shell profile modifications weren't applied correctly. Ensure the NVM initialization script is added to the appropriate shell configuration file (`~/.bashrc` for Bash, `~/.zshrc` for Zsh).

Install LTS version of Node 18x or greater:

```shell
nvm install 18 --lts
```

This command downloads and installs the latest Long Term Support version of Node 18. LTS versions receive critical bug fixes and security updates for an extended period, ensuring stability for production applications. The installation includes both Node.js and npm.

Set Node 18 as the default version for new terminal sessions:

```shell
nvm alias default 18
```

Verify the Node installation:

```shell
node --version
npm --version
```

> **Caution**: After modifying `~/.zshrc`, `~/.bashrc`, or installing a new Node version using `nvm`, open a new terminal window. Running `source ~/.zshrc` might not fully reload the environment and could lead to issues such as `ERR_UNSUPPORTED_DIR_IMPORT`. This error occurs when Node.js attempts to import ES modules but the environment variables aren't properly configured.

## Install the Compact developer tools

The Compact developer tools manage the installation and updates of the Compact toolchain, including the compiler. These tools solve the complexity of managing multiple compiler versions, platform-specific binaries, and toolchain dependencies. Before these tools existed, developers manually downloaded platform-specific ZIP files, extracted binaries, managed PATH configurations, and repeated this process for each update.

Install the developer tools with a single command:

```shell
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/midnightntwrk/compact/releases/latest/download/compact-installer.sh | sh
```

This command performs several operations:
- Downloads the installation script using secure HTTPS with TLS 1.2 minimum
- Detects the system architecture (x86_64, ARM64) and operating system
- Downloads the appropriate binary for the platform
- Creates the `~/.compact` directory structure for toolchain management
- Installs the `compact` command-line tool to `~/.cargo/bin` or another appropriate location

The installation script outputs instructions for adding the binary directory to your `PATH` environment variable. This step is crucial—without it, the shell cannot find the `compact` command. The exact instructions depend on your shell and existing PATH configuration. Typically, add a line like this to your shell configuration file:

```shell
export PATH="$HOME/.cargo/bin:$PATH"
```

After adding the directory to your `PATH`, open a new terminal window or reload your shell configuration. Then update to the latest toolchain:

```shell
compact update
```

This command downloads the latest stable version of the Compact compiler and associated tools. The download includes:
- The Compact compiler binary
- Zero-knowledge proving key generator (`zkir`)
- Platform-specific runtime dependencies
- Standard library definitions

The output shows the installed version:

```
compact: aarch64-darwin -- 0.24.0 -- installed
compact: aarch64-darwin -- 0.24.0 -- default.
```

The first line confirms successful installation. The second line indicates this version is now the default for all compilation operations. The tools maintain multiple versions simultaneously, enabling testing with different compiler versions without conflicts.

### Verify the installation

Test the compiler installation to ensure all components are properly configured:

```shell
compact compile --version
```

This command displays the compiler version number, such as `0.24.0`. The version check confirms:
- The `compact` binary is accessible via PATH
- The default toolchain is properly linked
- The compiler binary has appropriate execution permissions
- All required dependencies are present

If the command fails, common issues include:
- **PATH not updated**: The shell cannot find the `compact` command. Verify the installation directory is in your PATH and reload your shell configuration
- **No default toolchain**: Run `compact update` to install and set a default compiler version
- **Permission issues**: On Unix systems, the binaries might lack execution permissions. The installer should handle this automatically, but manual installation might require `chmod +x` on the binaries

The version number corresponds to the Compact compiler release, not the developer tools version. These versions are independent—developer tools version 0.1.0 might manage compiler version 0.24.0. Refer to the [release compatibility matrix](../../../relnotes/support-matrix) for version compatibility between compiler versions and example code.

### Check for updates

Regular update checks ensure access to the latest features, performance improvements, and bug fixes:

```shell
compact check
```

This command performs a network request to determine available updates. The output varies based on your current state:

When updates are available:
```
compact: aarch64-darwin -- Update Available -- 0.24.0
compact: Latest version available: 0.25.0.
```

This indicates version 0.25.0 is available for download. The update might include:
- New language features for Compact contracts
- Performance optimizations for proof generation
- Bug fixes for edge cases in compilation
- Enhanced error messages for better debugging

When current:
```
compact: aarch64-darwin -- Up to date -- 0.24.0
```

This confirms you're using the latest stable release. Check the Midnight developer announcements for information about upcoming releases and their expected features.

The check command only queries for updates without downloading them. This design enables checking for updates in bandwidth-constrained environments or when you need to coordinate updates across a development team.

## Use the Compact compiler

The Compact developer tools provide the standard method to invoke the compiler. Understanding the compilation process helps debug issues and optimize build workflows.

### Basic compilation

The standard compilation command:

```shell
compact compile <contract file> <output directory>
```

For example:

```shell
compact compile src/counter.compact src/managed/counter
```

This command triggers several processes:
1. **Parsing**: The compiler reads and validates the Compact contract syntax
2. **Type checking**: Ensures type safety across circuits, witnesses, and ledger operations
3. **Circuit generation**: Converts high-level Compact code into zero-knowledge circuits
4. **Proving key generation**: Creates cryptographic keys for generating and verifying proofs
5. **TypeScript API generation**: Produces type-safe interfaces for DApp integration

The compilation creates multiple output files in the specified directory:
- `contract/index.d.cts` - TypeScript type definitions for the contract API
- `contract/index.cjs` - JavaScript implementation of the contract
- `zkir/` - Directory containing the zero-knowledge circuit representations
- `proving-keys/` - Cryptographic keys for proof generation
- `verifying-keys/` - Public keys for proof verification

The compiler reports circuit complexity metrics:

```
Circuit 'increment' has complexity: 1234 constraints
```

These metrics indicate the computational cost of generating proofs. Higher constraint counts mean longer proof generation times and higher resource requirements. Optimize circuits to minimize constraints while maintaining security properties.

### Version-specific compilation

Override the default compiler version for testing or compatibility:

```shell
compact compile +0.23.0 <contract file> <output directory>
```

This feature enables:
- Testing contracts against different compiler versions
- Maintaining compatibility with deployed contracts compiled with older versions
- Gradual migration when new compiler versions introduce breaking changes

The version specifier (`+0.23.0`) must reference an already-installed version. Use `compact list --installed` to see available versions.

### Environment variables

The Midnight example DApps historically used environment variables for configuration and toolchain location. Understanding these variables helps when working with existing code or debugging build issues.

**Legacy COMPACT_HOME variable**: Previous versions of Midnight examples required setting `COMPACT_HOME` to point to the compiler directory. The new developer tools eliminate this requirement by managing compiler locations internally. The `compact` command automatically resolves the correct compiler path based on the selected version.

If working with older example code that references `COMPACT_HOME`, you have two options:
1. **Update the build scripts**: Replace `$COMPACT_HOME/compactc` references with `compact compile` commands
2. **Set COMPACT_HOME for compatibility**: Export the variable pointing to `~/.compact/bin` for temporary backward compatibility

**Direct compiler access**: While not recommended, the installed toolchain binaries reside in `~/.compact/bin/`. This directory contains symbolic links to the current default version's binaries:
- `compactc` - The main compiler executable
- `zkir` - Zero-knowledge intermediate representation tool
- Supporting libraries and runtime files

Direct invocation bypasses version management benefits. Always prefer using `compact compile` for:
- Automatic version selection
- Consistent behavior across platforms
- Compatibility with future toolchain updates
- Integrated error handling and diagnostics

**Project-specific configuration**: Modern Midnight projects should document their compiler version requirements in configuration files rather than relying on environment variables. Consider using:
- `package.json` scripts that invoke `compact compile` with specific versions
- Build configuration files that specify the required compiler version
- CI/CD pipelines that install and use specific toolchain versions via `compact update`

This approach ensures reproducible builds across different development environments and team members.

## Optional: Visual Studio Code extension for Compact

Use any editor to create Midnight DApps. Midnight provides a VSCode extension specifically for creating and editing Midnight contracts written in the Compact DSL. The extension transforms VSCode into a specialized Compact development environment with language-aware features that significantly improve productivity and reduce errors.

### Extension features

**Syntax highlighting**: Color-codes different language elements (keywords, types, functions, comments) for improved readability. The highlighting rules understand Compact-specific constructs like `circuit`, `witness`, and `ledger` declarations.

**Live, dynamic contract checking**: Performs real-time semantic analysis as you type, identifying errors before compilation. This includes:
- Type checking across circuit boundaries
- Privacy flow analysis to prevent unintended data disclosure
- Witness function signature validation
- Ledger state access verification

**Debugging assistance**: Provides enhanced error messages with suggested fixes. When compilation fails, the extension highlights problematic code sections and offers context-aware solutions.

**Code completion and IntelliSense**: Offers intelligent suggestions for:
- Standard library functions and types
- Ledger field access
- Circuit and witness declarations
- Import statements for standard modules

**Templates and snippets**: Accelerates development with pre-built patterns for:
- New contract scaffolding with standard structure
- Common circuit patterns (authentication, state transitions)
- Witness function declarations
- Standard library imports

### Installation process

Download the VSCode extension for Compact from [the Midnight Testnet releases repository](../../../relnotes/overview). The file name follows the pattern `compact-x.y.z.vsix` for version `x.y.z`. The VSIX file is a packaged extension format that includes all necessary dependencies.

Install the plugin in VSCode:
1. **Open the Extensions pane**: Click the Extensions icon in the Activity Bar or press `Ctrl+Shift+X` (Windows/Linux) or `Cmd+Shift+X` (macOS)
2. **Access installation options**: Click the `...` symbol at the top of the Extensions pane to reveal additional actions
3. **Select manual installation**: Choose "Install from VSIX..." from the dropdown menu
4. **Locate the downloaded file**: Navigate to your Downloads folder or wherever you saved the VSIX file
5. **Confirm installation**: VSCode installs the extension and may prompt for additional permissions

VSCode typically activates newly installed extensions immediately. The extension activates automatically when opening files with the `.compact` extension. Sometimes VSCode prompts for a restart to ensure all language server components initialize properly.

### Configuration

The extension works with default settings but supports customization through VSCode's settings:

- **Compiler path**: If not using the standard `compact` command, specify a custom compiler location
- **Validation level**: Adjust the strictness of real-time checking (errors only, include warnings, include suggestions)
- **Format on save**: Enable automatic code formatting when saving files

Access extension settings through `File > Preferences > Settings` and search for "Compact" to find all available options.

Even if VSCode isn't your primary editor, consider using the VSCode Compact extension for editing Midnight contracts while learning the language. The immediate feedback and intelligent assistance accelerate the learning process and help avoid common mistakes.

## Manage toolchain versions

The Compact developer tools support multiple toolchain versions simultaneously. This capability is essential for maintaining existing contracts while developing new ones, testing compatibility across versions, and gradually migrating to newer compiler releases.

### List available versions

View all versions available for download:

```shell
compact list
```

Output shows versions and supported platforms:

```
compact: available versions

→ 0.24.0 - x86_macos, aarch64_macos, x86_linux
  0.23.0 - aarch64_macos, x86_linux
  0.22.0 - x86_macos, x86_linux
```

The arrow (`→`) indicates the current default version used when running `compact compile` without a version override. Platform indicators show which architectures support each version:
- `x86_macos` - Intel-based Mac computers
- `aarch64_macos` - Apple Silicon Macs (M1, M2, M3)
- `x86_linux` - Standard Linux on Intel/AMD processors

Not all versions support all platforms. Early releases might lack Apple Silicon support, while some versions might skip certain platforms due to build issues.

### Check installed versions

List versions downloaded to your system:

```shell
compact list --installed
```

Output shows only locally available versions:

```
compact: installed versions

→ 0.24.0
  0.23.0
```

Installed versions consume disk space (approximately 100-200MB each) but enable offline compilation and instant version switching. Remove unused versions by deleting their directories from `~/.compact/versions/`.

### Switch between versions

Change the default toolchain version:

```shell
compact update 0.23.0
```

This command:
1. Downloads the specified version if not already installed
2. Verifies the download integrity using checksums
3. Updates the symbolic link at `~/.compact/bin` to point to the new version
4. Confirms the switch with output showing the new default

The switch affects all subsequent `compact compile` commands unless overridden with the `+version` syntax. Projects can document their required compiler version in README files or build scripts to ensure consistency across team members.

## Developer tools maintenance

The developer tools update themselves independently from the toolchain. This separation ensures that improvements to the version management system don't require compiler updates, and compiler releases don't force tool updates. The architecture enables the tools to manage multiple compiler versions while maintaining a consistent interface.

### Check for tool updates

Verify if newer developer tools are available:

```shell
compact self check
```

This command queries the GitHub releases API to identify the latest stable version. The check compares your installed version against the latest release and reports:
- Current installed version of the developer tools
- Latest available version
- Whether an update is recommended

The tools check for updates automatically once per day when running any `compact` command. This passive check doesn't interrupt workflow but notifies about available updates through a brief message after command completion.

### Update the developer tools

Install the latest developer tools version:

```shell
compact self update
```

The self-update process:
1. Downloads the latest version to a temporary location
2. Verifies the download using cryptographic signatures
3. Replaces the current binary with the new version
4. Preserves all installed toolchains and configuration

Self-updates are backward compatible—new tool versions continue to work with existing installed toolchains. This design principle ensures that updating tools never breaks existing projects.

### When to update

Update the developer tools when:
- **New features become available**: Future releases include features like `compact format` for code formatting, `compact doc` for documentation generation, and `compact test` for contract testing
- **Bug fixes are released**: Tool updates may resolve issues with version management, platform compatibility, or command execution
- **Security updates**: Although rare, security updates to the tools themselves should be applied promptly

The release notes for each tool version (distinct from compiler release notes) describe new features and important changes. Monitor the Midnight developer announcements for significant tool updates that enhance the development experience.

## Get help

The `compact` tool provides comprehensive built-in documentation accessible directly from the command line. This integrated help system eliminates the need to search online documentation for basic command syntax and options.

### General help

Access the main help overview:

```shell
compact help
compact --help
```

Both commands display identical output—a complete list of available subcommands with brief descriptions. The help text includes:
- **Subcommand list**: All available operations like `compile`, `update`, `list`, `check`
- **Global options**: Flags that apply to all subcommands, such as `--directory` for specifying the toolchain location
- **Usage examples**: Basic command patterns showing typical invocations

The help system uses a hierarchical structure. The top-level help provides an overview, while subcommand-specific help offers detailed information about individual operations.

### Subcommand help

Get detailed help for specific operations:

```shell
compact help update
compact update --help
```

Subcommand help includes:
- **Detailed description**: Explains what the command does and when to use it
- **Argument specifications**: Required and optional parameters with their types
- **Flag descriptions**: All available options with their effects
- **Examples**: Real-world usage scenarios
- **Related commands**: References to similar or complementary operations

For compiler-specific help:

```shell
compact compile --help
```

This displays compiler options including:
- **Input specifications**: Supported file formats and contract structures
- **Output options**: Directory structure and generated file descriptions
- **Optimization flags**: Options for controlling compilation behavior
- **Debug options**: Flags for generating additional diagnostic information

### Version information

The tools provide multiple version queries for different components:

**Developer tools version**:
```shell
compact --version
```
Returns the version of the `compact` command itself (e.g., `0.1.0`). This version indicates the capabilities of the version management system.

**Compiler/toolchain version**:
```shell
compact compile --version
```
Returns the version of the currently selected Compact compiler (e.g., `0.24.0`). This version determines available language features and compilation behavior.

**Compact language version**:
```shell
compact compile --language-version
```
Returns the version of the Compact language specification supported by the current compiler. Language versions change less frequently than compiler versions, as they represent the stable language syntax and semantics.

Understanding version relationships helps diagnose compatibility issues:
- **Language version**: Defines contract syntax and available features
- **Compiler version**: Implements a specific language version with particular optimizations
- **Developer tools version**: Manages compiler installations and provides development utilities

When reporting issues or seeking support, provide all three version numbers for complete context.
</file>

<file path="docs/develop/tutorial/3-creating/bboard-contract.mdx">
---
sidebar_label: "Bulletin board contract"
---

# Bulletin board contract

Just as with the counter DApp, there are separate subdirectories in
the [`example-bboard`](https://github.com/midnightntwrk/example-bboard) repository for the contract and the user
interaction code.
Unlike the simple counter DApp, however, the bulletin board DApp
demonstrates an additional useful separation: between user interface
code and the underlying application logic that is independent of the
user interface.  Keeping the user interface separate from the
application logic allows you to create a command-line version of the
bulletin board in this part of the tutorial and a web-based version in
a later part.
- `contract` - contains the Compact source for the bulletin board
  contract, plus associated TypeScript
- `api` - contains TypeScript source that implements the core behavior
  of the DApp, such as posting messages and taking them down, and
  depends on the `contract` code
- `bboard-cli` - contains the command-line interface for the text-based
  DApp and depends on both the `contract` and `api` code.


:::tip

This page walks step by step through the design of the bulletin board
contract.  The finished contract appears at the end of the page.  Midnight
recommends viewing and editing the contract using the
[Visual Studio Code extension for Compact](/docs/develop/tutorial/2-building/index.mdx#optional-visual-studio-code-vscode-extension-for-compact),
where you get nice colors and auto-completion of names.

:::

To create a Midnight contract for the bulletin board scenario, we need
to identify:
- The components of the contract's public state
- The visible operations that can be performed on the contract
- The private data and operations, used by the visible operations in
  ways that are provably valid, but not shared publicly.

The public state of the contract and the transaction history of the
public operations appear on the ledger of the Midnight blockchain.
Anyone can verify them.  The private data never has to leave the
DApp user's computer.

## Public ledger state on the blockchain

The public ledger state of the bulletin board consists of four
values:
1. A state: vacant or occupied
2. A message
3. A counter to identify *which* specific post is current
4. A public token produced by the user who made the current post, but
   from which their private identity cannot be derived.

The third value is perhaps less obvious than the others; it
corresponds to the 'that message' constraint mentioned on the
previous page.  When its value is 15, it says, 'The current message
is the 15th post.'  If you have ever implemented any sort of software
lock, it will not surprise you that the correct behavior is to
increment this counter whenever the board becomes vacant (not when it
becomes occupied), because that is the point at which the bulletin board
no longer holds the (previous) numbered post.

The fourth value should be a non-reversible hash of the owner's
identity and the posting sequence number (the counter).  No one can
figure out who posted the message from the token, but the user who
created the post can reliably derive that token again to satisfy the
identity-verification obligation.

Here is the type of that ledger state, specified in Midnight's Compact
contract language:

import CodeFromGithub from '@site/src/components/CodeFromGithub';

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact#L18-L37"
  language="compact"
/>



Some notes about the types used in this ledger declaration:
- Notice that Compact includes support for declaring new types, such as the
  enumeration type that encodes the vacant or occupied state of the bulletin
  board.  With the `export` modifier added to the declaration, the Compact
  compiler will generate TypeScript representations for the enumeration type and
  its values.
- Ledger fields with Compact types (such as `STATE`, `Maybe`, and `Bytes`)
  represent a mutable cell in the ledger, whose value can be updated by
  circuits.
- The ledger's `Counter` type (automatically initialized to zero), can be
  incremented by circuits.
- The builtin Compact `Opaque` type describes values whose internal structure is
  irrelevant to the contract.
- The standard library's `Maybe` type describes values that may be absent.  Its
  values are created using the `some` or `none` constructors.
- The owner's identity tokens are 256-bit hashes, which occupy 32 bytes.
- The standard library `CompactStandardLibrary` contains `Maybe`, `some`,
  `none`, and `Counter`.  (`Opaque` and `Bytes` are builtin Compact types.)

The contract need not explicitly initialize the `owner` field when
the ledger is constructed, because its value is not meaningful yet.
Every ledger field that is not explicitly initialized in the constructor
is initialized to the default value of its type if the type has a default
value.

## Enforcing the contract: circuits

Remember, anyone who uses this bulletin board will be required to
abide by its rules, but *they* must do the work of proving they
satisfied the contract.  When they make changes to the bulletin board,
they submit proofs that they followed the rules, and observers
can quickly verify their proofs.  Such proofs, which observers
can verify without access to the data that enabled the proof
construction, are called *zero-knowledge* proofs, and they are
implemented using *mathematical circuits*.

These ideas are not at all new; some of the important papers about
zero-knowledge proofs were published in the 1980s.  The more recent
developments are advances in the way such proofs can be generated and
verified automatically, without human intervention, and the way they
can be combined with public blockchains.

One of *Midnight's unique contributions* to this space is to make the
definition of zero-knowledge-based smart contracts and their
supporting circuits *accessible to general programmers*.

Begin by writing the `post` operation as a Compact `circuit`
definition.  The main obligation to be satisfied in this part of the
contract is the bulletin board's first rule: posting can occur only
when the board is vacant.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact#L41-L46"
  language="compact"
/>


A `circuit` definition is much like a function definition.  It can specify input
parameters and a return value.  The current state of the ledger is also
implicitly available in the circuit definition.  As with the `enum STATE` type,
an `export` modifier has been added to this definition, so that the `post`
circuit can be called from TypeScript.

To establish enforced contractual obligations, the definition uses the `assert`
statement, which checks that some Boolean expression is true.  If the expression
is false, the transaction is aborted, reporting the failure using the message
specified in the `assert` statement.  The `assert` above checks that the board
is vacant when someone tries to post a message (rule 1).

What is this generated 'public key' that the `post` circuit writes
into the ledger's `owner` field to identify the user posting the
message?  It is derived by hashing a string with the sequence number
of the post and the user's secret key, which is not sent over the
network.  The code above has used a call to a 'helper' circuit
`publicKey`, which is defined in the same contract.  Here is its
definition:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact#L58-L60"
  language="compact"
/>


Three notes about this  definition:
1. The `persistentHash` function is defined in Compact's standard
   library.
2. Typically, you would not export helper circuits like this one,
   because there would be no reason to call them from TypeScript.  In
   this case, `publicKey` is exported so that its value can be logged
   by the DApp, for debugging purposes.
3. While this circuit is named `publicKey`, its return value is *not*
   truly one side of a key pair from public key cryptography.
   Instead, zero-knowledge circuits can be understood as a kind of
   generalization of public key cryptography.  The result of this
   circuit serves the same role as a public key, though, so its
   naming is intended to evoke that sense.

## Accessing private state

So, how to retrieve secret key needed by the `post` circuit and passed
to `publicKey`?  The function `localSecretKey` cannot be another
circuit, because the values returned by circuits are publicly
verifiable, and the value returned by this function should never
appear in the ledger.

This kind of function is called a *witness*.  Witness functions
provide the API to the private state of a contract, as maintained by
individual DApps that use the contract.  The contract does not
describe the definition of the witness; it merely declares the
witness's existence.  The DApp must implement it.  Here is the
declaration in the contract:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact#L39"
  language="compact"
/>



The return values of witnesses are presumed to be private data.  The Compact
compiler tracks them through the program and prevents them from leaking by being
revealed in the public ledger state.  Specifically, in the `post` circuit, the
result of `localSecretKey()` is presumed to be private.  Because this value is
passed to `publicKey`, the result of `publicKey` is also presumed to be
private (or at least, based on private data).  The compiler would signal an
error if it were written into the public ledger state.  In this case however,
the hash of the owner's identity combined with the sequence counter will not
leak the owner's identity.  Wrapping the public key value in `disclose` tells
the Compact compiler that this disclosure is intended.

With all these tools at hand, you can write the `takeDown` circuit,
which enforces the rule that only the owner of the current post can
take it down.  Of course, it also makes no sense to take down a post
from a vacant board, so the circuit checks that first:

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact#L48-L56"
  language="compact"
/>


This circuit returns the message that was taken down, to demonstrate
that public circuits can return values, too.

When a DApp submits a `takeDown` transaction to the Midnight network, it does
not include the private data that would allow other contract participants to
check the second `assert`.  Notice that the Compact compiler does not require
`publicKey` to be explicitly `disclose`d in this circuit.  The `takeDown`
transaction includes a verifiable proof that each `assert` has been checked.
The compiler generates all the material to make this possible 'behind the
scenes,' without the DApp programmer ever having to write code that appears to
generate and transmit proofs.

## Compiling the contract

That's everything.  Here is the complete contract.

<CodeFromGithub
  url="https://github.com/midnightntwrk/example-bboard/blob/main/contract/src/bboard.compact"
  language="compact"
/>


In the `contract` subdirectory of `bboard-tutorial`, there is a build
script to run the Compact compiler as part of the build, but it is
instructive to run the compiler manually this time.

Compile the `bboard.compact` with the Compact compiler
like this (assuming that you have added the Compact compiler's
directory to your `PATH` following the instructions provided in
[Running Midnight Compact compiler](/docs/develop/tutorial/2-building/index.mdx#running-midnight-compact-compiler)
and that your current directory is the
`contract` directory when you run the command):

```shell
compactc src/bboard.compact src/managed/bboard
```

You should see a message about the circuit complexity for each of the
public circuits (`post`, `takeDown`, and `publicKey`) when you run
the compiler.  If you see an error message, check your code for
mistakes.  If you need help, contact the Midnight Developer Relations
team or your fellow developers on Discord.

You can see the TypeScript API that the Compact compiler generated for
the contract in `src/managed/bboard/contract/index.d.cts`.  The DApp
will rely on this API to deploy the contract and call the circuits.
</file>

<file path="docs/develop/tutorial/3-creating/bboard-dapp.mdx">
---
sidebar_label: "Bulletin board DApp"
---


Explore the TypeScript code for a working bulletin board DApp. The complete codebase is available for examination, including the contract interaction logic and private state management.


## Prerequisites

The contract must exist in the `contract/src` subdirectory. Compile the contract to generate the TypeScript API and related files in the `managed` subdirectory.

:::note
The Compact compiler generates the TypeScript API from your Compact contract code. This compilation step produces type-safe interfaces for contract interaction.
:::

The TypeScript code spans three directories:
- `contract/src` - Contract definitions and witness functions
- `api/src` - Application abstractions
- `bboard-cli/src` - Main application run loop

Key files for review:
- `contract/src/witnesses.ts` - Private state and witness function definitions
- `api/src/index.ts` - Application interface implementation

## Define the private state

The blockchain stores public contract state visible to all users. Private state remains local to each DApp instance and varies per user. Contracts declare types for private state access functions but don't define the functions or specify the private state structure. The generated contract API parameterizes certain components by the private state type.

Define an interface or type alias for the private state as a best practice.

The bulletin board's private state contains the user's secret key, which remains constant throughout the application lifecycle. The `localSecretKey()` witness retrieves this value.

The bulletin board contract declares the secret key as a byte array, corresponding to TypeScript's `Uint8Array`. Define `BBoardPrivateState` with a `secretKey` property:

```typescript
// Generated by the Compact compiler, this type definition enables type-safe private state handling
export type BBoardPrivateState = {
  secretKey: Uint8Array;
};
```

The following helper function creates `BBoardPrivateState` objects:

```typescript
export function createBBoardPrivateState(secretKey: Uint8Array): BBoardPrivateState {
  return { secretKey };
}
```

## Initialize the private oracle

Zero-knowledge proof systems use the term *oracle* for components that access private state. This terminology appears throughout the Midnight API and documentation.

The `witnesses` object requires a property or method for each declared witness function. The `bboard.compact` contract declares one witness function: `localSecretKey`.

### Function structure

The function signature contains:
- **Parameter**: `WitnessContext` - Contains ledger state, private state, and contract address
- **Returns**: Tuple containing:
  - New private oracle state
  - Value matching the witness function's declared return type

The `WitnessContext<L, PS>` type includes:
- `ledger: L`
- `privateState: PS`
- `contractAddress: string`

This implementation uses:
- `Ledger` type from the Compact compiler-generated API
- `BBoardPrivateState` from Exercise 1

### Implementation

The `localSecretKey` function returns the unchanged private state (since it doesn't modify state) and the secret key value for contract hash generation and verification:

```typescript
// This witness function integrates with the Compact compiler-generated contract API
export const witnesses = createBBoardWitnesses<BBoardPrivateState>({
  localSecretKey: ({ privateState }) => {
    return [privateState, privateState.secretKey];
  },
});
```

:::important
Never mutate private state in place. Return new state values from witness functions.
:::

:::caution
Avoid global variables for private state. Always use the value passed to witness functions.
:::

## Invoke the post circuit

The `api/src/index.ts` file defines `BBoardAPI`, the application interface for deployed bulletin board contracts.

### Post method implementation

The `post` method submits new messages to the bulletin board. This asynchronous method belongs to the `BBoardAPI` class, initialized with a `DeployedBBoardContract`.

`DeployedBBoardContract` aliases [`FoundContract`](../../reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FoundContract), Midnight.js's abstraction for deployed smart contracts. The application uses `FoundContract` rather than `DeployedContract` because it doesn't require private deployment metadata.

`FoundContract` exposes `callTx`, providing functions for each contract circuit. These functions create and submit transactions.

The bulletin board's `post` method invokes the circuit:

```typescript
// The Compact compiler-generated API provides type-safe circuit invocation
await this.deployedContract.callTx.post([message]);
```

Posting to non-empty boards causes transaction failure and throws an exception. The current implementation propagates exceptions to the main `run` function, causing the DApp to exit. Consider adding try/catch blocks for improved error handling after testing.

## Invoke the take-down circuit

The `takeDown` function follows the `post` method in `api/src/index.ts`.

This method invokes the contract's `takeDown` circuit using the deployed contract's `callTx` property:

```typescript
// The Compact compiler ensures type safety for circuit parameters
await this.deployedContract.callTx.takeDown([]);
```

## Deploy a new bulletin board contract

Contract circuit invocation and transaction submission require minimal code. Contract deployment requires more setup but remains concise.

### Deployment function

The `deploy` function in `api/src/index.ts` contains the `deployContract` call with all required arguments.

`deployContract` requires two arguments:

- **MidnightProviders object**: Contains all necessary provider implementations
- **DeployContractOptions object**: Contains deployment configuration parameters

For bulletin board contracts, `DeployContractOptions` requires:
- `privateStateKey`: Key for storing private state in the `PrivateStateProvider`
- `contract`: `Contract` object containing executable JavaScript (generated by the Compact compiler)
- `initialPrivateState`: Initial private state matching the type stored under `privateStateKey`

### Configuration

#### Private state key

```typescript
privateStateKey: 'bboard-private-state'
```
Unique identifier for retrieving user private state from the configured provider. The system generates and stores new state under this key if none exists.

#### Contract instance

```typescript
contract: bboardContractInstance
```

Defined as:
```typescript
// The Compact compiler generates the Contract class with witness function integration
export const bboardContractInstance = new Contract(witnesses);
```

Creates a `Contract` instance (generated by the Compact compiler) with the witness functions defined earlier.

#### Initial private state

```typescript
initialPrivateState: await getPrivateState(providers.privateStateProvider)
```

The `getPrivateState` method retrieves existing private state or generates new state using 32 random bytes, ensuring consistent and valid private state access.

### Complete deployment call

```typescript
// The Compact compiler-generated Contract class enables type-safe deployment
const deployedContract = await deployContract(providers, {
  privateStateKey: 'bboard-private-state',
  contract: bboardContractInstance,
  initialPrivateState: await getPrivateState(providers.privateStateProvider),
});
```

This minimal code deploys a complete contract to the Midnight blockchain.

### Join existing contracts

The `join` function (below `deploy`) contains similar code for joining existing contracts. Compare both implementations to understand the differences.

### Reference documentation

Explore the Midnight.js reference documentation for library functions:
- [`deployContract`](../../reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/deployContract)
- [`findDeployedContract`](../../reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/functions/findDeployedContract)

## Compile and run the DApp

Navigate to the `example-bboard` directory (containing `contract`, `api`, and `bboard-cli`) and run:

```shell
npx turbo build
```

:::note
The build process uses the Compact compiler output from the `managed` directory to ensure type safety throughout the application.
:::

### Troubleshooting: ERR_UNSUPPORTED_DIR_IMPORT

This Node.js error occurs due to environment caching after modifying `.zshrc`, `.bashrc`, or changing Node versions with NVM.

**Resolution steps:**
1. Open a new terminal window (don't rely on `source ~/.zshrc`)
2. Verify Node version: `nvm use 18`
3. Clear cached modules:
   ```bash
   rm -rf node_modules/.cache
   ```

This environment-related issue affects certain ESM-style imports when the Node.js setup becomes stale.
</file>

<file path="docs/develop/tutorial/3-creating/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Create a new DApp

Learn how to:

- Write a contract that works with both public and private data
- Fill in the missing parts of the DApp code, to create a complete and working DApp
- Run a Midnight node that is *disconnected* from the Midnight Testnet, for testing purposes
- Switch from a test configuration to a production configuration and
   use your new DApp on Testnet.
</file>

<file path="docs/develop/tutorial/3-creating/local-testing.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Midnight test environment"
---

# Midnight test environment

In this tutorial, you ran DApps that were
already complete and tested. In this part, however, you have been
writing portions of the DApp yourself, and you probably want to try
out your work _before_ deploying the DApp to the Midnight network.

The Midnight team has already created a compose file for Docker that
runs a proof server, Midnight node, and Midnight Indexer locally,
configured so that they run disconnected from the Midnight network.
In effect, the Midnight node acts as if it is its own isolated
Midnight network. This allows you to test contracts and DApps
entirely on your own system, before deploying them to the real
network.

If you want to review the details, you can see the Docker compose
definition in this file:

```
example-bboard/bboard-cli/standalone.yml
```

The important part is the environment variable `CFG_PRESET` set to
`dev` in `node` definition. That tells the node to run standalone
without connecting to any other nodes.

Before running this test configuration, you must stop any existing
proof server, indexer, and node. Then, if you want, you can start and
stop the test configuration to verify that it works. 

Do not leave the test configuration running in Docker for the next
steps, though, because you will test the bulletin board DApp by
launching it with a command that starts and stops the whole
`standalone.yml` configuration automatically as part of running the
DApp.

## Run the DApp in standalone mode

In the `example-bboard/bboard-cli` directory, launch the DApp with:

```shell
yarn standalone
```

After verifying that the latest images of the proof server, indexer,
and Midnight node are pulled from the Midnight image server, the DApp
will launch the Docker configuration in `standalone.yml` and wait
for it to be ready.

Then, the DApp will start in standalone mode, not prompting to create
or restore a wallet, but instead, creating a new wallet with tDUST
that is valid only for such offline testing.

:::note Wallet SDK v4.0.0+ Behavior in Standalone Mode
In standalone mode, the DApp uses `@midnight-ntwrk/wallet@4.0.0` to create a disposable wallet. This SDK version introduces important changes:

- Wallets are **always created from a seed**.
- Wallet addresses are shown in **Bech32m format** by default. If you need compatibility with legacy tools, convert them using [`@midnight-ntwrk/wallet-sdk-address-format`](https://www.npmjs.com/package/@midnight-ntwrk/wallet-sdk-address-format).
- Wallet state is no longer sufficient for restoration — the **seed must be preserved** even in offline tests if you want reproducibility.
:::


When the wallet is ready, DApp asks whether it should join an existing
contract or deploy a new one. There is no existing contract to join,
so deploy one. Then, explore the possibilities with the DApp, posting
a message and examining the public and private state.

When you exit the DApp, the Docker containers should stop be and be
cleaned up automatically.

## Run the DApp connected to the Testnet

When you are ready to try out your DApp on the Midnight Testnet, be
sure you have not left it running and that your standalone Docker
configuration has exited. Then,
[start your proof server](../using/proof-server) again. When it is
ready, start the DApp with this command:

```shell
yarn testnet-remote
```

This time, you will need real tDUST, so either create a new wallet and
transfer some tDUST to it from your [Lace wallet](/docs/develop/tutorial/1-using/chrome-ext.mdx),
or look back
at the logs from your experiments with the counter DApp in part 2 to
find the seed for your headless wallet:

```
counter/counter-cli/logs/testnet
```

Once the DApp has found some tDUST in your wallet, it will proceed and
allow you to deploy your bulletin board to Testnet.

## Summary

Have fun playing with the bulletin board DApp. If you are ambitious,
you could create a separate DApp to watch a bulletin board, showing
the messages that are posted and saying when they are taken down. The
code in the `displayLedgerState` function in `bboard-cli/src/index.ts`
will help you get started. You could also share the address of your
bulletin board contract with a friend and see each other's posted
messages.

Congratulations! You have created a working DApp around a non-trivial
Midnight contract, with real rules that are enforced automatically.
You have written parts of the DApp yourself, and you have learned to
test it offline.

At this point, with the help of the reference documentation, you know
enough to begin creating your own command-line contracts and DApps.
Later parts of this developer tutorial will show you how to add a web
UI for your DApps and connect them to the Lace wallet.
</file>

<file path="docs/develop/tutorial/3-creating/scenario.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "Bulletin board scenario"
---

# Bulletin board scenario

Imagine an old-fashioned cork bulletin board on the wall in an office
hallway.  This is a small bulletin board, with room for just a single
piece of paper to be tacked up on it.  Here are the office rules for
this bulletin board:
1. Anyone can post a message on the board when it is vacant.
2. Once someone has posted a message, no one else can take it down.
   Only the person who posted that message may remove it.

Be sure you understand these rules.  The following pages will refer
back to them as 'rule 1' and 'rule 2'.  You can probably imagine
extending them to include content restrictions or time limits on
posts, but they are kept intentionally simple for this tutorial.

What does it look like to implement an online version of this bulletin
board?  A globally shared space where anyone can update a message is
easy to create, but how to enforce the rules?

Rule 1 can be enforced using only the public state of the bulletin
board: if it's empty, allow a new message to be posted, but if it's
occupied, reject attempts to post a message.

Rule 2 is more complicated, because it requires that the identity of
the user attempting to remove a message be verified.  (In fact,
there's another constraint hidden in the English statement of the rule
when it refers to the person who 'posted *that* message.'  This implies
that the user wanting to take down a post is able to prove not only
their identity, but also that they tacked up that specific post.)

One obvious way to enforce rule 2 is to make users 'log in' to the
bulletin board system, so that the system can authenticate their
identities.  This approach requires users to transmit evidence of
their identities across the Internet to the bulletin board server,
usually involving some sort of secret shared between each user and the
server, which the server can verify.

Is there a better way?  With Midnight, yes there is.  You can
contractually obligate anyone who wants to remove a message from the
bulletin board to validate *for themselves, on their own computer*
that they posted it.  Midnight can safely and reliably enforce the
terms of the contract by requiring a machine-checkable proof that the
validation has occurred, without requiring the private evidence of the
user's identity to be transmitted across the Internet.
</file>

<file path="docs/develop/tutorial/3-creating/updatability.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
sidebar_label: "DApp updatability"
---

# DApp updatability

Updating code in a decentralized environment is challenging, because producing
an update is typically a centralized process, and this can be employed
maliciously. It is however often necessary to have some path to changing
deployed contracts and DApps, and Midnight provides this through *Contract
Maintenance Authorities* (CMAs).

By default, as has been the case through this tutorial, a maintenance authority
is empty, meaning no user is able to perform an update to the corresponding
contract. At deploy-time, the deployer can instead nominate a set of public
keys, and specify a threshold for how many of these public keys need to come together to
sign an update, to allow updatability of this contract. This can be used to
decentralize the power to update to a group, which needs to agree and sign off
on updates jointly, or simply to have a single owner control a contract.

:::warning

While Midnight does not require a deployed contract to nominate a CMA, we
strongly advise DApp authors to be aware of the trade-offs involved before
making this decision.

:::

## Why should you care?

Even if your are familiar with updatability in other blockchain ecosystems,
there is an important difference for Midnight that may affect what you think is
right for your DApp. In most ecosystems, a deployed contract is guaranteed to
run as deployed indefinitely, and this lessens the need for updatability. In
Midnight, as contracts *are* in part zero-knowledge proofs, any breaking update
to our proof system – including security updates – may require contracts to
update to the new proof system. Put differently, old contracts *may be
disabled* after system upgrades in the future.

This is especially true prior to mainnet, during which time we will not provide
any support for prior versions of our proof system. At or before mainnet launch
we will refine this support policy. Put differently: We will, with notice,
remove support for old deployments of contracts from Midnight. Updatable
contracts will be able to migrate, but non-upgradable ones will not, by
definition. Refer to the [release compatibility matrix](../../../relnotes/support-matrix) for the complete versions overview.


:::danger

Non-upgradable contracts should plan to allow users to withdraw their funds in
a timely manner (in less than a week) to prevent loss of user funds. Upgradable
contracts should make a commitment to upgrade timelines, or similarly provide a
path to withdraw funds in case the contract is not upgraded.

:::

At this time, Midnight's APIs are tooled only towards one-user authorities,
although the underlying system can cope with arbitrary party configurations.

## Capabilities of a maintenance authority

A contract maintenance authority (CMA) is able to perform various privileged actions
to change a contract after deployment. These make use of a 'verifier key
version', a combined version of proving system and the onchain runtime. A
contract can have multiple active verifier key versions at the same time, and
can have keys registered for each of them. This allows supporting transitions
between versions, and in the future may be used to provide long-term support
for some verifier key versions. A contract maintenance authority can perform
the following privileged actions:

- Change the CMA associated with this contract – this CMA then succeeds the
  current one; this can be used to relinquish control.
- Remove a verifier key (of a specific version) from the contract – this will
  reject future transactions that attempt to use this operation with this
  specific verifier key version. The key removed must exist.
- Add a new verifier key of a specific version – this adds new functionality to
  a contract, or re-exports existing functionality with a new verifier key
  version. A key may not already exist to insert it, it must first be removed.

:::info

Removing and re-adding a verifier key can be used to change the implementation
of a circuit, modifying its behaviour. Be aware that this is a very powerful
capability!

:::

Maintenance authorities can make changes by signing a sequence of the above
'single updates' into a combined 'maintenance update'. Currently, maintenance
updates take effect immediately, although this functionality may be refined
over time.

## How to operate a maintenance authority

Maintaining a maintenance authority introduces three new things for a DApp developer to manage:

1. They need to generate and store key pairs for the authority
2. They need to modify deployment to add the authority
3. They need to provide an interface for the authority to produce and sign updates

The initial contract authority of a contract being deployed can be specified by providing a value for 
[`signingKey`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptions)
in
[`DeployContractOptions`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployContractOptions).
The initial signing key can be sampled with
[`sampleSigningKey`](/develop/reference/midnight-api/compact-runtime/functions/sampleSigningKey).
Note that the same CMA can be used in multiple contracts by specifying the same
signing key for different deployments.

A deployed contract's circuits can be updated using the
[`DeployedContract`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployedContract)
object's
[`circuitMaintenanceTx`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FoundContract#circuitmaintenancetx)
property, which contains one 
[`CircuitMaintenanceTxInterface`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterface)
for each circuit defined on the contract. This allows inserting new verifier keys and removing existing verifier keys with
[`insertVerifierKey`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterface#insertverifierkey)
and
[`removeVerifierKey`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/CircuitMaintenanceTxInterface#removeverifierkey)
respectively.
Similarly, a deployed contract's maintenance authority can be updated using the
[`DeployedContract`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/DeployedContract)'s
[`contractMaintenanceTx`](/develop/reference/midnight-api/midnight-js/@midnight-ntwrk/midnight-js-contracts/type-aliases/FoundContract#contractmaintenancetx)
property. For example, `deployedContract.foo.insertVerifierKey(key)`
inserts the verifier key `key` for the `foo` circuit in the deployed contract
`deployedContract`.
</file>

<file path="docs/develop/tutorial/index.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
slug: /develop/tutorial/
---

# Midnight developer tutorial

The purpose of this tutorial is to introduce you to the experience of
using and creating Midnight decentralized applications (DApps).

All the content on this site is specific to Midnight testnet.  Both the documentation and the Midnight
network itself are subject to change prior to any wider public
release.

:::important

Testnet is a sandboxed development environment, so there are NO guarantees that the environment will persist data.

:::
## Audience

This tutorial is about being a Midnight DApp *developer*, who creates
Midnight DApps.  Midnight DApp *users* will not need to know anything
about how to author smart contracts or how to write DApp software.

The tutorial assumes you want to test drive the Midnight developer
experience without reconfiguring your own computer as a Midnight
developer system.  Therefore, Midnight provides
directory-local configuration files and Docker images that should
minimize the changes to your system.  If you don't already have Docker
installed on your system, the tutorial will point you in the right
direction to get it.

Midnight contracts are described in their own domain-specific
language, but Midnight DApps are written in TypeScript (or
JavaScript).  This tutorial does not assume you are a TypeScript
programmer, but it does assume:

- You are willing to read some TypeScript code.
- You are familiar with using a text editor to edit code.
- You are comfortable interacting with your system in a terminal
  window, typing (and pasting in) commands at a shell prompt.

If those assumptions do not describe you, you might like to review the [learn](../../learn/introduction/what-is-midnight/) section
to explore the features and benefits Midnight provides without getting into the technical details of coding.
</file>

<file path="docs/develop/faq.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# FAQ

## General questions

### Is there a Midnight white paper?

There is no Midnight white paper, but the research paper 'Kachina –
Foundations of Private Smart Contracts', written by researchers Thomas
Kerber et al. at the University of Edinburgh, describes the underlying
cryptography and Universal Composition model powering the Midnight
network. Read more about the architecture and concepts in the
'Learn' section.

### What tokens are available for use on Testnet? Are there gas fees?

Testnet uses only one token: test DUST (**tDUST**), which is a test token used for Midnight Testnet testing purposes only.
Visit the [token acquisition page](/docs/develop/tutorial/1-using/faucet.mdx) to find out more.
This may change in future
versions of Midnight, and may include the calibration of the gas fees against
the amount work performed by a computation.

## Developer questions

### Where do I go if I need help troubleshooting my code?

The [Getting help](./getting-help.mdx) section of this site describes
multiple ways to communicate with the Midnight team and your fellow
developers. Your questions, including those about troubleshooting
your code, are welcome.

### What types of DApps can I build on the Midnight Testnet?

Theoretically, any DApp that does not require one contract to call
another from within its circuits. This includes private payment
DApps, private auction DApps, and DApps that enable shielded identity
verification.

### What types of DApps can _not_ yet be built on Testnet?

DApps that require an oracle (for pricing data info or other external
data), such as a DeFi lending DApp requiring Bitcoin pricing data.

### Can I reuse Solidity code on Midnight?

No, Midnight DApps are created in TypeScript and Compact, a custom
programming language, to build zero-knowledge circuits that generate
privacy proofs.

### What are the key unique concepts or coding patterns I need to know to create DApps on Midnight?

One of the key ideas in Midnight is the distinction between
information that you want to place in the public record and
information that you want to keep private. For example, the assertion
that someone is over 25 might be useful to place in the public space
of a contract, while the details of the person's birthday and precise
age might be kept private. This kind of thinking about what is truly
needed in the public sphere is a core aspect of Midnight programming.

After writing the contract in Midnight’s contract language, the DApp
is written in standard TypeScript. This implies that the coding
experience of existing JavaScript and TypeScript programmers can be
applied to creating Midnight DApps.

### How does Midnight work at a high level?

See the tutorial's [introductory material](./tutorial/high-level-arch.mdx)
and the section of this site about [How Midnight works](./how-midnight-works/).
You can also read more about Midnight's architecture and concepts in
the 'Learn' section.

### What is the current Testnet block time (time to finality)?

Testnet block time is 6 seconds. This time is governed by network
parameters that are subject to adjustment. Finality will occur typically one or
two blocks after block creation (so within 18 seconds).

### I'm getting `ERR_UNSUPPORTED_DIR_IMPORT`. What should I do?

This error typically occurs when Node.js tries to import a directory instead of a specific file, which can happen if your terminal environment is stale after updating `~/.zshrc`, changing Node versions, or setting environment variables.

To fix this:

* Open a new terminal window (don’t just run `source ~/.zshrc`) after changing your shell config or switching Node versions.
* Ensure you're using the correct Node version (Midnight recommends Node 18+). Run:
  ```bash
  nvm use
  ```
* Clear any module cache:
  ```bash
  rm -rf node_modules/.cache
  ```
</file>

<file path="docs/develop/getting-help.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
---

# Getting help

As a participant in the Midnight Testnet, you have the
opportunity to shape the future of Midnight by reporting issues,
suggesting enhancements, and directly influencing the development
process.

## Connectivity failures, bugs, general problems, and suggestions

There are two ways to report problems, make suggestions, give
feedback, or just ask for help:

1. Participate in a discussion on the [Midnight Discord server](https://discord.gg/midnightnetwork). The
   Midnight team will be monitoring the
   `#support` channel
   regularly.
   **Important:** when you first join the Midnight Discord server, you
   must accept the rules in the
   `#rules`
   before you can access other content on the server.
2. Send email to [Midnight support](mailto:support@midnight.network).

## Security vulnerabilities

If you discover any security vulnerabilities in the Midnight libraries
or infrastructure, please report them using the following protocol:

1. Do _not_ post security vulnerabilities on the support channel on
   Discord.
2. Instead, please send a report of what you have found to the
   Midnight support email address: [support@midnight.network](mailto:support@midnight.network).
   If you have a fix or workaround for the vulnerability, please describe that, too.
3. The Midnight team will evaluate your report and may release a fix
   or publish instructions for mitigating the vulnerability. The team
   will inform you of the outcome directly.
4. Unless you request otherwise, the Midnight team will credit you for
   finding the problem in any publication of a fix or mitigation.
5. After the Midnight team has either published a fix or informed you
   that the vulnerability will not be addressed, you are free to
   disclose it publicly.
</file>

<file path="docs/develop/relnotes.mdx">
---
SPDX-License-Identifier: Apache-2.0
copyright: This file is part of midnight-docs. Copyright (C) 2025 Midnight Foundation. Licensed under the Apache License, Version 2.0 (the "License"); You may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
id: relnotes
---

# Release notes

- [Midnight Testnet](/relnotes/midnight-testnet-relnotes.pdf)
- [Midnight Public Devnet v0.1.0 - Release Notes](/relnotes/midnight-public-devnet-0.1.0-relnotes.pdf)  
- [Midnight Devnet v0.0.2 - Release Notes](/relnotes/midnight-devnet-0.0.2-relnotes.pdf)
</file>

</files>
