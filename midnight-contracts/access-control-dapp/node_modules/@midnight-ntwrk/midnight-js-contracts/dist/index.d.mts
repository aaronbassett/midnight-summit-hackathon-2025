import { ContractAddress, CoinPublicKey, ContractState, StateValue, Op, AlignedValue, ZswapLocalState, SigningKey, ShieldedCoinInfo as ShieldedCoinInfo$1 } from '@midnight-ntwrk/compact-runtime';
import { ZswapChainState, PartitionedTranscript, UnprovenTransaction, ShieldedCoinInfo, EncPublicKey, ContractAddress as ContractAddress$1, SigningKey as SigningKey$1 } from '@midnight-ntwrk/ledger-v6';
import { Contract, ImpureCircuitId, CircuitParameters, PrivateState, CircuitReturnType, InitialStateParameters, MidnightProviders, PrivateStateId, FinalizedTxData, VerifierKey, PublicDataProvider, PrivateStateProvider, UnshieldedBalances } from '@midnight-ntwrk/midnight-js-types';

/**
 * Describes the target of a circuit invocation.
 */
type CallOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = {
    /**
     * The contract defining the circuit to call.
     */
    readonly contract: C;
    /**
     * The identifier of the circuit to call.
     */
    readonly circuitId: ICK;
    /**
     * The address of the contract being executed.
     */
    readonly contractAddress: ContractAddress;
};
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the options for a circuit call.
 */
type CallOptionsWithArguments<C extends Contract, ICK extends ImpureCircuitId<C>> = CircuitParameters<C, ICK> extends [] ? CallOptionsBase<C, ICK> : CallOptionsBase<C, ICK> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: CircuitParameters<C, ICK>;
};
/**
 * Data retrieved via providers that should be included in the call options.
 */
type CallOptionsProviderDataDependencies = {
    /**
     * The Zswap public key of the current user.
     */
    readonly coinPublicKey: CoinPublicKey;
    /**
     * The initial public state of the contract to run the circuit against.
     */
    readonly initialContractState: ContractState;
    /**
     * The initial public Zswap state of the contract to run the circuit against.
     */
    readonly initialZswapChainState: ZswapChainState;
};
/**
 * Call options with circuit arguments and data
 */
type CallOptionsWithProviderDataDependencies<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK> & CallOptionsProviderDataDependencies;
/**
 * Call options for contracts with private state.
 */
type CallOptionsWithPrivateState<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithProviderDataDependencies<C, ICK> & {
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Call options for a given contract and circuit.
 */
type CallOptions<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithProviderDataDependencies<C, ICK> | CallOptionsWithPrivateState<C, ICK>;
/**
 * The private (sensitive) portions of the call result.
 */
type CallResultPrivate<C extends Contract, ICK extends ImpureCircuitId<C>> = {
    /**
     * ZK representation of the circuit arguments.
     */
    readonly input: AlignedValue;
    /**
     * ZK representation of the circuit result.
     */
    readonly output: AlignedValue;
    /**
     * ZK representation of the circuit witness call results.
     */
    readonly privateTranscriptOutputs: AlignedValue[];
    /**
     * The JS representation of the input to the circuit.
     */
    readonly result: CircuitReturnType<C, ICK>;
    /**
     * The private state resulting from executing the circuit.
     */
    readonly nextPrivateState: PrivateState<C>;
    /**
     * The Zswap local state resulting from executing the circuit.
     */
    readonly nextZswapLocalState: ZswapLocalState;
};
/**
 * The public portions of the call result.
 */
type CallResultPublic = {
    /**
     * The public state resulting from executing the circuit.
     */
    readonly nextContractState: StateValue;
    /**
     * The public transcript resulting from executing the circuit.
     */
    readonly publicTranscript: Op<AlignedValue>[];
    /**
     * A {@link publicTranscript} partitioned into guaranteed and fallible sections.
     * The guaranteed section of a public transcript must succeed for the corresponding
     * transaction to be considered valid. The fallible section of a public transcript
     * can fail without invalidating the transaction, as long as the guaranteed section succeeds.
     */
    readonly partitionedTranscript: PartitionedTranscript;
};
/**
 * Contains all information resulting from circuit execution.
 */
type CallResult<C extends Contract, ICK extends ImpureCircuitId<C>> = {
    /**
     * The public/non-sensitive data produced by the circuit execution.
     */
    readonly public: CallResultPublic;
    /**
     * The private/sensitive data produced by the circuit execution.
     */
    readonly private: CallResultPrivate<C, ICK>;
};
/**
 * Calls a circuit in the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
declare const call: <C extends Contract, ICK extends ImpureCircuitId<C>>(options: CallOptions<C, ICK>) => CallResult<C, ICK>;

/**
 * Describes the target of a circuit invocation.
 */
type ContractConstructorOptionsBase<C extends Contract> = {
    /**
     * The contract defining the circuit to call.
     */
    readonly contract: C;
};
/**
 * Conditional type that optionally adds the inferred contract constructor argument types
 * to the constructor options.
 */
type ContractConstructorOptionsWithArguments<C extends Contract> = InitialStateParameters<C> extends [] ? ContractConstructorOptionsBase<C> : ContractConstructorOptionsBase<C> & {
    /**
     * Arguments to pass to the circuit being called.
     */
    readonly args: InitialStateParameters<C>;
};
/**
 * Data retrieved via providers that should be included in the constructor call options.
 */
type ContractConstructorOptionsProviderDataDependencies = {
    /**
     * The current user's ZSwap public key.
     */
    readonly coinPublicKey: CoinPublicKey;
};
/**
 * Contract constructor options including arguments and provider data.
 */
type ContractConstructorOptionsWithProviderDataDependencies<C extends Contract> = ContractConstructorOptionsWithArguments<C> & ContractConstructorOptionsProviderDataDependencies;
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
type ContractConstructorOptionsWithPrivateState<C extends Contract> = ContractConstructorOptionsWithProviderDataDependencies<C> & {
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Conditional type that optionally adds the inferred circuit argument types to
 * the target of a circuit invocation.
 */
type ContractConstructorOptions<C extends Contract> = ContractConstructorOptionsWithProviderDataDependencies<C> | ContractConstructorOptionsWithPrivateState<C>;
/**
 * The updated states resulting from executing a contract constructor.
 */
type ContractConstructorResult<C extends Contract> = {
    /**
     * The public state resulting from executing the contract constructor.
     */
    readonly nextContractState: ContractState;
    /**
     * The private state resulting from executing the contract constructor.
     */
    readonly nextPrivateState: PrivateState<C>;
    /**
     * The Zswap local state resulting from executing the contract constructor.
     */
    readonly nextZswapLocalState: ZswapLocalState;
};
/**
 * Calls the constructor of the given contract according to the given configuration.
 *
 * @param options Configuration.
 */
declare const callContractConstructor: <C extends Contract>(options: ContractConstructorOptions<C>) => ContractConstructorResult<C>;

/**
 * Convenience type for representing the set of providers necessary to use
 * a given contract.
 */
type ContractProviders<C extends Contract = Contract, ICK extends ImpureCircuitId<C> = ImpureCircuitId<C>, PS = PrivateState<C>> = MidnightProviders<ICK, PrivateStateId, PS>;

/**
 * Data relevant to any unsubmitted transaction.
 */
type UnsubmittedTxData = {
    /**
     * The unproven ledger transaction produced.
     */
    readonly unprovenTx: UnprovenTransaction;
    /**
     * New coins created during the construction of the transaction.
     */
    readonly newCoins: ShieldedCoinInfo[];
};
/**
 * Base type for public data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxPublicData = {
    /**
     * The ledger address of the contract that was deployed.
     */
    readonly contractAddress: ContractAddress;
    /**
     * The initial public state of the contract deployed to the blockchain.
     */
    readonly initialContractState: ContractState;
};
/**
 * Base type for private data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxPrivateData<C extends Contract> = {
    /**
     * The signing key that was added as the deployed contract's maintenance authority.
     */
    readonly signingKey: SigningKey;
    /**
     * The initial private state of the contract deployed to the blockchain. This
     * value is persisted if the transaction succeeds.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Base type for data relevant to an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxDataBase<C extends Contract> = {
    /**
     * The public data (data that will be revealed upon tx submission) relevant to the deployment transaction.
     */
    readonly public: UnsubmittedDeployTxPublicData;
    /**
     * The private data (data that will not be revealed upon tx submission) relevant to the deployment transaction.
     */
    readonly private: UnsubmittedDeployTxPrivateData<C>;
};
/**
 * Data for an unsubmitted deployment transaction.
 */
type UnsubmittedDeployTxData<C extends Contract> = UnsubmittedDeployTxDataBase<C> & {
    /**
     * The data of this transaction that is only visible on the user device.
     */
    readonly private: UnsubmittedTxData & {
        /**
         * The Zswap state produced as a result of running the contract constructor. Useful for when
         * inputs or outputs are created in the contract constructor.
         */
        readonly initialZswapState: ZswapLocalState;
    };
};
/**
 * Data for a finalized deploy transaction submitted in this process.
 */
type FinalizedDeployTxDataBase<C extends Contract> = UnsubmittedDeployTxDataBase<C> & {
    /**
     * The data of this transaction that is visible on the blockchain.
     */
    readonly public: FinalizedTxData;
};
/**
 * Data for a finalized deploy transaction submitted in this process.
 */
type FinalizedDeployTxData<C extends Contract> = UnsubmittedDeployTxData<C> & {
    /**
     * The data of this transaction that is visible on the blockchain.
     */
    readonly public: FinalizedTxData;
};
/**
 * Data for an unsubmitted call transaction.
 */
type UnsubmittedCallTxData<C extends Contract, ICK extends ImpureCircuitId<C>> = CallResult<C, ICK> & {
    /**
     * Private data relevant to this call transaction.
     */
    readonly private: UnsubmittedTxData;
};
/**
 * Data for a submitted, finalized call transaction.
 */
type FinalizedCallTxData<C extends Contract, ICK extends ImpureCircuitId<C>> = UnsubmittedCallTxData<C, ICK> & {
    /**
     * Public data relevant to this call transaction.
     */
    readonly public: FinalizedTxData;
};

declare function createUnprovenCallTxFromInitialStates<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(options: CallOptionsWithProviderDataDependencies<C, ICK>, walletCoinPublicKey: CoinPublicKey, walletEncryptionPublicKey: EncPublicKey): UnsubmittedCallTxData<C, ICK>;
declare function createUnprovenCallTxFromInitialStates<C extends Contract, ICK extends ImpureCircuitId<C>>(options: CallOptionsWithPrivateState<C, ICK>, walletCoinPublicKey: CoinPublicKey, walletEncryptionPublicKey: EncPublicKey): UnsubmittedCallTxData<C, ICK>;
/**
 * Base type for configuration for a call transaction; identical to {@link CallOptionsWithArguments}.
 */
type CallTxOptionsBase<C extends Contract, ICK extends ImpureCircuitId<C>> = CallOptionsWithArguments<C, ICK>;
/**
 * Call transaction options with the private state ID to use to store the new private
 * state resulting from the circuit call. Since a private state should already be
 * stored at the given private state ID, we don't need an 'initialPrivateState' like
 * in {@link DeployTxOptionsWithPrivateState}.
 */
type CallTxOptionsWithPrivateStateId<C extends Contract, ICK extends ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> & {
    /**
     * The identifier for the private state of the contract.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * Call transaction configuration.
 */
type CallTxOptions<C extends Contract, ICK extends ImpureCircuitId<C>> = CallTxOptionsBase<C, ICK> | CallTxOptionsWithPrivateStateId<C, ICK>;
/**
 * The minimum set of providers needed to create a call transaction, the ZK
 * artifact provider and a wallet. By defining this type, users can choose to
 * omit a private state provider if they're creating a call transaction for a
 * contract with no private state.
 */
type UnprovenCallTxProvidersBase = Pick<ContractProviders, 'publicDataProvider' | 'walletProvider'>;
/**
 * Same providers as {@link UnprovenCallTxProvidersBase} with an additional private
 * state provider to store the new private state resulting from the circuit call -
 * only used when creating a call transaction for a contract with a private state.
 */
type UnprovenCallTxProvidersWithPrivateState<C extends Contract> = UnprovenCallTxProvidersBase & Pick<ContractProviders<C>, 'privateStateProvider'>;
declare function createUnprovenCallTx<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersBase, options: CallTxOptionsBase<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;
declare function createUnprovenCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(providers: UnprovenCallTxProvidersWithPrivateState<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>): Promise<UnsubmittedCallTxData<C, ICK>>;

/**
 * A type that lifts each circuit defined in a contract to a function that builds
 * and submits a call transaction.
 */
type CircuitCallTxInterface<C extends Contract> = {
    [ICK in ImpureCircuitId<C>]: (...args: CircuitParameters<C, ICK>) => Promise<FinalizedCallTxData<C, ICK>>;
};
/**
 * Creates a {@link CallTxOptions} object from various data.
 */
declare const createCallTxOptions: <C extends Contract, ICK extends ImpureCircuitId<C>>(contract: C, circuitId: ICK, contractAddress: ContractAddress$1, privateStateId: PrivateStateId | undefined, args: CircuitParameters<C, ICK>) => CallTxOptions<C, ICK>;
/**
 * Creates a circuit call transaction interface for a contract.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier of the state of the witnesses of the contract.
 */
declare const createCircuitCallTxInterface: <C extends Contract>(providers: ContractProviders<C>, contract: C, contractAddress: ContractAddress$1, privateStateId: PrivateStateId | undefined) => CircuitCallTxInterface<C>;
/**
 * An interface for creating maintenance transactions for a specific circuit defined in a
 * given contract.
 */
type CircuitMaintenanceTxInterface = {
    /**
     * Constructs and submits a transaction that removes the current verifier key stored
     * on the blockchain for this circuit at this contract's address.
     */
    removeVerifierKey(): Promise<FinalizedTxData>;
    /**
     * Constructs and submits a transaction that adds a new verifier key to the
     * blockchain for this circuit at this contract's address.
     *
     * @param newVk The new verifier key to add for this circuit.
     */
    insertVerifierKey(newVk: VerifierKey): Promise<FinalizedTxData>;
};
/**
 * Creates a {@link CircuitMaintenanceTxInterface}.
 *
 * @param providers The providers to use to create and submit transactions.
 * @param circuitId The circuit ID the interface is for.
 * @param contractAddress The address of the deployed contract for which this
 *                        interface is being created.
 */
declare const createCircuitMaintenanceTxInterface: <C extends Contract, ICK extends ImpureCircuitId<C>>(providers: ContractProviders<C, ICK>, circuitId: ICK, contractAddress: ContractAddress$1) => CircuitMaintenanceTxInterface;
/**
 * A set of maintenance transaction creation interfaces, one for each circuit defined in
 * a given contract, keyed by the circuit name.
 */
type CircuitMaintenanceTxInterfaces<C extends Contract> = Record<ImpureCircuitId<C>, CircuitMaintenanceTxInterface>;
/**
 * Creates a {@link CircuitMaintenanceTxInterfaces}.
 *
 * @param providers The providers to use to build transactions.
 * @param contract The contract to use to execute circuits.
 * @param contractAddress The ledger address of the contract.
 */
declare const createCircuitMaintenanceTxInterfaces: <C extends Contract>(providers: ContractProviders<C>, contract: C, contractAddress: ContractAddress$1) => CircuitMaintenanceTxInterfaces<C>;
/**
 * Interface for creating maintenance transactions for a contract that was
 * deployed.
 */
interface ContractMaintenanceTxInterface {
    /**
     * Constructs and submits a transaction that replaces the maintenance
     * authority stored on the blockchain for this contract.
     *
     * @param newAuthority The new contract maintenance authority for this contract.
     */
    replaceAuthority(newAuthority: SigningKey): Promise<FinalizedTxData>;
}
/**
 * Creates a {@link ContractMaintenanceTxInterface}.
 *
 * @param providers The providers to use to build transactions.
 * @param contractAddress The ledger address of the contract.
 */
declare const createContractMaintenanceTxInterface: (providers: ContractProviders, contractAddress: ContractAddress$1) => ContractMaintenanceTxInterface;

/**
 * Checks that two verifier keys are equal. Does initial length check match for efficiency.
 *
 * @param a First verifier key.
 * @param b Second verifier key.
 */
declare const verifierKeysEqual: (a: Uint8Array, b: Uint8Array) => boolean;
/**
 * Checks that the given `contractState` contains the given `verifierKeys`.
 *
 * @param verifierKeys The verifier keys the client has for the deployed contract we're checking.
 * @param contractState The (typically already deployed) contract state containing verifier keys.
 *
 * @throws ContractTypeError When one or more of the local and deployed verifier keys do not match.
 */
declare const verifyContractState: (verifierKeys: [ImpureCircuitId, VerifierKey][], contractState: ContractState) => void;
/**
 * Base type for the configuration options for {@link findDeployedContract}.
 */
type FindDeployedContractOptionsBase<C extends Contract> = {
    /**
     * The contract to use to execute circuits.
     */
    readonly contract: C;
    /**
     * The address of a previously deployed contract.
     */
    readonly contractAddress: ContractAddress;
    /**
     * The signing key to use to perform contract maintenance updates. If defined, the given signing
     * key is stored for this contract address. This is useful when someone has already added the given signing
     * key to the contract maintenance authority. If undefined, and there is an existing signing key for the
     * contract address locally, the existing signing key is kept. This is useful when the contract was
     * deployed locally. If undefined, and there is not an existing signing key for the contract address
     * locally, a fresh signing key is generated and stored for the contract address locally. This is
     * useful when you want to give a signing key to someone else to add you as a maintenance authority.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link findDeployedContract} base configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
type FindDeployedContractOptionsExistingPrivateState<C extends Contract> = FindDeployedContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * {@link findDeployedContract} configuration that includes an initial private
 * state to store and the private state ID at which to store it. Only used if
 * the intention is to overwrite the private state currently stored at the given
 * private state ID.
 */
type FindDeployedContractOptionsStorePrivateState<C extends Contract> = FindDeployedContractOptionsExistingPrivateState<C> & {
    /**
     * For types of contract that make no use of private state and or witnesses that operate upon it, this
     * property may be `undefined`. Otherwise, the value provided via this property should be same initial
     * state that was used when calling {@link deployContract}.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Configuration for {@link findDeployedContract}.
 */
type FindDeployedContractOptions<C extends Contract> = FindDeployedContractOptionsBase<C> | FindDeployedContractOptionsExistingPrivateState<C> | FindDeployedContractOptionsStorePrivateState<C>;
/**
 * Base type for a deployed contract that has been found on the blockchain.
 */
type FoundContract<C extends Contract> = {
    /**
     * Data for the finalized deploy transaction corresponding to this contract.
     */
    readonly deployTxData: FinalizedDeployTxDataBase<C>;
    /**
     * Interface for creating call transactions for a contract.
     */
    readonly callTx: CircuitCallTxInterface<C>;
    /**
     * An interface for creating maintenance transactions for circuits defined in the
     * contract that was deployed.
     */
    readonly circuitMaintenanceTx: CircuitMaintenanceTxInterfaces<C>;
    /**
     * Interface for creating maintenance transactions for the contract that was
     * deployed.
     */
    readonly contractMaintenanceTx: ContractMaintenanceTxInterface;
};
declare function findDeployedContract<C extends Contract<undefined>>(providers: ContractProviders<C, ImpureCircuitId<C>, unknown>, options: FindDeployedContractOptionsBase<C>): Promise<FoundContract<C>>;
declare function findDeployedContract<C extends Contract>(providers: ContractProviders<C>, options: FindDeployedContractOptionsExistingPrivateState<C>): Promise<FoundContract<C>>;
declare function findDeployedContract<C extends Contract>(providers: ContractProviders<C>, options: FindDeployedContractOptionsStorePrivateState<C>): Promise<FoundContract<C>>;

/**
 * Base type for configuration for {@link deployContract}; identical to
 * {@link ContractConstructorOptionsWithArguments} except the `signingKey` is
 * now optional, since {@link deployContract} will generate a fresh signing key
 * in the event that `signingKey` is undefined.
 */
type DeployContractOptionsBase<C extends Contract> = ContractConstructorOptionsWithArguments<C> & {
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     * If undefined, a new signing key is sampled and used as the CMA then stored
     * in the private state provider under the newly deployed contract's address.
     * Otherwise, the passed signing key is added as the CMA. The second case is
     * useful when you want to use the same CMA for two different contracts.
     */
    readonly signingKey?: SigningKey;
};
/**
 * {@link deployContract} base options with information needed to store private states;
 * only used if the contract being deployed has a private state.
 */
type DeployContractOptionsWithPrivateState<C extends Contract> = DeployContractOptionsBase<C> & {
    /**
     * An identifier for the private state of the contract being found.
     */
    readonly privateStateId: PrivateStateId;
    /**
     * The private state to run the circuit against.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Configuration for {@link deployContract}.
 */
type DeployContractOptions<C extends Contract> = DeployContractOptionsBase<C> | DeployContractOptionsWithPrivateState<C>;
/**
 * Interface for a contract that has been deployed to the blockchain.
 */
type DeployedContract<C extends Contract> = FoundContract<C> & {
    /**
     * Data resulting from the deployment transaction that created this contract. The information in a
     * {@link deployTxData} contains additional private information that does not
     * exist in {@link FoundContract.deployTxData} because certain private data is only available to
     * the deployer of a contract.
     */
    readonly deployTxData: FinalizedDeployTxData<C>;
};
declare function deployContract<C extends Contract<undefined>>(providers: ContractProviders<C, ImpureCircuitId<C>, unknown>, options: DeployContractOptionsBase<C>): Promise<DeployedContract<C>>;
declare function deployContract<C extends Contract>(providers: ContractProviders<C>, options: DeployContractOptionsWithPrivateState<C>): Promise<DeployedContract<C>>;

/**
 * An error indicating that a transaction submitted to a consensus node failed.
 */
declare class TxFailedError extends Error {
    readonly finalizedTxData: FinalizedTxData;
    readonly circuitId?: ImpureCircuitId | undefined;
    /**
     * @param finalizedTxData The finalization data of the transaction that failed.
     * @param circuitId The name of the circuit that was called to create the call
     *                  transaction that failed. Only defined if a call transaction
     *                  failed.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId?: ImpureCircuitId | undefined);
}
/**
 * An error indicating that a deploy transaction was not successfully applied by the consensus node.
 */
declare class DeployTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the deployment transaction that failed.
     */
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a call transaction was not successfully applied by the consensus node.
 */
declare class CallTxFailedError extends TxFailedError {
    /**
     * @param finalizedTxData The finalization data of the call transaction that failed.
     * @param circuitId The name of the circuit that was called to build the transaction.
     */
    constructor(finalizedTxData: FinalizedTxData, circuitId: ImpureCircuitId);
}
/**
 * The error that is thrown when there is a contract type mismatch between a given contract type,
 * and the initial state that is deployed at a given contract address.
 *
 * @remarks
 * This error is typically thrown during calls to {@link findDeployedContract} where the supplied contract
 * address represents a different type of contract to the contract type given.
 */
declare class ContractTypeError extends TypeError {
    readonly contractState: ContractState;
    readonly circuitIds: ImpureCircuitId[];
    /**
     * Initializes a new {@link ContractTypeError}.
     *
     * @param contractState The initial deployed contract state.
     * @param circuitIds The circuits that are undefined, or have a verifier key mismatch with the
     *                   key present in `contractState`.
     */
    constructor(contractState: ContractState, circuitIds: ImpureCircuitId[]);
}
/**
 * An error indicating that a contract maintenance authority replacement transaction failed.
 */
declare class ReplaceMaintenanceAuthorityTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key removal transaction failed.
 */
declare class RemoveVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a verifier key insertion transaction failed.
 */
declare class InsertVerifierKeyTxFailedError extends TxFailedError {
    constructor(finalizedTxData: FinalizedTxData);
}
/**
 * An error indicating that a private state ID was specified for a call transaction while a private
 * state provider was not. We want to let the user know so that they aren't under the impression the
 * private state of a contract was updated when it wasn't.
 */
declare class IncompleteCallTxPrivateStateConfig extends Error {
    constructor();
}
/**
 * An error indicating that an initial private state was specified for a contract find while a
 * private state ID was not. We can't store the initial private state if we don't have a private state ID,
 * and we need to let the user know that.
 */
declare class IncompleteFindContractPrivateStateConfig extends Error {
    constructor();
}

/**
 * Object containing the publicly visible states of a contract.
 */
type PublicContractStates = {
    /**
     * The (public) Zswap chain state of a contract.
     */
    readonly zswapChainState: ZswapChainState;
    /**
     * The (public) ledger state of a contract.
     */
    readonly contractState: ContractState;
};
/**
 * Object containing the publicly visible states of a contract and the private
 * state of a contract.
 */
type ContractStates<PS> = PublicContractStates & {
    /**
     * The private state of a contract.
     */
    readonly privateState: PS;
};
/**
 * Fetches only the public visible (Zswap and ledger) states of a contract.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
declare const getPublicStates: (publicDataProvider: PublicDataProvider, contractAddress: ContractAddress$1) => Promise<PublicContractStates>;
/**
 * Retrieves the Zswap, ledger, and private states of the contract corresponding
 * to the given identifier using the given providers.
 *
 * @param publicDataProvider The provider to use to fetch the public states (Zswap and ledger)
 *                           from the blockchain.
 * @param privateStateProvider The provider to use to fetch the private state.
 * @param contractAddress The ledger address of the contract.
 * @param privateStateId The identifier for the private state of the contract.
 */
declare const getStates: <PS>(publicDataProvider: PublicDataProvider, privateStateProvider: PrivateStateProvider<PrivateStateId, PS>, contractAddress: ContractAddress$1, privateStateId: PrivateStateId) => Promise<ContractStates<PS>>;

/**
 * Fetches the unshielded balances associated with a specific contract address.
 *
 * @param publicDataProvider The provider to use to fetch the unshielded balances from the blockchain.
 * @param contractAddress The ledger address of the contract.
 */
declare const getUnshieldedBalances: (publicDataProvider: PublicDataProvider, contractAddress: ContractAddress$1) => Promise<UnshieldedBalances>;

/**
 * Configuration for {@link submitTx}.
 */
type SubmitTxOptions<ICK extends ImpureCircuitId> = {
    /**
     * The transaction to prove, balance, and submit.
     */
    readonly unprovenTx: UnprovenTransaction;
    /**
     * Any new coins created during the construction of the transaction. Only defined
     * if the transaction being submitted is a call or deploy transaction.
     */
    readonly newCoins?: ShieldedCoinInfo$1[];
    /**
     * A circuit identifier to use to fetch the ZK artifacts needed to prove the
     * transaction. Only defined if a call transaction is being submitted.
     */
    readonly circuitId?: ICK;
};
/**
 * Providers required to submit an unproven deployment transaction. Since {@link submitTx} doesn't
 * manipulate private state, the private state provider can be omitted.
 */
type SubmitTxProviders<C extends Contract, ICK extends ImpureCircuitId<C>> = Omit<ContractProviders<C, ICK>, 'privateStateProvider'>;
/**
 * Proves, balances, and submits an unproven deployment or call transaction using
 * the given providers, according to the given options.
 *
 * @param providers The providers used to manage the transaction lifecycle.
 * @param options Configuration.
 *
 * @returns A promise that resolves with the finalized transaction data for the invocation,
 *          or rejects if an error occurs along the way.
 */
declare const submitTx: <C extends Contract, ICK extends ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: SubmitTxOptions<ICK>) => Promise<FinalizedTxData>;

declare function submitCallTx<C extends Contract<undefined>, ICK extends ImpureCircuitId<C>>(providers: SubmitTxProviders<C, ICK>, options: CallTxOptionsBase<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;
declare function submitCallTx<C extends Contract, ICK extends ImpureCircuitId<C>>(providers: ContractProviders<C>, options: CallTxOptionsWithPrivateStateId<C, ICK>): Promise<FinalizedCallTxData<C, ICK>>;

/**
 * Base type for deploy transaction configuration.
 */
type DeployTxOptionsBase<C extends Contract> = ContractConstructorOptionsWithArguments<C> & {
    /**
     * The signing key to add as the to-be-deployed contract's maintenance authority.
     */
    readonly signingKey: SigningKey;
};
/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration used as a base type for the {@link DeployTxOptionsWithPrivateStateId} configuration.
 * It is also used directly as parameter to {@link createUnprovenDeployTx} which doesn't need
 * to save private state (and therefore doesn't need a private state ID) but does need to supply an
 * initial private state to run the contract constructor against.
 */
type DeployTxOptionsWithPrivateState<C extends Contract> = DeployTxOptionsBase<C> & {
    /**
     * The private state to run the contract constructor against.
     */
    readonly initialPrivateState: PrivateState<C>;
};
/**
 * Configuration for creating deploy transactions for contracts with private state. This
 * configuration is used when a deployment transaction is created and an initial private
 * state needs to be stored, as is the case in {@link submitDeployTx}.
 */
type DeployTxOptionsWithPrivateStateId<C extends Contract> = DeployTxOptionsWithPrivateState<C> & {
    /**
     * The identifier for the private state of the contract.
     */
    readonly privateStateId: PrivateStateId;
};
/**
 * Configuration for creating unproven deploy transactions.
 */
type UnprovenDeployTxOptions<C extends Contract> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateState<C>;
declare function createUnprovenDeployTxFromVerifierKeys<C extends Contract<undefined>>(verifierKeys: [ImpureCircuitId<C>, VerifierKey][], coinPublicKey: CoinPublicKey, options: DeployTxOptionsBase<C>, encryptionPublicKey: EncPublicKey): UnsubmittedDeployTxData<C>;
declare function createUnprovenDeployTxFromVerifierKeys<C extends Contract>(verifierKeys: [ImpureCircuitId<C>, VerifierKey][], coinPublicKey: CoinPublicKey, options: DeployTxOptionsWithPrivateState<C>, encryptionPublicKey: EncPublicKey): UnsubmittedDeployTxData<C>;
/**
 * Providers needed to create an unproven deployment transactions, just the ZK artifact
 * provider and a wallet.
 */
type UnprovenDeployTxProviders<C extends Contract> = Pick<ContractProviders<C>, 'zkConfigProvider' | 'walletProvider'>;
declare function createUnprovenDeployTx<C extends Contract<undefined>>(providers: UnprovenDeployTxProviders<C>, options: DeployTxOptionsBase<C>): Promise<UnsubmittedDeployTxData<C>>;
declare function createUnprovenDeployTx<C extends Contract>(providers: UnprovenDeployTxProviders<C>, options: DeployTxOptionsWithPrivateState<C>): Promise<UnsubmittedDeployTxData<C>>;

/**
 * Configuration for creating deploy transactions.
 */
type DeployTxOptions<C extends Contract> = DeployTxOptionsBase<C> | DeployTxOptionsWithPrivateStateId<C>;
declare function submitDeployTx<C extends Contract<undefined>>(providers: ContractProviders<C, ImpureCircuitId<C>, unknown>, options: DeployTxOptionsBase<C>): Promise<FinalizedDeployTxData<C>>;
declare function submitDeployTx<C extends Contract>(providers: ContractProviders<C>, options: DeployTxOptionsWithPrivateStateId<C>): Promise<FinalizedDeployTxData<C>>;

/**
 * Constructs and submits a transaction that adds a new verifier key to the
 * blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be inserted.
 * @param circuitId The circuit for which the verifier key should be inserted.
 * @param newVk The new verifier key for the circuit.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
declare const submitInsertVerifierKeyTx: (providers: ContractProviders, contractAddress: ContractAddress$1, circuitId: ImpureCircuitId, newVk: VerifierKey) => Promise<FinalizedTxData>;

/**
 * Constructs and submits a transaction that removes the current verifier key stored
 * on the blockchain for the given circuit ID at the given contract address.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract containing the circuit for which
 *                        the verifier key should be removed.
 * @param circuitId The circuit for which the verifier key should be removed.
 *
 * @returns A promise that resolves with the finalized transaction data, or rejects if
 *          an error occurs along the way.
 *
 * TODO: We'll likely want to modify ZKConfigProvider provider so that the verifier keys are
 *       automatically rotated in this function. This likely involves storing key versions
 *       along with keys in ZKConfigProvider. By default, artifacts for the latest version
 *       would be fetched to build transactions.
 */
declare const submitRemoveVerifierKeyTx: (providers: ContractProviders, contractAddress: ContractAddress$1, circuitId: ImpureCircuitId) => Promise<FinalizedTxData>;

/**
 * Constructs and submits a transaction that replaces the maintenance
 * authority stored on the blockchain for this contract. After the transaction is
 * finalized, the current signing key stored in the given private state provider
 * is overwritten with the given new authority key.
 *
 * @param providers The providers to use to manage the transaction lifecycle.
 * @param contractAddress The address of the contract for which the maintenance
 *                        authority should be updated.
 *
 * TODO: There are at least three options we should support in the future:
 *       1. Replace authority and maintain key (current).
 *       2. Replace authority and do not maintain key.
 *       3. Add additional authorities and maintain original key.
 */
declare const submitReplaceAuthorityTx: (providers: ContractProviders, contractAddress: ContractAddress$1) => (newAuthority: SigningKey$1) => Promise<FinalizedTxData>;

export { CallTxFailedError, ContractTypeError, DeployTxFailedError, IncompleteCallTxPrivateStateConfig, IncompleteFindContractPrivateStateConfig, InsertVerifierKeyTxFailedError, RemoveVerifierKeyTxFailedError, ReplaceMaintenanceAuthorityTxFailedError, TxFailedError, call, callContractConstructor, createCallTxOptions, createCircuitCallTxInterface, createCircuitMaintenanceTxInterface, createCircuitMaintenanceTxInterfaces, createContractMaintenanceTxInterface, createUnprovenCallTx, createUnprovenCallTxFromInitialStates, createUnprovenDeployTx, createUnprovenDeployTxFromVerifierKeys, deployContract, findDeployedContract, getPublicStates, getStates, getUnshieldedBalances, submitCallTx, submitDeployTx, submitInsertVerifierKeyTx, submitRemoveVerifierKeyTx, submitReplaceAuthorityTx, submitTx, verifierKeysEqual, verifyContractState };
export type { CallOptions, CallOptionsBase, CallOptionsProviderDataDependencies, CallOptionsWithArguments, CallOptionsWithPrivateState, CallOptionsWithProviderDataDependencies, CallResult, CallResultPrivate, CallResultPublic, CallTxOptions, CallTxOptionsBase, CallTxOptionsWithPrivateStateId, CircuitCallTxInterface, CircuitMaintenanceTxInterface, CircuitMaintenanceTxInterfaces, ContractConstructorOptions, ContractConstructorOptionsBase, ContractConstructorOptionsProviderDataDependencies, ContractConstructorOptionsWithArguments, ContractConstructorOptionsWithPrivateState, ContractConstructorOptionsWithProviderDataDependencies, ContractConstructorResult, ContractMaintenanceTxInterface, ContractProviders, ContractStates, DeployContractOptions, DeployContractOptionsBase, DeployContractOptionsWithPrivateState, DeployTxOptions, DeployTxOptionsBase, DeployTxOptionsWithPrivateState, DeployTxOptionsWithPrivateStateId, DeployedContract, FinalizedCallTxData, FinalizedDeployTxData, FinalizedDeployTxDataBase, FindDeployedContractOptions, FindDeployedContractOptionsBase, FindDeployedContractOptionsExistingPrivateState, FindDeployedContractOptionsStorePrivateState, FoundContract, PublicContractStates, SubmitTxOptions, SubmitTxProviders, UnprovenCallTxProvidersBase, UnprovenCallTxProvidersWithPrivateState, UnprovenDeployTxOptions, UnprovenDeployTxProviders, UnsubmittedCallTxData, UnsubmittedDeployTxData, UnsubmittedDeployTxDataBase, UnsubmittedDeployTxPrivateData, UnsubmittedDeployTxPublicData, UnsubmittedTxData };
